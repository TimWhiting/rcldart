// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to the ros client library dynamic libraries
///
class RCL {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RCL(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RCL.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<rosidl_service_type_support_t> get_service_typesupport_handle(
    ffi.Pointer<rosidl_service_type_support_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return _get_service_typesupport_handle(
      handle,
      identifier,
    );
  }

  late final _get_service_typesupport_handle_ptr =
      _lookup<ffi.NativeFunction<_c_get_service_typesupport_handle>>(
          'get_service_typesupport_handle');
  late final _dart_get_service_typesupport_handle
      _get_service_typesupport_handle = _get_service_typesupport_handle_ptr
          .asFunction<_dart_get_service_typesupport_handle>();

  ffi.Pointer<rosidl_service_type_support_t>
      get_service_typesupport_handle_function(
    ffi.Pointer<rosidl_service_type_support_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return _get_service_typesupport_handle_function(
      handle,
      identifier,
    );
  }

  late final _get_service_typesupport_handle_function_ptr =
      _lookup<ffi.NativeFunction<_c_get_service_typesupport_handle_function>>(
          'get_service_typesupport_handle_function');
  late final _dart_get_service_typesupport_handle_function
      _get_service_typesupport_handle_function =
      _get_service_typesupport_handle_function_ptr
          .asFunction<_dart_get_service_typesupport_handle_function>();

  /// Return a zero initialized allocator.
  /// /**
  ///  * Note that this is an invalid allocator and should only be used as a placeholder.
  ///  */
  rcutils_allocator_t rcutils_get_zero_initialized_allocator() {
    return _rcutils_get_zero_initialized_allocator();
  }

  late final _rcutils_get_zero_initialized_allocator_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_zero_initialized_allocator>>(
          'rcutils_get_zero_initialized_allocator');
  late final _dart_rcutils_get_zero_initialized_allocator
      _rcutils_get_zero_initialized_allocator =
      _rcutils_get_zero_initialized_allocator_ptr
          .asFunction<_dart_rcutils_get_zero_initialized_allocator>();

  /// Return a properly initialized rcutils_allocator_t with default values.
  /// /**
  ///  * This defaults to:
  ///  *
  ///  * - allocate = wraps malloc()
  ///  * - deallocate = wraps free()
  ///  * - reallocate = wraps realloc()
  ///  * - zero_allocate = wraps calloc()
  ///  * - state = `NULL`
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  */
  rcutils_allocator_t rcutils_get_default_allocator() {
    return _rcutils_get_default_allocator();
  }

  late final _rcutils_get_default_allocator_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_default_allocator>>(
          'rcutils_get_default_allocator');
  late final _dart_rcutils_get_default_allocator
      _rcutils_get_default_allocator = _rcutils_get_default_allocator_ptr
          .asFunction<_dart_rcutils_get_default_allocator>();

  /// Return true if the given allocator has non-null function pointers.
  /// /**
  ///  * Will also return false if the allocator pointer is null.
  ///  */
  bool rcutils_allocator_is_valid(
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_allocator_is_valid(
          allocator,
        ) !=
        0;
  }

  late final _rcutils_allocator_is_valid_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_allocator_is_valid>>(
          'rcutils_allocator_is_valid');
  late final _dart_rcutils_allocator_is_valid _rcutils_allocator_is_valid =
      _rcutils_allocator_is_valid_ptr
          .asFunction<_dart_rcutils_allocator_is_valid>();

  /// Emulate the behavior of [reallocf](https://linux.die.net/man/3/reallocf).
  /// /**
  ///  * This function will return `NULL` if the allocator is `NULL` or has `NULL` for
  ///  * function pointer fields.
  ///  */
  ffi.Pointer<ffi.Void> rcutils_reallocf(
    ffi.Pointer<ffi.Void> pointer,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_reallocf(
      pointer,
      size,
      allocator,
    );
  }

  late final _rcutils_reallocf_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_reallocf>>('rcutils_reallocf');
  late final _dart_rcutils_reallocf _rcutils_reallocf =
      _rcutils_reallocf_ptr.asFunction<_dart_rcutils_reallocf>();

  /// Format a string.
  /// /**
  ///  * This function just wraps snprintf() as defined in C11 in a portable way.
  ///  *
  ///  * On Windows this defaults to the _TRUNCATE behavior of _snprintf_s(), but
  ///  * only returns -1 if errno is not 0.
  ///  * Unlike _snprintf_s() which returns -1 when truncation occurs, this function
  ///  * behaves like snprintf() (http://en.cppreference.com/w/cpp/io/c/fprintf):
  ///  *
  ///  * > Number of characters written if successful or negative value if an error
  ///  * > occurred.
  ///  * > If the resulting string gets truncated due to buf_size limit, function
  ///  * > returns the total number of characters (not including the terminating
  ///  * > null-byte) which would have been written, if the limit was not imposed.
  ///  *
  ///  * If `NULL` and `0` are given for buffer and buffer_size respectively, the
  ///  * size of the string that would be generated is returned.
  ///  * Either snprintf() or _vscprintf() is used to calculate this value.
  ///  *
  ///  * \see snprintf()
  ///  * \see _snprintf_s()
  ///  * \returns the number of bytes that would have been written given enough space,
  ///  *   or a negative number if there is an error, but unlike _snprintf_s(),
  ///  *   -1 is not returned if there is truncation.
  ///  */
  int rcutils_snprintf(
    ffi.Pointer<ffi.Int8> buffer,
    int buffer_size,
    ffi.Pointer<ffi.Int8> format,
  ) {
    return _rcutils_snprintf(
      buffer,
      buffer_size,
      format,
    );
  }

  late final _rcutils_snprintf_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_snprintf>>('rcutils_snprintf');
  late final _dart_rcutils_snprintf _rcutils_snprintf =
      _rcutils_snprintf_ptr.asFunction<_dart_rcutils_snprintf>();

  /// Format a string with va_list for arguments, see rcutils_snprintf().
  int rcutils_vsnprintf(
    ffi.Pointer<ffi.Int8> buffer,
    int buffer_size,
    ffi.Pointer<ffi.Int8> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _rcutils_vsnprintf(
      buffer,
      buffer_size,
      format,
      args,
    );
  }

  late final _rcutils_vsnprintf_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_vsnprintf>>('rcutils_vsnprintf');
  late final _dart_rcutils_vsnprintf _rcutils_vsnprintf =
      _rcutils_vsnprintf_ptr.asFunction<_dart_rcutils_vsnprintf>();

  /// Forces initialization of thread-local storage if called in a newly created thread.
  /// /**
  ///  * If this function is not called beforehand, then the first time the error
  ///  * state is set or the first time the error message is retrieved, the default
  ///  * allocator will be used to allocate thread-local storage.
  ///  *
  ///  * This function may or may not allocate memory.
  ///  * The system's thread-local storage implementation may need to allocate
  ///  * memory, since it usually has no way of knowing how much storage is needed
  ///  * without knowing how many threads will be created.
  ///  * Most implementations (e.g. C11, C++11, and pthread) do not have ways to
  ///  * specify how this memory is allocated, but if the implementation allows, the
  ///  * given allocator to this function will be used, but is otherwise unused.
  ///  * This only occurs when creating and destroying threads, which can be avoided
  ///  * in the "steady" state by reusing pools of threads.
  ///  *
  ///  * It is worth considering that repeated thread creation and destruction will
  ///  * result in repeated memory allocations and could result in memory
  ///  * fragmentation.
  ///  * This is typically avoided anyways by using pools of threads.
  ///  *
  ///  * In case an error is indicated by the return code, no error message will have
  ///  * been set.
  ///  *
  ///  * If called more than once in a thread, or after implicitly initialized by
  ///  * setting the error state, it will still return `RCUTILS_RET_OK`, even
  ///  * if the given allocator is invalid.
  ///  * Essentially this function does nothing if thread-local storage has already
  ///  * been called.
  ///  * If already initialized, the given allocator is ignored, even if it does not
  ///  * match the allocator used originally to initialize the thread-local storage.
  ///  *
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if the allocator is invalid, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if allocating memory fails, or
  ///  * \return `RCUTILS_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcutils_initialize_error_handling_thread_local_storage(
    rcutils_allocator_t allocator,
  ) {
    return _rcutils_initialize_error_handling_thread_local_storage(
      allocator,
    );
  }

  late final _rcutils_initialize_error_handling_thread_local_storage_ptr =
      _lookup<
              ffi.NativeFunction<
                  _c_rcutils_initialize_error_handling_thread_local_storage>>(
          'rcutils_initialize_error_handling_thread_local_storage');
  late final _dart_rcutils_initialize_error_handling_thread_local_storage
      _rcutils_initialize_error_handling_thread_local_storage =
      _rcutils_initialize_error_handling_thread_local_storage_ptr.asFunction<
          _dart_rcutils_initialize_error_handling_thread_local_storage>();

  /// Set the error message, as well as the file and line on which it occurred.
  /// /**
  ///  * This is not meant to be used directly, but instead via the
  ///  * RCUTILS_SET_ERROR_MSG(msg) macro.
  ///  *
  ///  * The error_msg parameter is copied into the internal error storage and must
  ///  * be null terminated.
  ///  * The file parameter is copied into the internal error storage and must
  ///  * be null terminated.
  ///  *
  ///  * \param[in] error_string The error message to set.
  ///  * \param[in] file The path to the file in which the error occurred.
  ///  * \param[in] line_number The line number on which the error occurred.
  ///  */
  void rcutils_set_error_state(
    ffi.Pointer<ffi.Int8> error_string,
    ffi.Pointer<ffi.Int8> file,
    int line_number,
  ) {
    return _rcutils_set_error_state(
      error_string,
      file,
      line_number,
    );
  }

  late final _rcutils_set_error_state_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_set_error_state>>(
          'rcutils_set_error_state');
  late final _dart_rcutils_set_error_state _rcutils_set_error_state =
      _rcutils_set_error_state_ptr.asFunction<_dart_rcutils_set_error_state>();

  /// Return `true` if the error is set, otherwise `false`.
  bool rcutils_error_is_set() {
    return _rcutils_error_is_set() != 0;
  }

  late final _rcutils_error_is_set_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_error_is_set>>(
          'rcutils_error_is_set');
  late final _dart_rcutils_error_is_set _rcutils_error_is_set =
      _rcutils_error_is_set_ptr.asFunction<_dart_rcutils_error_is_set>();

  /// Return an rcutils_error_state_t which was set with rcutils_set_error_state().
  /// /**
  ///  * The returned pointer will be NULL if no error has been set in this thread.
  ///  *
  ///  * The returned pointer is valid until RCUTILS_SET_ERROR_MSG, rcutils_set_error_state,
  ///  * or rcutils_reset_error are called in the same thread.
  ///  *
  ///  * \return A pointer to the current error state struct.
  ///  */
  ffi.Pointer<rcutils_error_state_t> rcutils_get_error_state() {
    return _rcutils_get_error_state();
  }

  late final _rcutils_get_error_state_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_error_state>>(
          'rcutils_get_error_state');
  late final _dart_rcutils_get_error_state _rcutils_get_error_state =
      _rcutils_get_error_state_ptr.asFunction<_dart_rcutils_get_error_state>();

  /// Return the error message followed by `, at <file>:<line>` if set, else "error not set".
  /// /**
  ///  * This function is "safe" because it returns a copy of the current error
  ///  * string or one containing the string "error not set" if no error was set.
  ///  * This ensures that the copy is owned by the calling thread and is therefore
  ///  * never invalidated by other error handling calls, and that the C string
  ///  * inside is always valid and null terminated.
  ///  *
  ///  * \return The current error string, with file and line number, or "error not set" if not set.
  ///  */
  rcutils_error_string_t rcutils_get_error_string() {
    return _rcutils_get_error_string();
  }

  late final _rcutils_get_error_string_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_error_string>>(
          'rcutils_get_error_string');
  late final _dart_rcutils_get_error_string _rcutils_get_error_string =
      _rcutils_get_error_string_ptr
          .asFunction<_dart_rcutils_get_error_string>();

  /// Reset the error state by clearing any previously set error state.
  void rcutils_reset_error() {
    return _rcutils_reset_error();
  }

  late final _rcutils_reset_error_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_reset_error>>(
          'rcutils_reset_error');
  late final _dart_rcutils_reset_error _rcutils_reset_error =
      _rcutils_reset_error_ptr.asFunction<_dart_rcutils_reset_error>();

  /// Return an empty array_list struct.
  /// /**
  ///  * This function returns an empty and zero initialized array_list struct.
  ///  * Calling rcutils_array_list_fini() on any non-initialized instance leads
  ///  * to undefined behavior.
  ///  * Every instance of array_list_t has to either be zero_initialized with this
  ///  * function or manually allocated.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * rcutils_array_list_t foo;
  ///  * rcutils_array_list_fini(&foo); // undefined behavior!
  ///  *
  ///  * rcutils_array_list_t bar = rcutils_get_zero_initialized_array_list();
  ///  * rcutils_array_list_fini(&bar); // ok
  ///  * ```
  ///  */
  rcutils_array_list_t rcutils_get_zero_initialized_array_list() {
    return _rcutils_get_zero_initialized_array_list();
  }

  late final _rcutils_get_zero_initialized_array_list_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_zero_initialized_array_list>>(
          'rcutils_get_zero_initialized_array_list');
  late final _dart_rcutils_get_zero_initialized_array_list
      _rcutils_get_zero_initialized_array_list =
      _rcutils_get_zero_initialized_array_list_ptr
          .asFunction<_dart_rcutils_get_zero_initialized_array_list>();

  /// Initialize an array list with a given initial capacity.
  /// /**
  ///  * This function will initialize a given, zero initialized, array_list to
  ///  * a given size.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * rcutils_allocator_t allocator = rcutils_get_default_allocator();
  ///  * rcutils_array_list_t array_list = rcutils_get_zero_initialized_array_list();
  ///  * rcutils_ret_t ret = rcutils_array_list_init(&array_list, 2, sizeof(int), &allocator);
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... error handling
  ///  * }
  ///  * int data = 42;
  ///  * int out_data = 0;
  ///  * ret = rcutils_array_list_add(&array_list, &data);
  ///  * data++;
  ///  * ret = rcutils_array_list_get(&array_list, 0, &out_data);
  ///  * assert(42 == out_data);
  ///  * ret = rcutils_array_list_fini(&array_list);
  ///  * ```
  ///  *
  ///  * \param[inout] array_list object to be initialized
  ///  * \param[in] initial_capacity the initial capacity to allocate in the list
  ///  * \param[in] data_size the size (in bytes) of the data object being stored in the list
  ///  * \param[in] allocator to be used to allocate and deallocate memory
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_array_list_init(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int initial_capacity,
    int data_size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_array_list_init(
      array_list,
      initial_capacity,
      data_size,
      allocator,
    );
  }

  late final _rcutils_array_list_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_array_list_init>>(
          'rcutils_array_list_init');
  late final _dart_rcutils_array_list_init _rcutils_array_list_init =
      _rcutils_array_list_init_ptr.asFunction<_dart_rcutils_array_list_init>();

  /// Finalize an array list, reclaiming all resources.
  /// /**
  ///  * This function reclaims any memory owned by the array list.
  ///  *
  ///  * The allocator used to initialize the array list is used to deallocate each
  ///  * entry in the list and the list itself.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] array_list object to be finalized
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_array_list_fini(
    ffi.Pointer<rcutils_array_list_t> array_list,
  ) {
    return _rcutils_array_list_fini(
      array_list,
    );
  }

  late final _rcutils_array_list_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_array_list_fini>>(
          'rcutils_array_list_fini');
  late final _dart_rcutils_array_list_fini _rcutils_array_list_fini =
      _rcutils_array_list_fini_ptr.asFunction<_dart_rcutils_array_list_fini>();

  /// Adds an entry to the list
  /// /**
  ///  * This function adds the provided data to the end of the list. A shallow copy of
  ///  * the provided data is made to store in the list instead of just storing
  ///  * the pointer to the provided data.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] array_list to add the data to
  ///  * \param[in] data a pointer to the data to add to the list
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_array_list_add(
    ffi.Pointer<rcutils_array_list_t> array_list,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_array_list_add(
      array_list,
      data,
    );
  }

  late final _rcutils_array_list_add_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_array_list_add>>(
          'rcutils_array_list_add');
  late final _dart_rcutils_array_list_add _rcutils_array_list_add =
      _rcutils_array_list_add_ptr.asFunction<_dart_rcutils_array_list_add>();

  /// Sets an entry in the list to the provided data
  /// /**
  ///  * This function sets the provided data at the specified index in the list.
  ///  * A shallow copy of the provided data is made to store in the list instead
  ///  * of just storing the pointer to the provided data.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] array_list to add the data to
  ///  * \param[in] index the position in the list to set the data
  ///  * \param[in] data a pointer to the data that will be set in the list
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if index out of bounds, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_array_list_set(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_array_list_set(
      array_list,
      index,
      data,
    );
  }

  late final _rcutils_array_list_set_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_array_list_set>>(
          'rcutils_array_list_set');
  late final _dart_rcutils_array_list_set _rcutils_array_list_set =
      _rcutils_array_list_set_ptr.asFunction<_dart_rcutils_array_list_set>();

  /// Removes an entry in the list at the provided index
  /// /**
  ///  * This function removes data from the list at the specified index. The capacity
  ///  * of the list will never decrease when entries are removed.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] array_list to add the data to
  ///  * \param[in] index the index of the item to remove from the list
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if index out of bounds, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_array_list_remove(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
  ) {
    return _rcutils_array_list_remove(
      array_list,
      index,
    );
  }

  late final _rcutils_array_list_remove_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_array_list_remove>>(
          'rcutils_array_list_remove');
  late final _dart_rcutils_array_list_remove _rcutils_array_list_remove =
      _rcutils_array_list_remove_ptr
          .asFunction<_dart_rcutils_array_list_remove>();

  /// Retrieves an entry in the list at the provided index
  /// /**
  ///  * This function retrieves a copy of the data stored in the list at the provided index.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  *
  ///  * \param[in] array_list to add the data to
  ///  * \param[in] index the index at which to get the data
  ///  * \param[out] data a copy of the data stored in the list
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_array_list_get(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_array_list_get(
      array_list,
      index,
      data,
    );
  }

  late final _rcutils_array_list_get_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_array_list_get>>(
          'rcutils_array_list_get');
  late final _dart_rcutils_array_list_get _rcutils_array_list_get =
      _rcutils_array_list_get_ptr.asFunction<_dart_rcutils_array_list_get>();

  /// Retrieves the size of the provided array_list
  /// /**
  ///  * This function retrieves the number of items in the provided array list
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  *
  ///  * \param[in] array_list list to get the size of
  ///  * \param[out] size The number of items currently stored in the list
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_array_list_get_size(
    ffi.Pointer<rcutils_array_list_t> array_list,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return _rcutils_array_list_get_size(
      array_list,
      size,
    );
  }

  late final _rcutils_array_list_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_array_list_get_size>>(
          'rcutils_array_list_get_size');
  late final _dart_rcutils_array_list_get_size _rcutils_array_list_get_size =
      _rcutils_array_list_get_size_ptr
          .asFunction<_dart_rcutils_array_list_get_size>();

  /// Return a zero initialized char array struct.
  /// /**
  ///  * \return rcutils_char_array_t a zero initialized char array struct
  ///  */
  rcutils_char_array_t rcutils_get_zero_initialized_char_array() {
    return _rcutils_get_zero_initialized_char_array();
  }

  late final _rcutils_get_zero_initialized_char_array_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_zero_initialized_char_array>>(
          'rcutils_get_zero_initialized_char_array');
  late final _dart_rcutils_get_zero_initialized_char_array
      _rcutils_get_zero_initialized_char_array =
      _rcutils_get_zero_initialized_char_array_ptr
          .asFunction<_dart_rcutils_get_zero_initialized_char_array>();

  /// Initialize a zero initialized char array struct.
  /// /**
  ///  * This function may leak if the char array struct is already
  ///  * pre-initialized.
  ///  * If the capacity is set to 0, no memory is allocated and the internal buffer
  ///  * is still NULL.
  ///  *
  ///  * \param char_array a pointer to the to be initialized char array struct
  ///  * \param buffer_capacity the size of the memory to allocate for the byte stream
  ///  * \param allocator the allocator to use for the memory allocation
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENTS` if any arguments are invalid, or
  ///  * \return 'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_init(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int buffer_capacity,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_char_array_init(
      char_array,
      buffer_capacity,
      allocator,
    );
  }

  late final _rcutils_char_array_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_init>>(
          'rcutils_char_array_init');
  late final _dart_rcutils_char_array_init _rcutils_char_array_init =
      _rcutils_char_array_init_ptr.asFunction<_dart_rcutils_char_array_init>();

  /// Finalize a char array struct.
  /// /**
  ///  * Cleans up and deallocates any resources owned by rcutils_char_array_t.
  ///  * The array passed to this function needs to have been initialized by
  ///  * rcutils_char_array_init().
  ///  * If .owns_buffer is false, this function has no effect because that
  ///  * implies that the char_array does not own the internal buffer.
  ///  * Passing an uninitialized instance to this function leads to undefined
  ///  * behavior.
  ///  *
  ///  * \param char_array pointer to the rcutils_char_array_t to be cleaned up
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENTS` if the char_array argument is invalid
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_fini(
    ffi.Pointer<rcutils_char_array_t> char_array,
  ) {
    return _rcutils_char_array_fini(
      char_array,
    );
  }

  late final _rcutils_char_array_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_fini>>(
          'rcutils_char_array_fini');
  late final _dart_rcutils_char_array_fini _rcutils_char_array_fini =
      _rcutils_char_array_fini_ptr.asFunction<_dart_rcutils_char_array_fini>();

  /// Resize the internal buffer of the char array.
  /// /**
  ///  * The internal buffer of the char array can be resized dynamically if needed.
  ///  * If the new size is smaller than the current capacity, then the memory is
  ///  * truncated.
  ///  * Be aware, that this will deallocate the memory and therefore invalidates any
  ///  * pointers to this storage.
  ///  * If the new size is larger, new memory is getting allocated and the existing
  ///  * content is copied over.
  ///  * Note that if the array doesn't own the current buffer the function just
  ///  * allocates a new block of memory and copies the contents of the old buffer
  ///  * instead of resizing the existing buffer.
  ///  *
  ///  * \param char_array pointer to the instance of rcutils_char_array_t which is being resized
  ///  * \param new_size the new size of the internal buffer
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if new_size is set to zero
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_resize(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int new_size,
  ) {
    return _rcutils_char_array_resize(
      char_array,
      new_size,
    );
  }

  late final _rcutils_char_array_resize_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_resize>>(
          'rcutils_char_array_resize');
  late final _dart_rcutils_char_array_resize _rcutils_char_array_resize =
      _rcutils_char_array_resize_ptr
          .asFunction<_dart_rcutils_char_array_resize>();

  /// Expand the internal buffer of the char array.
  /// /**
  ///  * This function is equivalent to `rcutils_char_array_resize` except that it resizes
  ///  * the internal buffer only when it is not big enough.
  ///  * If the buffer is already big enough for `new_size`, it returns `RCUTILS_RET_OK` without
  ///  * doing anything.
  ///  *
  ///  * \param char_array pointer to the instance of rcutils_char_array_t which is being resized
  ///  * \param new_size the new size of the internal buffer
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_expand_as_needed(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int new_size,
  ) {
    return _rcutils_char_array_expand_as_needed(
      char_array,
      new_size,
    );
  }

  late final _rcutils_char_array_expand_as_needed_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_expand_as_needed>>(
          'rcutils_char_array_expand_as_needed');
  late final _dart_rcutils_char_array_expand_as_needed
      _rcutils_char_array_expand_as_needed =
      _rcutils_char_array_expand_as_needed_ptr
          .asFunction<_dart_rcutils_char_array_expand_as_needed>();

  /// Produce output according to format and args.
  /// /**
  ///  * This function is equivalent to `vsprintf(char_array->buffer, format, args)`
  ///  * except that the buffer grows as needed so a user doesn't have to deal with
  ///  * memory management.
  ///  * The `va_list args` will be cloned before being used, so a user can safely
  ///  * use it again after calling this function.
  ///  *
  ///  * \param char_array pointer to the instance of rcutils_char_array_t which is being written to
  ///  * \param format the format string used by the underlying `vsnprintf`
  ///  * \param args the `va_list` used by the underlying `vsnprintf`
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_vsprintf(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return _rcutils_char_array_vsprintf(
      char_array,
      format,
      args,
    );
  }

  late final _rcutils_char_array_vsprintf_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_vsprintf>>(
          'rcutils_char_array_vsprintf');
  late final _dart_rcutils_char_array_vsprintf _rcutils_char_array_vsprintf =
      _rcutils_char_array_vsprintf_ptr
          .asFunction<_dart_rcutils_char_array_vsprintf>();

  /// Append a string (or part of it) to the string in buffer.
  /// /**
  ///  * This function treats the internal buffer as a string and appends the src string to it.
  ///  * If src is longer than n, n bytes will be used and an extra null byte will be appended.
  ///  * It is virtually equivalent to `strncat(char_array->buffer, src, n)` except that the buffer
  ///  * grows as needed so a user doesn't have to deal with memory management.
  ///  *
  ///  * \param char_array pointer to the instance of rcutils_char_array_t which is being appended to
  ///  * \param src the string to be appended to the end of the string in buffer
  ///  * \param n it uses at most n bytes from the src string
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_strncat(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> src,
    int n,
  ) {
    return _rcutils_char_array_strncat(
      char_array,
      src,
      n,
    );
  }

  late final _rcutils_char_array_strncat_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_strncat>>(
          'rcutils_char_array_strncat');
  late final _dart_rcutils_char_array_strncat _rcutils_char_array_strncat =
      _rcutils_char_array_strncat_ptr
          .asFunction<_dart_rcutils_char_array_strncat>();

  /// Append a string to the string in buffer.
  /// /**
  ///  * This function treats the internal buffer as a string and appends the src string to it.
  ///  * It is virtually equivalent to `strcat(char_array->buffer, src)` except that the buffer
  ///  * grows as needed. That is to say, a user can safely use it without doing calculation or
  ///  * checks on the sizes of the src and buffer.
  ///  *
  ///  * \param char_array pointer to the instance of rcutils_char_array_t which is being appended to
  ///  * \param src the string to be appended to the end of the string in buffer
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_strcat(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> src,
  ) {
    return _rcutils_char_array_strcat(
      char_array,
      src,
    );
  }

  late final _rcutils_char_array_strcat_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_strcat>>(
          'rcutils_char_array_strcat');
  late final _dart_rcutils_char_array_strcat _rcutils_char_array_strcat =
      _rcutils_char_array_strcat_ptr
          .asFunction<_dart_rcutils_char_array_strcat>();

  /// Copy memory to buffer.
  /// /**
  ///  * This function is equivalent to `memcpy(char_array->buffer, src, n)` except that the buffer
  ///  * grows as needed so a user doesn't have to worry about overflow.
  ///  *
  ///  * \param char_array pointer to the instance of rcutils_char_array_t which is being resized
  ///  * \param src the memory to be copied from
  ///  * \param n a total of n bytes will be copied
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_memcpy(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> src,
    int n,
  ) {
    return _rcutils_char_array_memcpy(
      char_array,
      src,
      n,
    );
  }

  late final _rcutils_char_array_memcpy_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_memcpy>>(
          'rcutils_char_array_memcpy');
  late final _dart_rcutils_char_array_memcpy _rcutils_char_array_memcpy =
      _rcutils_char_array_memcpy_ptr
          .asFunction<_dart_rcutils_char_array_memcpy>();

  /// Copy a string to buffer.
  /// /**
  ///  * This function is equivalent to `strcpy(char_array->buffer, src)` except that the buffer
  ///  * grows as needed so that `src` will fit without overflow.
  ///  *
  ///  * \param char_array pointer to the instance of rcutils_char_array_t which is being copied to
  ///  * \param src the string to be copied from
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_char_array_strcpy(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> src,
  ) {
    return _rcutils_char_array_strcpy(
      char_array,
      src,
    );
  }

  late final _rcutils_char_array_strcpy_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_char_array_strcpy>>(
          'rcutils_char_array_strcpy');
  late final _dart_rcutils_char_array_strcpy _rcutils_char_array_strcpy =
      _rcutils_char_array_strcpy_ptr
          .asFunction<_dart_rcutils_char_array_strcpy>();

  /// A hashing function for a null terminated c string.
  /// /**
  ///  * A hashing function for a null terminated c string.
  ///  * Should be used when your key is just a pointer to a c-string
  ///  */
  int rcutils_hash_map_string_hash_func(
    ffi.Pointer<ffi.Void> key_str,
  ) {
    return _rcutils_hash_map_string_hash_func(
      key_str,
    );
  }

  late final _rcutils_hash_map_string_hash_func_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_string_hash_func>>(
          'rcutils_hash_map_string_hash_func');
  late final _dart_rcutils_hash_map_string_hash_func
      _rcutils_hash_map_string_hash_func =
      _rcutils_hash_map_string_hash_func_ptr
          .asFunction<_dart_rcutils_hash_map_string_hash_func>();

  /// A comparison function for a null terminated c string.
  /// /**
  ///  * A comparison function for a null terminated c string.
  ///  * Should be used when your key is just a pointer to a c-string
  ///  */
  int rcutils_hash_map_string_cmp_func(
    ffi.Pointer<ffi.Void> val1,
    ffi.Pointer<ffi.Void> val2,
  ) {
    return _rcutils_hash_map_string_cmp_func(
      val1,
      val2,
    );
  }

  late final _rcutils_hash_map_string_cmp_func_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_string_cmp_func>>(
          'rcutils_hash_map_string_cmp_func');
  late final _dart_rcutils_hash_map_string_cmp_func
      _rcutils_hash_map_string_cmp_func = _rcutils_hash_map_string_cmp_func_ptr
          .asFunction<_dart_rcutils_hash_map_string_cmp_func>();

  /// Return an empty hash_map struct.
  /// /*
  ///  * This function returns an empty and zero initialized hash_map struct.
  ///  * All hash maps should be initialized with this or manually initialized
  ///  * before being used.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  * ```c
  ///  * // Do not do this:
  ///  * // rcutils_hash_map_t foo;
  ///  * // rcutils_hash_map_fini(&foo); // undefined behavior!
  ///  *
  ///  * // Do this instead:
  ///  * rcutils_hash_map_t bar = rcutils_get_zero_initialized_hash_map();
  ///  * rcutils_hash_map_fini(&bar); // ok
  ///  * ```
  ///  * */
  rcutils_hash_map_t rcutils_get_zero_initialized_hash_map() {
    return _rcutils_get_zero_initialized_hash_map();
  }

  late final _rcutils_get_zero_initialized_hash_map_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_zero_initialized_hash_map>>(
          'rcutils_get_zero_initialized_hash_map');
  late final _dart_rcutils_get_zero_initialized_hash_map
      _rcutils_get_zero_initialized_hash_map =
      _rcutils_get_zero_initialized_hash_map_ptr
          .asFunction<_dart_rcutils_get_zero_initialized_hash_map>();

  /// Initialize a rcutils_hash_map_t, allocating space for given capacity.
  /// /**
  ///  * This function initializes the rcutils_hash_map_t with a given initial
  ///  * capacity for entries.
  ///  * Note this does not allocate space for keys or values in the hash_map, just the
  ///  * arrays of pointers to the keys and values.
  ///  * rcutils_hash_map_set() should still be used when assigning values.
  ///  *
  ///  * The hash_map argument should point to allocated memory and should have
  ///  * been zero initialized with rcutils_get_zero_initialized_hash_map().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  * ```c
  ///  * rcutils_hash_map_t hash_map = rcutils_get_zero_initialized_hash_map();
  ///  * rcutils_ret_t ret =
  ///  *   rcutils_hash_map_init(&hash_map, 10, rcutils_get_default_allocator());
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... do error handling
  ///  * }
  ///  * // ... use the hash_map and when done:
  ///  * ret = rcutils_hash_map_fini(&hash_map);
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... do error handling
  ///  * }
  ///  * ```
  ///  *
  ///  * \param[inout] hash_map rcutils_hash_map_t to be initialized
  ///  * \param[in] initial_capacity the amount of initial capacity for the hash_map
  ///  * \param[in] key_size the size (in bytes) of the key used to index the data
  ///  * \param[in] data_size the size (in bytes) of the data being stored
  ///  * \param[in] key_hashing_func a function that returns a hashed value for a key
  ///  * \param[in] key_cmp_func a function used to compare keys
  ///  * \param[in] allocator the allocator to use through out the lifetime of the hash_map
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_STRING_MAP_ALREADY_INIT` if already initialized, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_hash_map_init(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    int initial_capacity,
    int key_size,
    int data_size,
    ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_hasher_t>>
        key_hashing_func,
    ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_cmp_t>> key_cmp_func,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_hash_map_init(
      hash_map,
      initial_capacity,
      key_size,
      data_size,
      key_hashing_func,
      key_cmp_func,
      allocator,
    );
  }

  late final _rcutils_hash_map_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_init>>(
          'rcutils_hash_map_init');
  late final _dart_rcutils_hash_map_init _rcutils_hash_map_init =
      _rcutils_hash_map_init_ptr.asFunction<_dart_rcutils_hash_map_init>();

  /// Finalize the previously initialized hash_map struct.
  /// /**
  ///  * This function will free any resources which were created when initializing
  ///  * or when calling rcutils_hash_map_set().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] hash_map rcutils_hash_map_t to be finalized
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_hash_map_fini(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
  ) {
    return _rcutils_hash_map_fini(
      hash_map,
    );
  }

  late final _rcutils_hash_map_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_fini>>(
          'rcutils_hash_map_fini');
  late final _dart_rcutils_hash_map_fini _rcutils_hash_map_fini =
      _rcutils_hash_map_fini_ptr.asFunction<_dart_rcutils_hash_map_fini>();

  /// Get the current capacity of the hash_map.
  /// /**
  ///  * This function will return the internal capacity of the hash_map, which is the
  ///  * number of buckets the hash_map uses to sort the keys.
  ///  * The capacity does not indicate how many key value pairs are stored in the
  ///  * hash_map, the rcutils_hash_map_get_size() function can provide that, nor the
  ///  * maximum number that can be stored without increasing the capacity.
  ///  * The capacity can be set initially with rcutils_hash_map_init().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be queried
  ///  * \param[out] capacity capacity of the hash_map
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_hash_map_get_capacity(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Uint64> capacity,
  ) {
    return _rcutils_hash_map_get_capacity(
      hash_map,
      capacity,
    );
  }

  late final _rcutils_hash_map_get_capacity_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_get_capacity>>(
          'rcutils_hash_map_get_capacity');
  late final _dart_rcutils_hash_map_get_capacity
      _rcutils_hash_map_get_capacity = _rcutils_hash_map_get_capacity_ptr
          .asFunction<_dart_rcutils_hash_map_get_capacity>();

  /// Get the current size of the hash_map.
  /// /**
  ///  * This function will return the internal size of the hash_map, which is the
  ///  * current number of key value pairs in the hash_map.
  ///  * The size is changed when calling rcutils_hash_map_set() or rcutils_hash_map_unset().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be queried
  ///  * \param[out] size size of the hash_map
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_hash_map_get_size(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return _rcutils_hash_map_get_size(
      hash_map,
      size,
    );
  }

  late final _rcutils_hash_map_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_get_size>>(
          'rcutils_hash_map_get_size');
  late final _dart_rcutils_hash_map_get_size _rcutils_hash_map_get_size =
      _rcutils_hash_map_get_size_ptr
          .asFunction<_dart_rcutils_hash_map_get_size>();

  /// Set a key value pair in the hash_map, increasing capacity if necessary.
  /// /**
  ///  * If the key already exists in the map then the value is updated to the new value
  ///  * provided. If it does not already exist then a new entry is added for the new key
  ///  * and value. The capacity will be increased if needed.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] hash_map rcutils_hash_map_t to be updated
  ///  * \param[in] key hash_map key
  ///  * \param[in] value value for given hash_map key
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_hash_map_set(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
  ) {
    return _rcutils_hash_map_set(
      hash_map,
      key,
      value,
    );
  }

  late final _rcutils_hash_map_set_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_set>>(
          'rcutils_hash_map_set');
  late final _dart_rcutils_hash_map_set _rcutils_hash_map_set =
      _rcutils_hash_map_set_ptr.asFunction<_dart_rcutils_hash_map_set>();

  /// Unset a key value pair in the hash_map.
  /// /**
  ///  * Unsets the key value pair in the hash_map and frees any internal resources allocated
  ///  * for the entry. This function will never decrease the capacity when removing keys.
  ///  * If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] hash_map rcutils_hash_map_t to be updated
  ///  * \param[in] key hash_map key, must be null terminated c string
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  ///  * \return `RCUTILS_RET_STRING_KEY_NOT_FOUND` if the key is not found in the map, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_hash_map_unset(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _rcutils_hash_map_unset(
      hash_map,
      key,
    );
  }

  late final _rcutils_hash_map_unset_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_unset>>(
          'rcutils_hash_map_unset');
  late final _dart_rcutils_hash_map_unset _rcutils_hash_map_unset =
      _rcutils_hash_map_unset_ptr.asFunction<_dart_rcutils_hash_map_unset>();

  /// Get whether or not a key exists.
  /// /**
  ///  * Returns true if the provided key exists in the hash_map or false if it does not or
  ///  * if the hash_map or key are invalid.
  ///  * In all cases no error message is set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be searched
  ///  * \param[in] key hash_map key, must be null terminated c string
  ///  * \return `true` if key is in the hash_map, or
  ///  * \return `false` if key is not in the hash_map, or
  ///  * \return `false` for invalid arguments, or
  ///  * \return `false` if the hash_map is invalid
  ///  */
  bool rcutils_hash_map_key_exists(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
  ) {
    return _rcutils_hash_map_key_exists(
          hash_map,
          key,
        ) !=
        0;
  }

  late final _rcutils_hash_map_key_exists_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_key_exists>>(
          'rcutils_hash_map_key_exists');
  late final _dart_rcutils_hash_map_key_exists _rcutils_hash_map_key_exists =
      _rcutils_hash_map_key_exists_ptr
          .asFunction<_dart_rcutils_hash_map_key_exists>();

  /// Get value given a key.
  /// /**
  ///  * This function can be used to retrieve a shallow copy of the stored data. The data
  ///  * pointer must point to a section of memory large enough to copy the full size of
  ///  * the data being stored, which is specified when the hash_map in initialized.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be searched
  ///  * \param[in] key hash_map key to look up the data for
  ///  * \param[out] data A copy of the data stored in the map
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  ///  * \return `RCUTILS_RET_NOT_FOUND` if the key doesn't exist in the map, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_hash_map_get(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_hash_map_get(
      hash_map,
      key,
      data,
    );
  }

  late final _rcutils_hash_map_get_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_get>>(
          'rcutils_hash_map_get');
  late final _dart_rcutils_hash_map_get _rcutils_hash_map_get =
      _rcutils_hash_map_get_ptr.asFunction<_dart_rcutils_hash_map_get>();

  /// Get the next key in the hash_map, unless NULL is given, then get the first key.
  /// /**
  ///  * This function allows you to iteratively get each key/value pair in the hash_map.
  ///  *
  ///  * If NULL is given for the previous_key, then the first key in the hash_map is returned.
  ///  * If that returned key is given as the previous_key for the next call to this function,
  ///  * then the next key in the hash_map is returned.
  ///  * If there are no more keys in the hash_map or if the given key is not in the hash_map,
  ///  * an error will be returned.
  ///  *
  ///  * The order of the keys in the hash_map is arbitrary and if the hash_map is modified
  ///  * between calls to this function the behavior is undefined.
  ///  * If the hash_map is modified then iteration should begin again by passing NULL to
  ///  * get the first key again.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * Example:
  ///  * ```c
  ///  * printf("entries in the hash_map:\n");
  ///  * int key = 0, data = 0;
  ///  * rcutils_ret_t status = rcutils_hash_map_get_next_key(&hash_map, NULL, &key, &data);
  ///  * while (RCUTILS_RET_OK == status) {
  ///  *   printf("%i: %i\n", key, data);
  ///  *   status = rcutils_hash_map_get_next_key(&hash_map, &key, &key, &data);
  ///  * }
  ///  * ```
  ///  *
  ///  * \param[in] hash_map rcutils_hash_map_t to be queried
  ///  * \param[in] previous_key NULL to get the first key or the previous key to get the next for
  ///  * \param[out] key A copy of the next key in the sequence
  ///  * \param[out] data A copy of the next data in the sequence
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  ///  * \return `RCUTILS_RET_NOT_FOUND` if the previous_key doesn't exist in the map, or
  ///  * \return `RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES` if there is no more data beyound the previous_key, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_hash_map_get_next_key_and_data(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> previous_key,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> data,
  ) {
    return _rcutils_hash_map_get_next_key_and_data(
      hash_map,
      previous_key,
      key,
      data,
    );
  }

  late final _rcutils_hash_map_get_next_key_and_data_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_hash_map_get_next_key_and_data>>(
          'rcutils_hash_map_get_next_key_and_data');
  late final _dart_rcutils_hash_map_get_next_key_and_data
      _rcutils_hash_map_get_next_key_and_data =
      _rcutils_hash_map_get_next_key_and_data_ptr
          .asFunction<_dart_rcutils_hash_map_get_next_key_and_data>();

  /// Return an empty string array struct.
  /// /**
  ///  * This function returns an empty and zero initialized string array struct.
  ///  * Calling rcutils_string_array_fini() on any non-initialized instance leads
  ///  * to undefined behavior.
  ///  * Every instance of string_array_t has to either be zero_initialized with this
  ///  * function or manually allocated.
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * rcutils_string_array_t foo;
  ///  * rcutils_string_array_fini(&foo); // undefined behavior!
  ///  *
  ///  * rcutils_string_array_t bar = rcutils_get_zero_initialized_string_array();
  ///  * rcutils_string_array_fini(&bar); // ok
  ///  * ```
  ///  */
  rcutils_string_array_t rcutils_get_zero_initialized_string_array() {
    return _rcutils_get_zero_initialized_string_array();
  }

  late final _rcutils_get_zero_initialized_string_array_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_zero_initialized_string_array>>(
          'rcutils_get_zero_initialized_string_array');
  late final _dart_rcutils_get_zero_initialized_string_array
      _rcutils_get_zero_initialized_string_array =
      _rcutils_get_zero_initialized_string_array_ptr
          .asFunction<_dart_rcutils_get_zero_initialized_string_array>();

  /// Initialize a string array with a given size.
  /// /**
  ///  * This function will initialize a given, zero initialized, string array to
  ///  * a given size.
  ///  *
  ///  * Note that putting a string into the array gives owenship to the array.
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * rcutils_allocator_t allocator = rcutils_get_default_allocator();
  ///  * rcutils_string_array_t string_array = rcutils_get_zero_initialized_string_array();
  ///  * rcutils_ret_t ret = rcutils_string_array_init(&string_array, 2, &allocator);
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... error handling
  ///  * }
  ///  * string_array.data[0] = rcutils_strdup("Hello", &allocator);
  ///  * string_array.data[1] = rcutils_strdup("World", &allocator);
  ///  * ret = rcutils_string_array_fini(&string_array);
  ///  *
  ///  * \param[inout] string_array object to be initialized
  ///  * \param[in] size the size the array should be
  ///  * \param[in] allocator to be used to allocate and deallocate memory
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  * ```
  ///  */
  int rcutils_string_array_init(
    ffi.Pointer<rcutils_string_array_t> string_array,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_string_array_init(
      string_array,
      size,
      allocator,
    );
  }

  late final _rcutils_string_array_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_array_init>>(
          'rcutils_string_array_init');
  late final _dart_rcutils_string_array_init _rcutils_string_array_init =
      _rcutils_string_array_init_ptr
          .asFunction<_dart_rcutils_string_array_init>();

  /// Finalize a string array, reclaiming all resources.
  /// /**
  ///  * This function reclaims any memory owned by the string array, including the
  ///  * strings it references.
  ///  *
  ///  * The allocator used to initialize the string array is used to deallocate each
  ///  * string in the array and the array of strings itself.
  ///  *
  ///  * \param[inout] string_array object to be finalized
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_array_fini(
    ffi.Pointer<rcutils_string_array_t> string_array,
  ) {
    return _rcutils_string_array_fini(
      string_array,
    );
  }

  late final _rcutils_string_array_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_array_fini>>(
          'rcutils_string_array_fini');
  late final _dart_rcutils_string_array_fini _rcutils_string_array_fini =
      _rcutils_string_array_fini_ptr
          .asFunction<_dart_rcutils_string_array_fini>();

  /// Compare two string arrays.
  /// /**
  ///  * The two string arrays are compared according to lexographical order.
  ///  *
  ///  * \param[in] sa0 The first string array.
  ///  * \param[in] sa1 The second string array.
  ///  * \param[out] res Negative value if `lhs` appears before `rhs` in lexographical order.
  ///  *   Zero if `lhs` and `rhs` are equal.
  ///  *   Positive value if `lhs` appears after `rhs in lexographical order.
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if any argument is `NULL`, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if `lhs->data` or `rhs->data` is `NULL`, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs.
  ///  */
  int rcutils_string_array_cmp(
    ffi.Pointer<rcutils_string_array_t> lhs,
    ffi.Pointer<rcutils_string_array_t> rhs,
    ffi.Pointer<ffi.Int32> res,
  ) {
    return _rcutils_string_array_cmp(
      lhs,
      rhs,
      res,
    );
  }

  late final _rcutils_string_array_cmp_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_array_cmp>>(
          'rcutils_string_array_cmp');
  late final _dart_rcutils_string_array_cmp _rcutils_string_array_cmp =
      _rcutils_string_array_cmp_ptr
          .asFunction<_dart_rcutils_string_array_cmp>();

  /// Return an empty string map struct.
  /// /*
  ///  * This function returns an empty and zero initialized string map struct.
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * // Do not do this:
  ///  * // rcutils_string_map_t foo;
  ///  * // rcutils_string_map_fini(&foo); // undefined behavior!
  ///  *
  ///  * // Do this instead:
  ///  * rcutils_string_map_t bar = rcutils_get_zero_initialized_string_map();
  ///  * rcutils_string_map_fini(&bar); // ok
  ///  * ```
  ///  * */
  rcutils_string_map_t rcutils_get_zero_initialized_string_map() {
    return _rcutils_get_zero_initialized_string_map();
  }

  late final _rcutils_get_zero_initialized_string_map_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_zero_initialized_string_map>>(
          'rcutils_get_zero_initialized_string_map');
  late final _dart_rcutils_get_zero_initialized_string_map
      _rcutils_get_zero_initialized_string_map =
      _rcutils_get_zero_initialized_string_map_ptr
          .asFunction<_dart_rcutils_get_zero_initialized_string_map>();

  /// Initialize a rcutils_string_map_t, allocating space for given capacity.
  /// /**
  ///  * This function initializes the rcutils_string_map_t with a given initial
  ///  * capacity for entries.
  ///  * Note this does not allocate space for keys or values in the map, just the
  ///  * arrays of pointers to the keys and values.
  ///  * rcutils_string_map_set() should still be used when assigning values.
  ///  *
  ///  * The string_map argument should point to allocated memory and should have
  ///  * been zero initialized with rcutils_get_zero_initialized_string_map().
  ///  * For example:
  ///  *
  ///  * ```c
  ///  * rcutils_string_map_t string_map = rcutils_get_zero_initialized_string_map();
  ///  * rcutils_ret_t ret =
  ///  *   rcutils_string_map_init(&string_map, 10, rcutils_get_default_allocator());
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... do error handling
  ///  * }
  ///  * // ... use the string map and when done:
  ///  * ret = rcutils_string_map_fini(&string_map);
  ///  * if (ret != RCUTILS_RET_OK) {
  ///  *   // ... do error handling
  ///  * }
  ///  * ```
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be initialized
  ///  * \param[in] initial_capacity the amount of initial capacity for the string map
  ///  * \param[in] allocator the allocator to use through out the lifetime of the map
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_STRING_MAP_ALREADY_INIT` if already initialized, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_init(
    ffi.Pointer<rcutils_string_map_t> string_map,
    int initial_capacity,
    rcutils_allocator_t allocator,
  ) {
    return _rcutils_string_map_init(
      string_map,
      initial_capacity,
      allocator,
    );
  }

  late final _rcutils_string_map_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_init>>(
          'rcutils_string_map_init');
  late final _dart_rcutils_string_map_init _rcutils_string_map_init =
      _rcutils_string_map_init_ptr.asFunction<_dart_rcutils_string_map_init>();

  /// Finalize the previously initialized string map struct.
  /// /**
  ///  * This function will free any resources which were created when initializing
  ///  * or when calling rcutils_string_map_set().
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be finalized
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_fini(
    ffi.Pointer<rcutils_string_map_t> string_map,
  ) {
    return _rcutils_string_map_fini(
      string_map,
    );
  }

  late final _rcutils_string_map_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_fini>>(
          'rcutils_string_map_fini');
  late final _dart_rcutils_string_map_fini _rcutils_string_map_fini =
      _rcutils_string_map_fini_ptr.asFunction<_dart_rcutils_string_map_fini>();

  /// Get the current capacity of the string map.
  /// /**
  ///  * This function will return the internal capacity of the map, which is the
  ///  * maximum number of key value pairs the map could hold.
  ///  * The capacity can be set initially with rcutils_string_map_init() or
  ///  * with rcutils_string_map_reserve().
  ///  * The capacity does not indicate how many key value paris are stored in the
  ///  * map, the rcutils_string_map_get_size() function can provide that.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be queried
  ///  * \param[out] capacity capacity of the string map
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_get_capacity(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Uint64> capacity,
  ) {
    return _rcutils_string_map_get_capacity(
      string_map,
      capacity,
    );
  }

  late final _rcutils_string_map_get_capacity_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_get_capacity>>(
          'rcutils_string_map_get_capacity');
  late final _dart_rcutils_string_map_get_capacity
      _rcutils_string_map_get_capacity = _rcutils_string_map_get_capacity_ptr
          .asFunction<_dart_rcutils_string_map_get_capacity>();

  /// Get the current size of the string map.
  /// /**
  ///  * This function will return the internal size of the map, which is the
  ///  * current number of key value pairs in the map.
  ///  * The size is changed when calling rcutils_string_map_set_no_resize(),
  ///  * rcutils_string_map_set(), or rcutils_string_map_unset().
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be queried
  ///  * \param[out] size size of the string map
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_get_size(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return _rcutils_string_map_get_size(
      string_map,
      size,
    );
  }

  late final _rcutils_string_map_get_size_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_get_size>>(
          'rcutils_string_map_get_size');
  late final _dart_rcutils_string_map_get_size _rcutils_string_map_get_size =
      _rcutils_string_map_get_size_ptr
          .asFunction<_dart_rcutils_string_map_get_size>();

  /// Reserve a given amount of capacity in the map.
  /// /**
  ///  * Increases the capacity of the map to at least the given size.
  ///  *
  ///  * If the current capacity is less than requested capacity then the capacity
  ///  * is increased using the allocator given during initialization of the map in
  ///  * rcutils_string_map_init().
  ///  * If the requested capacity is less than the current capacity, the capacity
  ///  * may be reduced, but no existing key value pairs will be truncated to do so.
  ///  * In effect, the capacity will be shrunk to fit the number of items in map or
  ///  * the requested capacity, which ever is larger.
  ///  *
  ///  * If recovering all resources is desired first call rcutils_string_map_clear()
  ///  * and then this function with a capacity of 0.
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to have space reserved in
  ///  * \param[in] capacity requested size to reserve in the map
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_reserve(
    ffi.Pointer<rcutils_string_map_t> string_map,
    int capacity,
  ) {
    return _rcutils_string_map_reserve(
      string_map,
      capacity,
    );
  }

  late final _rcutils_string_map_reserve_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_reserve>>(
          'rcutils_string_map_reserve');
  late final _dart_rcutils_string_map_reserve _rcutils_string_map_reserve =
      _rcutils_string_map_reserve_ptr
          .asFunction<_dart_rcutils_string_map_reserve>();

  /// Remove all key value pairs from the map.
  /// /**
  ///  * This function will remove all key value pairs from the map, and it will
  ///  * reclaim all resources allocated as a result of setting key value pairs.
  ///  * rcutils_string_map_fini() should still be called after this.
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be cleared
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_clear(
    ffi.Pointer<rcutils_string_map_t> string_map,
  ) {
    return _rcutils_string_map_clear(
      string_map,
    );
  }

  late final _rcutils_string_map_clear_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_clear>>(
          'rcutils_string_map_clear');
  late final _dart_rcutils_string_map_clear _rcutils_string_map_clear =
      _rcutils_string_map_clear_ptr
          .asFunction<_dart_rcutils_string_map_clear>();

  /// Set a key value pair in the map, increasing capacity if necessary.
  /// /**
  ///  * The capacity will be increased if needed using rcutils_string_map_reserve().
  ///  * Otherwise it is the same as rcutils_string_map_set_no_resize().
  ///  *
  ///  * \see rcutils_string_map_set_no_resize()
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be updated
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \param[in] value value for given map key, must be null terminated c string
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_set(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _rcutils_string_map_set(
      string_map,
      key,
      value,
    );
  }

  late final _rcutils_string_map_set_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_set>>(
          'rcutils_string_map_set');
  late final _dart_rcutils_string_map_set _rcutils_string_map_set =
      _rcutils_string_map_set_ptr.asFunction<_dart_rcutils_string_map_set>();

  /// Set a key value pair in the map but only if the map has enough capacity.
  /// /**
  ///  * If the map already contains the given key, the existing value will be
  ///  * replaced with the given value.
  ///  * If the map does not contain the given key, and the map has additional
  ///  * unused capacity, then it will store the given key and value in the map.
  ///  * If there is no unused capacity in the map, then RCUTILS_RET_NOT_ENOUGH_SPACE
  ///  * is returned.
  ///  *
  ///  * The given key and value c strings are copied into the map, and so storage is
  ///  * allocated for them in the map when this function is called if necessary.
  ///  * The storage allocated for this purpose is reclaimed either when
  ///  * rcutils_string_map_fini() is called on this map or when using this function
  ///  * or rcutils_string_map_unset().
  ///  *
  ///  * Any allocation that occurs in this functions uses the allocator of the map,
  ///  * which is given when the map is initialized in rcutils_string_map_init().
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be updated
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \param[in] value value for given map key, must be null terminated c string
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  ///  * \return `RCUTILS_RET_NOT_ENOUGH_SPACE` if map is full, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_set_no_resize(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _rcutils_string_map_set_no_resize(
      string_map,
      key,
      value,
    );
  }

  late final _rcutils_string_map_set_no_resize_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_set_no_resize>>(
          'rcutils_string_map_set_no_resize');
  late final _dart_rcutils_string_map_set_no_resize
      _rcutils_string_map_set_no_resize = _rcutils_string_map_set_no_resize_ptr
          .asFunction<_dart_rcutils_string_map_set_no_resize>();

  /// Unset a key value pair in the map.
  /// /**
  ///  * The key needs to be a null terminated c string.
  ///  * If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.
  ///  *
  ///  * \param[inout] string_map rcutils_string_map_t to be updated
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  ///  * \return `RCUTILS_RET_STRING_KEY_NOT_FOUND` if key not found, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_unset(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return _rcutils_string_map_unset(
      string_map,
      key,
    );
  }

  late final _rcutils_string_map_unset_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_unset>>(
          'rcutils_string_map_unset');
  late final _dart_rcutils_string_map_unset _rcutils_string_map_unset =
      _rcutils_string_map_unset_ptr
          .asFunction<_dart_rcutils_string_map_unset>();

  /// Get whether or not a key exists.
  /// /**
  ///  * The key needs to be a null terminated c string.
  ///  *
  ///  * This function can fail and return false if the key is not found,
  ///  * or the string_map is NULL or invalid, or if the key is NULL.
  ///  * In all cases no error message is set.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be searched
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \return `true` if key is in the map, or
  ///  * \return `false` if key is not in the map, or
  ///  * \return `false` for invalid arguments, or
  ///  * \return `false` if the string map is invalid
  ///  */
  bool rcutils_string_map_key_exists(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return _rcutils_string_map_key_exists(
          string_map,
          key,
        ) !=
        0;
  }

  late final _rcutils_string_map_key_exists_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_key_exists>>(
          'rcutils_string_map_key_exists');
  late final _dart_rcutils_string_map_key_exists
      _rcutils_string_map_key_exists = _rcutils_string_map_key_exists_ptr
          .asFunction<_dart_rcutils_string_map_key_exists>();

  /// Get whether or not a key of known length exists.
  /// /**
  ///  * Identical to rcutils_string_map_key_exists() but without relying on key to be
  ///  * a null terminated c string.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be searched
  ///  * \param[in] key map key
  ///  * \param[in] key_length map key length
  ///  * \return `true` if key is in the map, or
  ///  * \return `false` if key is not in the map, or
  ///  * \return `false` for invalid arguments, or
  ///  * \return `false` if the string map is invalid
  ///  */
  bool rcutils_string_map_key_existsn(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
    int key_length,
  ) {
    return _rcutils_string_map_key_existsn(
          string_map,
          key,
          key_length,
        ) !=
        0;
  }

  late final _rcutils_string_map_key_existsn_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_key_existsn>>(
          'rcutils_string_map_key_existsn');
  late final _dart_rcutils_string_map_key_existsn
      _rcutils_string_map_key_existsn = _rcutils_string_map_key_existsn_ptr
          .asFunction<_dart_rcutils_string_map_key_existsn>();

  /// Get value given a key.
  /// /**
  ///  * The key needs to be a null terminated c string.
  ///  *
  ///  * This function can fail, and therefore return NULL, if the key is not found,
  ///  * or the string_map is NULL or invalid, or if the key is NULL.
  ///  * In all cases no error message is set.
  ///  *
  ///  * The returned value string is still owned by the map, and it should not be
  ///  * modified or free'd.
  ///  * This also means that the value pointer becomes invalid if either
  ///  * rcutils_string_map_clear() or rcutils_string_map_fini() are called or if
  ///  * the key value pair is updated or removed with one of rcutils_string_map_set()
  ///  * or rcutils_string_map_set_no_resize() or rcutils_string_map_unset().
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be searched
  ///  * \param[in] key map key, must be null terminated c string
  ///  * \return value for the given key if successful, or
  ///  * \return `NULL` for invalid arguments, or
  ///  * \return `NULL` if the string map is invalid, or
  ///  * \return `NULL` if key not found, or
  ///  * \return `NULL` if an unknown error occurs
  ///  */
  ffi.Pointer<ffi.Int8> rcutils_string_map_get(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return _rcutils_string_map_get(
      string_map,
      key,
    );
  }

  late final _rcutils_string_map_get_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_get>>(
          'rcutils_string_map_get');
  late final _dart_rcutils_string_map_get _rcutils_string_map_get =
      _rcutils_string_map_get_ptr.asFunction<_dart_rcutils_string_map_get>();

  /// Get value given a key and key length.
  /// /**
  ///  * Identical to rcutils_string_map_get() but without relying on key to be a
  ///  * null terminated c string.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be searched
  ///  * \param[in] key map key
  ///  * \param[in] key_length map key length
  ///  * \return value for the given key if successful, or
  ///  * \return `NULL` for invalid arguments, or
  ///  * \return `NULL` if the string map is invalid, or
  ///  * \return `NULL` if key not found, or
  ///  * \return `NULL` if an unknown error occurs
  ///  */
  ffi.Pointer<ffi.Int8> rcutils_string_map_getn(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
    int key_length,
  ) {
    return _rcutils_string_map_getn(
      string_map,
      key,
      key_length,
    );
  }

  late final _rcutils_string_map_getn_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_getn>>(
          'rcutils_string_map_getn');
  late final _dart_rcutils_string_map_getn _rcutils_string_map_getn =
      _rcutils_string_map_getn_ptr.asFunction<_dart_rcutils_string_map_getn>();

  /// Get the next key in the map, unless NULL is given, then get the first key.
  /// /**
  ///  * This function allows you iteratively get each key in the map.
  ///  *
  ///  * If NULL is given for the key, then the first key in the map is returned.
  ///  * If that returned key if given to the this function, then the next key in the
  ///  * map is returned.
  ///  * If there are no more keys in the map or if the given key is not in the map,
  ///  * NULL is returned.
  ///  *
  ///  * The order of the keys in the map is arbitrary and if the map is modified
  ///  * between calls to this function the behavior is undefined.
  ///  * If the map is modifeid then iteration should begin again by passing NULL to
  ///  * get the first key again.
  ///  *
  ///  * This function operates based on the address of the pointer, you cannot pass
  ///  * a copy of a key to get the next key.
  ///  *
  ///  * Example:
  ///  *
  ///  * ```c
  ///  * printf("keys in the map:\n");
  ///  * const char * current_key = rcutils_string_map_get_next_key(&map, NULL);
  ///  * while (current_key) {
  ///  *   printf("  - %s\n", current_key);
  ///  *   current_key = rcutils_string_map_get_next_key(&map, current_key);
  ///  * }
  ///  * ```
  ///  *
  ///  * NULL can also be returned if NULL is given for the string_map or if the
  ///  * string_map is invalid.
  ///  *
  ///  * \param[in] string_map rcutils_string_map_t to be queried
  ///  * \param[in] key NULL to get the first key or the previous key to get the next
  ///  * \return value for the given key if successful, or
  ///  * \return `NULL` for invalid arguments, or
  ///  * \return `NULL` if the string map is invalid, or
  ///  * \return `NULL` if key not found, or
  ///  * \return `NULL` if there are no more keys in the map, or
  ///  * \return `NULL` if an unknown error occurs
  ///  */
  ffi.Pointer<ffi.Int8> rcutils_string_map_get_next_key(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return _rcutils_string_map_get_next_key(
      string_map,
      key,
    );
  }

  late final _rcutils_string_map_get_next_key_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_get_next_key>>(
          'rcutils_string_map_get_next_key');
  late final _dart_rcutils_string_map_get_next_key
      _rcutils_string_map_get_next_key = _rcutils_string_map_get_next_key_ptr
          .asFunction<_dart_rcutils_string_map_get_next_key>();

  /// Copy all the key value pairs from one map into another, overwritting and resizing if needed.
  /// /**
  ///  * If the destination string map does not have enough storage, then it is will
  ///  * be resized.
  ///  * If a key value pair exists in the destination map, its value will be
  ///  * replaced with the source map's value.
  ///  *
  ///  * It is possible for only some of the values to be copied if an error happens
  ///  * during the copying process, e.g. if memory allocation fails.
  ///  *
  ///  * \param[in] src_string_map rcutils_string_map_t to be copied from
  ///  * \param[inout] dst_string_map rcutils_string_map_t to be copied to
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unknown error occurs
  ///  */
  int rcutils_string_map_copy(
    ffi.Pointer<rcutils_string_map_t> src_string_map,
    ffi.Pointer<rcutils_string_map_t> dst_string_map,
  ) {
    return _rcutils_string_map_copy(
      src_string_map,
      dst_string_map,
    );
  }

  late final _rcutils_string_map_copy_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_string_map_copy>>(
          'rcutils_string_map_copy');
  late final _dart_rcutils_string_map_copy _rcutils_string_map_copy =
      _rcutils_string_map_copy_ptr.asFunction<_dart_rcutils_string_map_copy>();

  /// Return a zero initialized uint8 array struct.
  /// /**
  ///  * \return rcutils_uint8_array_t a zero initialized uint8 array struct
  ///  */
  rcutils_uint8_array_t rcutils_get_zero_initialized_uint8_array() {
    return _rcutils_get_zero_initialized_uint8_array();
  }

  late final _rcutils_get_zero_initialized_uint8_array_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_get_zero_initialized_uint8_array>>(
          'rcutils_get_zero_initialized_uint8_array');
  late final _dart_rcutils_get_zero_initialized_uint8_array
      _rcutils_get_zero_initialized_uint8_array =
      _rcutils_get_zero_initialized_uint8_array_ptr
          .asFunction<_dart_rcutils_get_zero_initialized_uint8_array>();

  /// Initialize a zero initialized uint8 array struct.
  /// /**
  ///  * This function may leak if the uint8 array struct is already initialized.
  ///  * If the capacity is set to 0, no memory is allocated and the internal buffer
  ///  * is still NULL.
  ///  *
  ///  * \param uint8_array a pointer to the to be initialized uint8 array struct
  ///  * \param buffer_capacity the size of the memory to allocate for the byte stream
  ///  * \param allocator the allocator to use for the memory allocation
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENTS` if any arguments are invalid, or
  ///  * \return 'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_uint8_array_init(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
    int buffer_capacity,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcutils_uint8_array_init(
      uint8_array,
      buffer_capacity,
      allocator,
    );
  }

  late final _rcutils_uint8_array_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_uint8_array_init>>(
          'rcutils_uint8_array_init');
  late final _dart_rcutils_uint8_array_init _rcutils_uint8_array_init =
      _rcutils_uint8_array_init_ptr
          .asFunction<_dart_rcutils_uint8_array_init>();

  /// Finalize a uint8 array struct.
  /// /**
  ///  * Cleans up and deallocates any resources used in a rcutils_uint8_array_t.
  ///  * The array passed to this function needs to have been initialized by
  ///  * rcutils_uint8_array_init().
  ///  * Passing an uninitialized instance to this function leads to undefined
  ///  * behavior.
  ///  *
  ///  * \param uint8_array pointer to the rcutils_uint8_array_t to be cleaned up
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENTS` if the uint8_array argument is invalid
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_uint8_array_fini(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  ) {
    return _rcutils_uint8_array_fini(
      uint8_array,
    );
  }

  late final _rcutils_uint8_array_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_uint8_array_fini>>(
          'rcutils_uint8_array_fini');
  late final _dart_rcutils_uint8_array_fini _rcutils_uint8_array_fini =
      _rcutils_uint8_array_fini_ptr
          .asFunction<_dart_rcutils_uint8_array_fini>();

  /// Resize the internal buffer of the uint8 array.
  /// /**
  ///  * The internal buffer of the uint8 array can be resized dynamically if needed.
  ///  * If the new size is smaller than the current capacity, then the memory is
  ///  * truncated.
  ///  * Be aware, that this might deallocate the memory and therefore invalidates any
  ///  * pointers to this storage.
  ///  *
  ///  * \param uint8_array pointer to the instance of rcutils_uint8_array_t which is being resized
  ///  * \param new_size the new size of the internal buffer
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if new_size is set to zero
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  ///  */
  int rcutils_uint8_array_resize(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
    int new_size,
  ) {
    return _rcutils_uint8_array_resize(
      uint8_array,
      new_size,
    );
  }

  late final _rcutils_uint8_array_resize_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_uint8_array_resize>>(
          'rcutils_uint8_array_resize');
  late final _dart_rcutils_uint8_array_resize _rcutils_uint8_array_resize =
      _rcutils_uint8_array_resize_ptr
          .asFunction<_dart_rcutils_uint8_array_resize>();

  /// This function returns the time from a system clock.
  /// The closest equivalent would be to std::chrono::system_clock::now();
  ///
  /// The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.
  ///
  /// The now argument must point to an allocated rcutils_time_point_value_t object,
  /// as the result is copied into this variable.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[out] now a datafield in which the current time is stored
  /// \return `RCUTILS_RET_OK` if the current time was successfully obtained, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unspecified error occur.
  int rcutils_system_time_now(
    ffi.Pointer<ffi.Int64> now,
  ) {
    return _rcutils_system_time_now(
      now,
    );
  }

  late final _rcutils_system_time_now_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_system_time_now>>(
          'rcutils_system_time_now');
  late final _dart_rcutils_system_time_now _rcutils_system_time_now =
      _rcutils_system_time_now_ptr.asFunction<_dart_rcutils_system_time_now>();

  /// Retrieve the current time as a rcutils_time_point_value_t object.
  /// /**
  ///  * This function returns the time from a monotonically increasing clock.
  ///  * The closest equivalent would be to std::chrono::steady_clock::now();
  ///  *
  ///  * The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.
  ///  *
  ///  * The now argument must point to an allocated rcutils_time_point_value_t object,
  ///  * as the result is copied into this variable.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[out] now a struct in which the current time is stored
  ///  * \return `RCUTILS_RET_OK` if the current time was successfully obtained, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unspecified error occur.
  ///  */
  int rcutils_steady_time_now(
    ffi.Pointer<ffi.Int64> now,
  ) {
    return _rcutils_steady_time_now(
      now,
    );
  }

  late final _rcutils_steady_time_now_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_steady_time_now>>(
          'rcutils_steady_time_now');
  late final _dart_rcutils_steady_time_now _rcutils_steady_time_now =
      _rcutils_steady_time_now_ptr.asFunction<_dart_rcutils_steady_time_now>();

  /// Return a time point as nanoseconds in a string.
  /// /**
  ///  * The number is always fixed width, with left padding zeros up to the maximum
  ///  * number of digits the time point can represent.
  ///  * Right now that is 19 digits (so 19 characters) for a signed 64-bit integer.
  ///  * Negative values will have a leading `-`, so they will be one character
  ///  * longer than the positive values.
  ///  *
  ///  * The recommended minimum size of the input string is 32 characters, but
  ///  * 21 (` ` or `-` for sign, 19 digits, null terminator) should be sufficiently
  ///  * large for both positive and negative values.
  ///  * If the given string is not large enough, the result will be truncated.
  ///  * If you need a string with variable width, using `snprintf()` directly is
  ///  * recommended.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No [1]
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] if `snprintf()` does not allocate additional memory internally</i>
  ///  *
  ///  * \param[in] time_point the time to be made into a string
  ///  * \param[out] str the output string in which it is stored
  ///  * \param[in] str_size the size of the output string
  ///  * \return `RCUTILS_RET_OK` if successful (even if truncated), or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unspecified error occur.
  ///  */
  int rcutils_time_point_value_as_nanoseconds_string(
    ffi.Pointer<ffi.Int64> time_point,
    ffi.Pointer<ffi.Int8> str,
    int str_size,
  ) {
    return _rcutils_time_point_value_as_nanoseconds_string(
      time_point,
      str,
      str_size,
    );
  }

  late final _rcutils_time_point_value_as_nanoseconds_string_ptr = _lookup<
          ffi.NativeFunction<
              _c_rcutils_time_point_value_as_nanoseconds_string>>(
      'rcutils_time_point_value_as_nanoseconds_string');
  late final _dart_rcutils_time_point_value_as_nanoseconds_string
      _rcutils_time_point_value_as_nanoseconds_string =
      _rcutils_time_point_value_as_nanoseconds_string_ptr
          .asFunction<_dart_rcutils_time_point_value_as_nanoseconds_string>();

  /// Return a time point as floating point seconds in a string.
  /// /**
  ///  * The number is always fixed width, with left padding zeros up to the maximum
  ///  * number of digits for the mantissa that the time point can represent and a
  ///  * characteristic (fractional-part) with a fixed width of 9 digits.
  ///  * Right now that means the mantissa is always 10 digits to add up to 19 total
  ///  * for the signed 64-bit time point type.
  ///  * Negative values will have a leading `-`, so they will be one character
  ///  * longer then positive values.
  ///  *
  ///  * The recommended minimum size of the input string is 32 characters, but
  ///  * 22 (` ` or `-` for sign, 19 digits, decimal point, null terminator) should
  ///  * be sufficient for now.
  ///  * If the given string is not large enough, the result will be truncated.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No [1]
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] if `snprintf()` does not allocate additional memory internally</i>
  ///  *
  ///  * \param[in] time_point the time to be made into a string
  ///  * \param[out] str the output string in which it is stored
  ///  * \param[in] str_size the size of the output string
  ///  * \return `RCUTILS_RET_OK` if successful (even if truncated), or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unspecified error occur.
  ///  */
  int rcutils_time_point_value_as_seconds_string(
    ffi.Pointer<ffi.Int64> time_point,
    ffi.Pointer<ffi.Int8> str,
    int str_size,
  ) {
    return _rcutils_time_point_value_as_seconds_string(
      time_point,
      str,
      str_size,
    );
  }

  late final _rcutils_time_point_value_as_seconds_string_ptr = _lookup<
          ffi.NativeFunction<_c_rcutils_time_point_value_as_seconds_string>>(
      'rcutils_time_point_value_as_seconds_string');
  late final _dart_rcutils_time_point_value_as_seconds_string
      _rcutils_time_point_value_as_seconds_string =
      _rcutils_time_point_value_as_seconds_string_ptr
          .asFunction<_dart_rcutils_time_point_value_as_seconds_string>();

  /// The flag if the logging system has been initialized.
  late final ffi.Pointer<ffi.Uint8> _g_rcutils_logging_initialized =
      _lookup<ffi.Uint8>('g_rcutils_logging_initialized');

  int get g_rcutils_logging_initialized => _g_rcutils_logging_initialized.value;

  set g_rcutils_logging_initialized(int value) =>
      _g_rcutils_logging_initialized.value = value;

  /// Initialize the logging system using the specified allocator.
  /// /**
  ///  * Initialize the logging system only if it was not in an initialized state.
  ///  *
  ///  * If an invalid allocator is passed, the initialization will fail.
  ///  * Otherwise, this function will still set the internal state to initialized
  ///  * even if an error occurs, to avoid repeated failing initialization attempts
  ///  * since this function is called automatically from logging macros.
  ///  * To re-attempt initialization, call rcutils_logging_shutdown() before
  ///  * re-calling this function.
  ///  *
  ///  * If multiple errors occur, the error code of the last error will be returned.
  ///  *
  ///  * The `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable can be used to set
  ///  * the output format of messages logged to the console.
  ///  * Available tokens are:
  ///  *   - `file_name`, the full file name of the caller including the path
  ///  *   - `function_name`, the function name of the caller
  ///  *   - `line_number`, the line number of the caller
  ///  *   - `message`, the message string after it has been formatted
  ///  *   - `name`, the full logger name
  ///  *   - `severity`, the name of the severity level, e.g. `INFO`
  ///  *   - `time`, the timestamp of log message in floating point seconds
  ///  *   - `time_as_nanoseconds`, the timestamp of log message in integer nanoseconds
  ///  *
  ///  * The `RCUTILS_COLORIZED_OUTPUT` environment variable allows configuring if colours
  ///  * are used or not. Available values are:
  ///  *  - `1`: Force using colours.
  ///  *  - `0`: Don't use colours.
  ///  * If it is unset, colours are used depending if the target stream is a terminal or not.
  ///  * See `isatty` documentation.
  ///  *
  ///  * The format string can use these tokens by referencing them in curly brackets,
  ///  * e.g. `"[{severity}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})"`.
  ///  * Any number of tokens can be used.
  ///  * The limit of the format string is 2048 characters.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param allocator rcutils_allocator_t to be used.
  ///  * \return `RCUTILS_RET_OK` if successful.
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if the allocator is invalid, in which
  ///  *   case initialization will fail.
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if an error occurs reading the output
  ///  *   format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in
  ///  *   which case the default format will be used.
  ///  * \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if the internal logger
  ///  *   severity level map cannot be initialized, in which case logger severity
  ///  *   levels will not be configurable.
  ///  */
  int rcutils_logging_initialize_with_allocator(
    rcutils_allocator_t allocator,
  ) {
    return _rcutils_logging_initialize_with_allocator(
      allocator,
    );
  }

  late final _rcutils_logging_initialize_with_allocator_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_initialize_with_allocator>>(
          'rcutils_logging_initialize_with_allocator');
  late final _dart_rcutils_logging_initialize_with_allocator
      _rcutils_logging_initialize_with_allocator =
      _rcutils_logging_initialize_with_allocator_ptr
          .asFunction<_dart_rcutils_logging_initialize_with_allocator>();

  /// Initialize the logging system.
  /// /**
  ///  * Call rcutils_logging_initialize_with_allocator() using the default allocator.
  ///  * This function is called automatically when using the logging macros.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return `RCUTILS_RET_OK` if successful.
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` if an error occurs reading the output
  ///  *   format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in
  ///  *   which case the default format will be used.
  ///  * \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if the internal logger
  ///  *   severity level map cannot be initialized, in which case logger levels
  ///  *   will not be configurable.
  ///  */
  int rcutils_logging_initialize() {
    return _rcutils_logging_initialize();
  }

  late final _rcutils_logging_initialize_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_initialize>>(
          'rcutils_logging_initialize');
  late final _dart_rcutils_logging_initialize _rcutils_logging_initialize =
      _rcutils_logging_initialize_ptr
          .asFunction<_dart_rcutils_logging_initialize>();

  /// Shutdown the logging system.
  /// /**
  ///  * Free the resources allocated for the logging system.
  ///  * This puts the system into a state equivalent to being uninitialized.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return `RCUTILS_RET_OK` if successful.
  ///  * \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if the internal logger
  ///  *   severity level map cannot be finalized.
  ///  */
  int rcutils_logging_shutdown() {
    return _rcutils_logging_shutdown();
  }

  late final _rcutils_logging_shutdown_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_shutdown>>(
          'rcutils_logging_shutdown');
  late final _dart_rcutils_logging_shutdown _rcutils_logging_shutdown =
      _rcutils_logging_shutdown_ptr
          .asFunction<_dart_rcutils_logging_shutdown>();

  /// The names of severity levels.
  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>>
      _g_rcutils_log_severity_names =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Int8>>>(
          'g_rcutils_log_severity_names');

  ffi.Pointer<ffi.Pointer<ffi.Int8>> get g_rcutils_log_severity_names =>
      _g_rcutils_log_severity_names.value;

  set g_rcutils_log_severity_names(ffi.Pointer<ffi.Pointer<ffi.Int8>> value) =>
      _g_rcutils_log_severity_names.value = value;

  /// Get a severity value from its string representation (e.g. DEBUG).
  /// /**
  ///  * String representation must match one of the values in
  ///  * `g_rcutils_log_severity_names`, but is not case-sensitive.
  ///  * Examples: UNSET, DEBUG, INFO, WARN, Error, fatal.
  ///  *
  ///  * \param[in] severity_string String representation of the severity, must be a
  ///  *   null terminated c string
  ///  * \param[in] allocator rcutils_allocator_t to be used
  ///  * \param[in,out] severity The severity level as a represented by the
  ///  *   `RCUTILS_LOG_SEVERITY` enum
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` on invalid arguments, or
  ///  * \return `RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID` if unable to match
  ///  *   string, or
  ///  * \return `RCUTILS_RET_ERROR` if an unspecified error occured
  ///  */
  int rcutils_logging_severity_level_from_string(
    ffi.Pointer<ffi.Int8> severity_string,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Int32> severity,
  ) {
    return _rcutils_logging_severity_level_from_string(
      severity_string,
      allocator,
      severity,
    );
  }

  late final _rcutils_logging_severity_level_from_string_ptr = _lookup<
          ffi.NativeFunction<_c_rcutils_logging_severity_level_from_string>>(
      'rcutils_logging_severity_level_from_string');
  late final _dart_rcutils_logging_severity_level_from_string
      _rcutils_logging_severity_level_from_string =
      _rcutils_logging_severity_level_from_string_ptr
          .asFunction<_dart_rcutils_logging_severity_level_from_string>();

  /// The function pointer of the current output handler.
  late final ffi.Pointer<
          ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>>
      _g_rcutils_logging_output_handler = _lookup<
              ffi.Pointer<
                  ffi.NativeFunction<rcutils_logging_output_handler_t>>>(
          'g_rcutils_logging_output_handler');

  ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>
      get g_rcutils_logging_output_handler =>
          _g_rcutils_logging_output_handler.value;

  set g_rcutils_logging_output_handler(
          ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>
              value) =>
      _g_rcutils_logging_output_handler.value = value;

  /// Get the current output handler.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return The function pointer of the current output handler.
  ///  */
  ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>
      rcutils_logging_get_output_handler() {
    return _rcutils_logging_get_output_handler();
  }

  late final _rcutils_logging_get_output_handler_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_get_output_handler>>(
          'rcutils_logging_get_output_handler');
  late final _dart_rcutils_logging_get_output_handler
      _rcutils_logging_get_output_handler =
      _rcutils_logging_get_output_handler_ptr
          .asFunction<_dart_rcutils_logging_get_output_handler>();

  /// Set the current output handler.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param function The function pointer of the output handler to be used.
  ///  */
  void rcutils_logging_set_output_handler(
    ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>> function,
  ) {
    return _rcutils_logging_set_output_handler(
      function,
    );
  }

  late final _rcutils_logging_set_output_handler_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_set_output_handler>>(
          'rcutils_logging_set_output_handler');
  late final _dart_rcutils_logging_set_output_handler
      _rcutils_logging_set_output_handler =
      _rcutils_logging_set_output_handler_ptr
          .asFunction<_dart_rcutils_logging_set_output_handler>();

  /// Formats a log message according to RCUTILS_CONSOLE_OUTPUT_FORMAT
  /// /**
  ///  * A formatter that is meant to be used by an output handler to format a log message to the match
  ///  * the format specified in RCUTILS_CONSOLE_OUTPUT_FORMAT by performing token replacement.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return `RCUTILS_RET_OK` if successful.
  ///  * \return `RCUTILS_RET_BAD_ALLOC` if memory allocation error occured
  ///  * \param location The location information about where the log came from
  ///  * \param severity The severity of the log message expressed as an integer
  ///  * \param name The name of the logger that this message came from
  ///  * \param timestamp The time at which the log message was generated
  ///  * \param msg The message being logged
  ///  * \param args The list of arguments to insert into the formatted log messgae
  ///  * \param[out] logging_output An output buffer for the formatted message
  ///  */
  int rcutils_logging_format_message(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Int8> name,
    int timestamp,
    ffi.Pointer<ffi.Int8> msg,
    ffi.Pointer<rcutils_char_array_t> logging_output,
  ) {
    return _rcutils_logging_format_message(
      location,
      severity,
      name,
      timestamp,
      msg,
      logging_output,
    );
  }

  late final _rcutils_logging_format_message_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_format_message>>(
          'rcutils_logging_format_message');
  late final _dart_rcutils_logging_format_message
      _rcutils_logging_format_message = _rcutils_logging_format_message_ptr
          .asFunction<_dart_rcutils_logging_format_message>();

  /// The default severity level for loggers.
  /// /**
  ///  * This level is used for (1) nameless log calls and (2) named log
  ///  * calls where the effective level of the logger name is unspecified.
  ///  *
  ///  * \see rcutils_logging_get_logger_effective_level()
  ///  */
  late final ffi.Pointer<ffi.Int32> _g_rcutils_logging_default_logger_level =
      _lookup<ffi.Int32>('g_rcutils_logging_default_logger_level');

  int get g_rcutils_logging_default_logger_level =>
      _g_rcutils_logging_default_logger_level.value;

  set g_rcutils_logging_default_logger_level(int value) =>
      _g_rcutils_logging_default_logger_level.value = value;

  /// Get the default level for loggers.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \return The level.
  ///  */
  int rcutils_logging_get_default_logger_level() {
    return _rcutils_logging_get_default_logger_level();
  }

  late final _rcutils_logging_get_default_logger_level_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_get_default_logger_level>>(
          'rcutils_logging_get_default_logger_level');
  late final _dart_rcutils_logging_get_default_logger_level
      _rcutils_logging_get_default_logger_level =
      _rcutils_logging_get_default_logger_level_ptr
          .asFunction<_dart_rcutils_logging_get_default_logger_level>();

  /// Set the default severity level for loggers.
  /// /**
  ///  * If the severity level requested is `RCUTILS_LOG_SEVERITY_UNSET`, the default
  ///  * value for the default logger (`RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL`)
  ///  * will be restored instead.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param level The level to be used.
  ///  */
  void rcutils_logging_set_default_logger_level(
    int level,
  ) {
    return _rcutils_logging_set_default_logger_level(
      level,
    );
  }

  late final _rcutils_logging_set_default_logger_level_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_set_default_logger_level>>(
          'rcutils_logging_set_default_logger_level');
  late final _dart_rcutils_logging_set_default_logger_level
      _rcutils_logging_set_default_logger_level =
      _rcutils_logging_set_default_logger_level_ptr
          .asFunction<_dart_rcutils_logging_set_default_logger_level>();

  /// Get the severity level for a logger.
  /// /**
  ///  * This considers the severity level of the specifed logger only.
  ///  * To get the effective level of a logger given the severity level of its
  ///  * ancestors, see rcutils_logging_get_logger_effective_level().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param name The name of the logger, must be null terminated c string
  ///  * \return The level of the logger if it has been set, or
  ///  * \return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or
  ///  * \return `g_rcutils_logging_default_logger_level` for an empty name, or
  ///  * \return -1 on invalid arguments, or
  ///  * \return -1 if an error occurred
  ///  */
  int rcutils_logging_get_logger_level(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _rcutils_logging_get_logger_level(
      name,
    );
  }

  late final _rcutils_logging_get_logger_level_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_get_logger_level>>(
          'rcutils_logging_get_logger_level');
  late final _dart_rcutils_logging_get_logger_level
      _rcutils_logging_get_logger_level = _rcutils_logging_get_logger_level_ptr
          .asFunction<_dart_rcutils_logging_get_logger_level>();

  /// Get the level for a logger and its name length.
  /// /**
  ///  * Identical to rcutils_logging_get_logger_level() but without
  ///  * relying on the logger name to be a null terminated c string.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param name The name of the logger
  ///  * \param name_length Logger name length
  ///  * \return The level of the logger if it has been set, or
  ///  * \return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or
  ///  * \return `g_rcutils_logging_default_logger_level` for `name_length` of `0`, or
  ///  * \return -1 on invalid arguments, or
  ///  * \return -1 if an error occurred
  ///  */
  int rcutils_logging_get_logger_leveln(
    ffi.Pointer<ffi.Int8> name,
    int name_length,
  ) {
    return _rcutils_logging_get_logger_leveln(
      name,
      name_length,
    );
  }

  late final _rcutils_logging_get_logger_leveln_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_get_logger_leveln>>(
          'rcutils_logging_get_logger_leveln');
  late final _dart_rcutils_logging_get_logger_leveln
      _rcutils_logging_get_logger_leveln =
      _rcutils_logging_get_logger_leveln_ptr
          .asFunction<_dart_rcutils_logging_get_logger_leveln>();

  /// Set the severity level for a logger.
  /// /**
  ///  * If an empty string is specified as the name, the
  ///  * `g_rcutils_logging_default_logger_level` will be set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param name The name of the logger, must be null terminated c string.
  ///  * \param level The level to be used.
  ///  * \return `RCUTILS_RET_OK` if successful, or
  ///  * \return `RCUTILS_RET_INVALID_ARGUMENT` on invalid arguments, or
  ///  * \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if severity map invalid, or
  ///  * \return `RCUTILS_RET_ERROR` if an unspecified error occured
  ///  */
  int rcutils_logging_set_logger_level(
    ffi.Pointer<ffi.Int8> name,
    int level,
  ) {
    return _rcutils_logging_set_logger_level(
      name,
      level,
    );
  }

  late final _rcutils_logging_set_logger_level_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_set_logger_level>>(
          'rcutils_logging_set_logger_level');
  late final _dart_rcutils_logging_set_logger_level
      _rcutils_logging_set_logger_level = _rcutils_logging_set_logger_level_ptr
          .asFunction<_dart_rcutils_logging_set_logger_level>();

  /// Determine if a logger is enabled for a severity level.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param name The name of the logger, must be null terminated c string or NULL.
  ///  * \param severity The severity level.
  ///  *
  ///  * \return true if the logger is enabled for the level; false otherwise.
  ///  */
  bool rcutils_logging_logger_is_enabled_for(
    ffi.Pointer<ffi.Int8> name,
    int severity,
  ) {
    return _rcutils_logging_logger_is_enabled_for(
          name,
          severity,
        ) !=
        0;
  }

  late final _rcutils_logging_logger_is_enabled_for_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_logger_is_enabled_for>>(
          'rcutils_logging_logger_is_enabled_for');
  late final _dart_rcutils_logging_logger_is_enabled_for
      _rcutils_logging_logger_is_enabled_for =
      _rcutils_logging_logger_is_enabled_for_ptr
          .asFunction<_dart_rcutils_logging_logger_is_enabled_for>();

  /// Determine the effective level for a logger.
  /// /**
  ///  * The effective level is determined as the severity level of
  ///  * the logger if it is set, otherwise it is the first specified severity
  ///  * level of the logger's ancestors, starting with its closest ancestor.
  ///  * The ancestor hierarchy is signified by logger names being separated by dots:
  ///  * a logger named `x` is an ancestor of `x.y`, and both `x` and `x.y` are
  ///  * ancestors of `x.y.z`, etc.
  ///  * If the level has not been set for the logger nor any of its
  ///  * ancestors, the default level is used.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, provided logging system is already initialized
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param name The name of the logger, must be null terminated c string.
  ///  *
  ///  * \return The level, or
  ///  * \return -1 on invalid arguments, or
  ///  * \return -1 if an error occurred.
  ///  */
  int rcutils_logging_get_logger_effective_level(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _rcutils_logging_get_logger_effective_level(
      name,
    );
  }

  late final _rcutils_logging_get_logger_effective_level_ptr = _lookup<
          ffi.NativeFunction<_c_rcutils_logging_get_logger_effective_level>>(
      'rcutils_logging_get_logger_effective_level');
  late final _dart_rcutils_logging_get_logger_effective_level
      _rcutils_logging_get_logger_effective_level =
      _rcutils_logging_get_logger_effective_level_ptr
          .asFunction<_dart_rcutils_logging_get_logger_effective_level>();

  /// Log a message.
  /// /**
  ///  * The attributes of this function are also being influenced by the currently
  ///  * set output handler.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No, for formatted outputs <= 1023 characters
  ///  *                    | Yes, for formatted outputs >= 1024 characters
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param location The pointer to the location struct or NULL
  ///  * \param severity The severity level
  ///  * \param name The name of the logger, must be null terminated c string or NULL
  ///  * \param format The format string
  ///  * \param ... The variable arguments
  ///  */
  void rcutils_log(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> format,
  ) {
    return _rcutils_log(
      location,
      severity,
      name,
      format,
    );
  }

  late final _rcutils_log_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_log>>('rcutils_log');
  late final _dart_rcutils_log _rcutils_log =
      _rcutils_log_ptr.asFunction<_dart_rcutils_log>();

  /// The default output handler outputs log messages to the standard streams.
  /// /**
  ///  * The messages with a severity level `DEBUG` and `INFO` are written to `stdout`.
  ///  * The messages with a severity level `WARN`, `ERROR`, and `FATAL` are written
  ///  * to `stderr`.
  ///  * The console output format of the logged message can be configured through
  ///  * the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable: see
  ///  * rcutils_logging_initialize_with_allocator() for details.
  ///  * For configuring if using colours or not, `RCUTILS_COLORIZED_OUTPUT` can be used:
  ///  * see rcutils_logging_initialize_with_allocator() for details.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes, if the underlying *printf functions are
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param location The pointer to the location struct or NULL
  ///  * \param severity The severity level
  ///  * \param name The name of the logger, must be null terminated c string
  ///  * \param timestamp The timestamp for when the log message was made
  ///  * \param log_str The string to be logged
  ///  */
  void rcutils_logging_console_output_handler(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Int8> name,
    int timestamp,
    ffi.Pointer<ffi.Int8> format,
    ffi.Pointer<ffi.Pointer<__va_list_tag>> args,
  ) {
    return _rcutils_logging_console_output_handler(
      location,
      severity,
      name,
      timestamp,
      format,
      args,
    );
  }

  late final _rcutils_logging_console_output_handler_ptr =
      _lookup<ffi.NativeFunction<_c_rcutils_logging_console_output_handler>>(
          'rcutils_logging_console_output_handler');
  late final _dart_rcutils_logging_console_output_handler
      _rcutils_logging_console_output_handler =
      _rcutils_logging_console_output_handler_ptr
          .asFunction<_dart_rcutils_logging_console_output_handler>();

  /// Return a zero initialized init options structure.
  rmw_init_options_t rmw_get_zero_initialized_init_options() {
    return _rmw_get_zero_initialized_init_options();
  }

  late final _rmw_get_zero_initialized_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_zero_initialized_init_options>>(
          'rmw_get_zero_initialized_init_options');
  late final _dart_rmw_get_zero_initialized_init_options
      _rmw_get_zero_initialized_init_options =
      _rmw_get_zero_initialized_init_options_ptr
          .asFunction<_dart_rmw_get_zero_initialized_init_options>();

  /// Initialize given init_options with the default values and implementation specific values.
  /// /**
  ///  * The given allocator is used, if required, during setup of the init options,
  ///  * but is also used during initialization.
  ///  *
  ///  * In either case the given allocator is stored in the returned init options.
  ///  *
  ///  * The `impl` pointer should not be changed manually.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[inout] init_options object to be setup
  ///  * \param[in] allocator to be used during setup and during initialization
  ///  * \return `RMW_RET_OK` if setup is successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if init_options has already be initialized, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_init_options_init(
    ffi.Pointer<rmw_init_options_t> init_options,
    rcutils_allocator_t allocator,
  ) {
    return _rmw_init_options_init(
      init_options,
      allocator,
    );
  }

  late final _rmw_init_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_init_options_init>>(
          'rmw_init_options_init');
  late final _dart_rmw_init_options_init _rmw_init_options_init =
      _rmw_init_options_init_ptr.asFunction<_dart_rmw_init_options_init>();

  /// Copy the given source init options to the destination init options.
  /// /**
  ///  * The allocator from the source is used for any allocations and stored in the
  ///  * destination.
  ///  *
  ///  * The destination should either be zero initialized with
  ///  * `rmw_get_zero_initialized_init_options()` or should have had
  ///  * `rmw_init_options_fini()` called on it.
  ///  * Giving an already initialized init options for the destination will result
  ///  * in a failure with return code `RMW_RET_INVALID_ARGUMENT`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] src rcl_init_options_t object to be copied from
  ///  * \param[out] dst rcl_init_options_t object to be copied into
  ///  * \return `RMW_RET_OK` if the copy is successful, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier for src does not match the implementation of this function, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if the dst has already be initialized, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_init_options_copy(
    ffi.Pointer<rmw_init_options_t> src,
    ffi.Pointer<rmw_init_options_t> dst,
  ) {
    return _rmw_init_options_copy(
      src,
      dst,
    );
  }

  late final _rmw_init_options_copy_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_init_options_copy>>(
          'rmw_init_options_copy');
  late final _dart_rmw_init_options_copy _rmw_init_options_copy =
      _rmw_init_options_copy_ptr.asFunction<_dart_rmw_init_options_copy>();

  /// Finalize the given init_options.
  /// /**
  ///  * The given init_options must be non-`NULL` and valid, i.e. had
  ///  * `rmw_init_options_init()` called on it but not this function yet.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[inout] init_options object to be setup
  ///  * \return `RMW_RET_OK` if setup is successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_init_options_fini(
    ffi.Pointer<rmw_init_options_t> init_options,
  ) {
    return _rmw_init_options_fini(
      init_options,
    );
  }

  late final _rmw_init_options_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_init_options_fini>>(
          'rmw_init_options_fini');
  late final _dart_rmw_init_options_fini _rmw_init_options_fini =
      _rmw_init_options_fini_ptr.asFunction<_dart_rmw_init_options_fini>();

  /// Return a zero initialized context structure.
  rmw_context_t rmw_get_zero_initialized_context() {
    return _rmw_get_zero_initialized_context();
  }

  late final _rmw_get_zero_initialized_context_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_zero_initialized_context>>(
          'rmw_get_zero_initialized_context');
  late final _dart_rmw_get_zero_initialized_context
      _rmw_get_zero_initialized_context = _rmw_get_zero_initialized_context_ptr
          .asFunction<_dart_rmw_get_zero_initialized_context>();

  /// Initialize the middleware with the given options, and yielding an context.
  /// /**
  ///  * The given context must be zero initialized, and is filled with
  ///  * middleware specific data upon success of this function.
  ///  * The context is used when initializing some entities like nodes and
  ///  * guard conditions, and is also required to properly call rmw_shutdown().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] options initialization options to be used during initialization
  ///  * \param[out] context resulting context struct
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier does not match, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are null or invalid, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_init(
    ffi.Pointer<rmw_init_options_t> options,
    ffi.Pointer<rmw_context_t> context,
  ) {
    return _rmw_init(
      options,
      context,
    );
  }

  late final _rmw_init_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_init>>('rmw_init');
  late final _dart_rmw_init _rmw_init =
      _rmw_init_ptr.asFunction<_dart_rmw_init>();

  /// Shutdown the middleware for a given context.
  /// /**
  ///  * The given context must be a valid context which has been initialized
  ///  * with rmw_init().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] context resulting context struct
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  ///  *   identifier does not match, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if the argument is null or invalid, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_shutdown(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return _rmw_shutdown(
      context,
    );
  }

  late final _rmw_shutdown_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_shutdown>>('rmw_shutdown');
  late final _dart_rmw_shutdown _rmw_shutdown =
      _rmw_shutdown_ptr.asFunction<_dart_rmw_shutdown>();

  /// Finalize a context.
  /// /**
  ///  * The context to be finalized must have been previously initialized with
  ///  * `rmw_init()`, and then later invalidated with `rmw_shutdown()`.
  ///  * If context is `NULL`, then `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  * If context is zero-initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  * If context is initialized and valid (`rmw_shutdown()` was not called on it),
  ///  * then `RMW_RET_INVALID_ARGUMENT` is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \return `RMW_RET_OK` if the shutdown was completed successfully, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occur.
  ///  */
  int rmw_context_fini(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return _rmw_context_fini(
      context,
    );
  }

  late final _rmw_context_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_context_fini>>('rmw_context_fini');
  late final _dart_rmw_context_fini _rmw_context_fini =
      _rmw_context_fini_ptr.asFunction<_dart_rmw_context_fini>();

  rmw_loaned_message_sequence_t
      rmw_get_zero_initialized_loaned_message_sequence() {
    return _rmw_get_zero_initialized_loaned_message_sequence();
  }

  late final _rmw_get_zero_initialized_loaned_message_sequence_ptr = _lookup<
          ffi.NativeFunction<
              _c_rmw_get_zero_initialized_loaned_message_sequence>>(
      'rmw_get_zero_initialized_loaned_message_sequence');
  late final _dart_rmw_get_zero_initialized_loaned_message_sequence
      _rmw_get_zero_initialized_loaned_message_sequence =
      _rmw_get_zero_initialized_loaned_message_sequence_ptr
          .asFunction<_dart_rmw_get_zero_initialized_loaned_message_sequence>();

  /// Return a rcl_arguments_t struct with members initialized to `NULL`.
  rcl_arguments_t rcl_get_zero_initialized_arguments() {
    return _rcl_get_zero_initialized_arguments();
  }

  late final _rcl_get_zero_initialized_arguments_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_arguments>>(
          'rcl_get_zero_initialized_arguments');
  late final _dart_rcl_get_zero_initialized_arguments
      _rcl_get_zero_initialized_arguments =
      _rcl_get_zero_initialized_arguments_ptr
          .asFunction<_dart_rcl_get_zero_initialized_arguments>();

  /// Parse command line arguments into a structure usable by code.
  /// /**
  ///  * \sa rcl_get_zero_initialized_arguments()
  ///  *
  ///  * ROS arguments are expected to be scoped by a leading `--ros-args` flag and a trailing double
  ///  * dash token `--` which may be elided if no non-ROS arguments follow after the last `--ros-args`.
  ///  *
  ///  * Remap rule parsing is supported via `-r/--remap` flags e.g. `--remap from:=to` or `-r from:=to`.
  ///  * Successfully parsed remap rules are stored in the order they were given in `argv`.
  ///  * If given arguments `{"__ns:=/foo", "__ns:=/bar"}` then the namespace used by nodes in this
  ///  * process will be `/foo` and not `/bar`.
  ///  *
  ///  * \sa rcl_remap_topic_name()
  ///  * \sa rcl_remap_service_name()
  ///  * \sa rcl_remap_node_name()
  ///  * \sa rcl_remap_node_namespace()
  ///  *
  ///  * Parameter override rule parsing is supported via `-p/--param` flags e.g. `--param name:=value`
  ///  * or `-p name:=value`.
  ///  *
  ///  * The default log level will be parsed as `--log-level level`, where `level` is a name
  ///  * representing one of the log levels in the `RCUTILS_LOG_SEVERITY` enum, e.g. `info`, `debug`,
  ///  * `warn`, not case sensitive.
  ///  * If multiple of these rules are found, the last one parsed will be used.
  ///  *
  ///  * If an argument does not appear to be a valid ROS argument e.g. a `-r/--remap` flag followed by
  ///  * anything but a valid remap rule, parsing will fail immediately.
  ///  *
  ///  * If an argument does not appear to be a known ROS argument, then it is skipped and left unparsed.
  ///  *
  ///  * \sa rcl_arguments_get_count_unparsed_ros()
  ///  * \sa rcl_arguments_get_unparsed_ros()
  ///  *
  ///  * All arguments found outside a `--ros-args ... --` scope are skipped and left unparsed.
  ///  *
  ///  * \sa rcl_arguments_get_count_unparsed()
  ///  * \sa rcl_arguments_get_unparsed()
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] argc The number of arguments in argv.
  ///  * \param[in] argv The values of the arguments.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] args_output A structure that will contain the result of parsing.
  ///  *   Must be zero initialized before use.
  ///  * \return `RCL_RET_OK` if the arguments were parsed successfully, or
  ///  * \return `RCL_RET_INVALID_ROS_ARGS` if an invalid ROS argument is found, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_parse_arguments(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
    rcutils_allocator_t allocator,
    ffi.Pointer<rcl_arguments_t> args_output,
  ) {
    return _rcl_parse_arguments(
      argc,
      argv,
      allocator,
      args_output,
    );
  }

  late final _rcl_parse_arguments_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_parse_arguments>>(
          'rcl_parse_arguments');
  late final _dart_rcl_parse_arguments _rcl_parse_arguments =
      _rcl_parse_arguments_ptr.asFunction<_dart_rcl_parse_arguments>();

  /// Return the number of arguments that were not ROS specific arguments.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \return number of unparsed arguments, or
  ///  * \return -1 if args is `NULL` or zero initialized.
  ///  */
  int rcl_arguments_get_count_unparsed(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return _rcl_arguments_get_count_unparsed(
      args,
    );
  }

  late final _rcl_arguments_get_count_unparsed_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_get_count_unparsed>>(
          'rcl_arguments_get_count_unparsed');
  late final _dart_rcl_arguments_get_count_unparsed
      _rcl_arguments_get_count_unparsed = _rcl_arguments_get_count_unparsed_ptr
          .asFunction<_dart_rcl_arguments_get_count_unparsed>();

  /// Return a list of indices to non ROS specific arguments.
  /// /**
  ///  * Non ROS specific arguments may have been provided i.e. arguments outside a '--ros-args' scope.
  ///  * This function populates an array of indices to these arguments in the original argv array.
  ///  * Since the first argument is always assumed to be a process name, the list will always contain
  ///  * the index 0.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] output_unparsed_indices An allocated array of indices into the original argv array.
  ///  *   This array must be deallocated by the caller using the given allocator.
  ///  *   If there are no unparsed args then the output will be set to NULL.
  ///  * \return `RCL_RET_OK` if everything goes correctly, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_arguments_get_unparsed(
    ffi.Pointer<rcl_arguments_t> args,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_indices,
  ) {
    return _rcl_arguments_get_unparsed(
      args,
      allocator,
      output_unparsed_indices,
    );
  }

  late final _rcl_arguments_get_unparsed_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_get_unparsed>>(
          'rcl_arguments_get_unparsed');
  late final _dart_rcl_arguments_get_unparsed _rcl_arguments_get_unparsed =
      _rcl_arguments_get_unparsed_ptr
          .asFunction<_dart_rcl_arguments_get_unparsed>();

  /// Return the number of ROS specific arguments that were not successfully parsed.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \return number of unparsed ROS specific arguments, or
  ///  * \return -1 if args is `NULL` or zero initialized.
  ///  */
  int rcl_arguments_get_count_unparsed_ros(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return _rcl_arguments_get_count_unparsed_ros(
      args,
    );
  }

  late final _rcl_arguments_get_count_unparsed_ros_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_get_count_unparsed_ros>>(
          'rcl_arguments_get_count_unparsed_ros');
  late final _dart_rcl_arguments_get_count_unparsed_ros
      _rcl_arguments_get_count_unparsed_ros =
      _rcl_arguments_get_count_unparsed_ros_ptr
          .asFunction<_dart_rcl_arguments_get_count_unparsed_ros>();

  /// Return a list of indices to unknown ROS specific arguments that were left unparsed.
  /// /**
  ///  * Some ROS specific arguments may not have been recognized, or were not intended to be
  ///  * parsed by rcl.
  ///  * This function populates an array of indices to these arguments in the original argv array.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] output_unparsed_indices An allocated array of indices into the original argv array.
  ///  *   This array must be deallocated by the caller using the given allocator.
  ///  *   If there are no unparsed ROS specific arguments then the output will be set to NULL.
  ///  * \return `RCL_RET_OK` if everything goes correctly, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_arguments_get_unparsed_ros(
    ffi.Pointer<rcl_arguments_t> args,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_ros_indices,
  ) {
    return _rcl_arguments_get_unparsed_ros(
      args,
      allocator,
      output_unparsed_ros_indices,
    );
  }

  late final _rcl_arguments_get_unparsed_ros_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_get_unparsed_ros>>(
          'rcl_arguments_get_unparsed_ros');
  late final _dart_rcl_arguments_get_unparsed_ros
      _rcl_arguments_get_unparsed_ros = _rcl_arguments_get_unparsed_ros_ptr
          .asFunction<_dart_rcl_arguments_get_unparsed_ros>();

  /// Return the number of parameter yaml files given in the arguments.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \return number of yaml files, or
  ///  * \return -1 if args is `NULL` or zero initialized.
  ///  */
  int rcl_arguments_get_param_files_count(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return _rcl_arguments_get_param_files_count(
      args,
    );
  }

  late final _rcl_arguments_get_param_files_count_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_get_param_files_count>>(
          'rcl_arguments_get_param_files_count');
  late final _dart_rcl_arguments_get_param_files_count
      _rcl_arguments_get_param_files_count =
      _rcl_arguments_get_param_files_count_ptr
          .asFunction<_dart_rcl_arguments_get_param_files_count>();

  /// Return a list of yaml parameter file paths specified on the command line.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] arguments An arguments structure that has been parsed.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] parameter_files An allocated array of paramter file names.
  ///  *   This array must be deallocated by the caller using the given allocator.
  ///  *   The output is NULL if there were no paramter files.
  ///  * \return `RCL_RET_OK` if everything goes correctly, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_arguments_get_param_files(
    ffi.Pointer<rcl_arguments_t> arguments,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> parameter_files,
  ) {
    return _rcl_arguments_get_param_files(
      arguments,
      allocator,
      parameter_files,
    );
  }

  late final _rcl_arguments_get_param_files_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_get_param_files>>(
          'rcl_arguments_get_param_files');
  late final _dart_rcl_arguments_get_param_files
      _rcl_arguments_get_param_files = _rcl_arguments_get_param_files_ptr
          .asFunction<_dart_rcl_arguments_get_param_files>();

  /// Return all parameter overrides parsed from the command line.
  /// /**
  ///  * Parameter overrides are parsed directly from command line arguments and
  ///  * parameter files provided in the command line.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] arguments An arguments structure that has been parsed.
  ///  * \param[out] parameter_overrides Parameter overrides as parsed from command line arguments.
  ///  *   This structure must be finalized by the caller.
  ///  *   The output is NULL if no parameter overrides were parsed.
  ///  * \return `RCL_RET_OK` if everything goes correctly, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_arguments_get_param_overrides(
    ffi.Pointer<rcl_arguments_t> arguments,
    ffi.Pointer<ffi.Pointer<rcl_params_t>> parameter_overrides,
  ) {
    return _rcl_arguments_get_param_overrides(
      arguments,
      parameter_overrides,
    );
  }

  late final _rcl_arguments_get_param_overrides_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_get_param_overrides>>(
          'rcl_arguments_get_param_overrides');
  late final _dart_rcl_arguments_get_param_overrides
      _rcl_arguments_get_param_overrides =
      _rcl_arguments_get_param_overrides_ptr
          .asFunction<_dart_rcl_arguments_get_param_overrides>();

  /// Return a list of arguments with ROS-specific arguments removed.
  /// /**
  ///  * Some arguments may not have been intended as ROS arguments.
  ///  * This function populates an array of the aruments in a new argv array.
  ///  * Since the first argument is always assumed to be a process name, the list
  ///  * will always contain the first value from the argument vector.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] argv The argument vector
  ///  * \param[in] args An arguments structure that has been parsed.
  ///  * \param[in] allocator A valid allocator.
  ///  * \param[out] nonros_argc The count of arguments that aren't ROS-specific
  ///  * \param[out] nonros_argv An allocated array of arguments that aren't ROS-specific
  ///  *   This array must be deallocated by the caller using the given allocator.
  ///  *   If there are no non-ROS args, then the output will be set to NULL.
  ///  * \return `RCL_RET_OK` if everything goes correctly, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_remove_ros_arguments(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
    ffi.Pointer<rcl_arguments_t> args,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Int32> nonros_argc,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> nonros_argv,
  ) {
    return _rcl_remove_ros_arguments(
      argv,
      args,
      allocator,
      nonros_argc,
      nonros_argv,
    );
  }

  late final _rcl_remove_ros_arguments_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_remove_ros_arguments>>(
          'rcl_remove_ros_arguments');
  late final _dart_rcl_remove_ros_arguments _rcl_remove_ros_arguments =
      _rcl_remove_ros_arguments_ptr
          .asFunction<_dart_rcl_remove_ros_arguments>();

  /// Copy one arguments structure into another.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args The structure to be copied.
  ///  *  Its allocator is used to copy memory into the new structure.
  ///  * \param[out] args_out A zero-initialized arguments structure to be copied into.
  ///  * \return `RCL_RET_OK` if the structure was copied successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_arguments_copy(
    ffi.Pointer<rcl_arguments_t> args,
    ffi.Pointer<rcl_arguments_t> args_out,
  ) {
    return _rcl_arguments_copy(
      args,
      args_out,
    );
  }

  late final _rcl_arguments_copy_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_copy>>('rcl_arguments_copy');
  late final _dart_rcl_arguments_copy _rcl_arguments_copy =
      _rcl_arguments_copy_ptr.asFunction<_dart_rcl_arguments_copy>();

  /// Reclaim resources held inside rcl_arguments_t structure.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] args The structure to be deallocated.
  ///  * \return `RCL_RET_OK` if the memory was successfully freed, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_arguments_fini(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return _rcl_arguments_fini(
      args,
    );
  }

  late final _rcl_arguments_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_arguments_fini>>('rcl_arguments_fini');
  late final _dart_rcl_arguments_fini _rcl_arguments_fini =
      _rcl_arguments_fini_ptr.asFunction<_dart_rcl_arguments_fini>();

  /// Return a zero initialized rcl_init_options_t struct.
  rcl_init_options_t rcl_get_zero_initialized_init_options() {
    return _rcl_get_zero_initialized_init_options();
  }

  late final _rcl_get_zero_initialized_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_init_options>>(
          'rcl_get_zero_initialized_init_options');
  late final _dart_rcl_get_zero_initialized_init_options
      _rcl_get_zero_initialized_init_options =
      _rcl_get_zero_initialized_init_options_ptr
          .asFunction<_dart_rcl_get_zero_initialized_init_options>();

  /// Initialize given init_options with the default values and implementation specific values.
  /// /**
  ///  * The given allocator is used, if required, during setup of the init options,
  ///  * but is also used during initialization.
  ///  *
  ///  * In either case the given allocator is stored in the returned init options.
  ///  *
  ///  * The `impl` pointer should not be changed manually.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] init_options object to be setup
  ///  * \param[in] allocator to be used during setup and during initialization
  ///  * \return `RCL_RET_OK` if setup is successful, or
  ///  * \return `RCL_RET_ALREADY_INIT` if init_options has already be initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_init_options_init(
    ffi.Pointer<rcl_init_options_t> init_options,
    rcutils_allocator_t allocator,
  ) {
    return _rcl_init_options_init(
      init_options,
      allocator,
    );
  }

  late final _rcl_init_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_init_options_init>>(
          'rcl_init_options_init');
  late final _dart_rcl_init_options_init _rcl_init_options_init =
      _rcl_init_options_init_ptr.asFunction<_dart_rcl_init_options_init>();

  /// Copy the given source init_options to the destination init_options.
  /// /**
  ///  * The allocator from the source is used for any allocations and stored in the
  ///  * destination.
  ///  *
  ///  * The destination should either be zero initialized with
  ///  * `rcl_get_zero_initialized_init_options()` or should have had
  ///  * `rcl_init_options_fini()` called on it.
  ///  * Giving an already initialized init options for the destination will result
  ///  * in a failure with return code `RCL_RET_ALREADY_INIT`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] src rcl_init_options_t object to be copied from
  ///  * \param[out] dst rcl_init_options_t object to be copied into
  ///  * \return `RCL_RET_OK` if the copy is successful, or
  ///  * \return `RCL_RET_ALREADY_INIT` if the dst has already be initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_init_options_copy(
    ffi.Pointer<rcl_init_options_t> src,
    ffi.Pointer<rcl_init_options_t> dst,
  ) {
    return _rcl_init_options_copy(
      src,
      dst,
    );
  }

  late final _rcl_init_options_copy_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_init_options_copy>>(
          'rcl_init_options_copy');
  late final _dart_rcl_init_options_copy _rcl_init_options_copy =
      _rcl_init_options_copy_ptr.asFunction<_dart_rcl_init_options_copy>();

  /// Finalize the given init_options.
  /// /**
  ///  * The given init_options must be non-`NULL` and valid, i.e. had
  ///  * `rcl_init_options_init()` called on it but not this function yet.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] init_options object to be setup
  ///  * \return `RCL_RET_OK` if setup is successful, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_init_options_fini(
    ffi.Pointer<rcl_init_options_t> init_options,
  ) {
    return _rcl_init_options_fini(
      init_options,
    );
  }

  late final _rcl_init_options_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_init_options_fini>>(
          'rcl_init_options_fini');
  late final _dart_rcl_init_options_fini _rcl_init_options_fini =
      _rcl_init_options_fini_ptr.asFunction<_dart_rcl_init_options_fini>();

  /// Return the rmw init options which are stored internally.
  /// /**
  ///  * This function can fail and return `NULL` if:
  ///  *   - init_options is NULL
  ///  *   - init_options is invalid, e.g. init_options->impl is NULL
  ///  *
  ///  * If NULL is returned an error message will have been set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] init_options object from which the rmw init options should be retrieved
  ///  * \return pointer to the the rmw init options, or
  ///  * \return `NULL` if there was an error
  ///  */
  ffi.Pointer<rmw_init_options_t> rcl_init_options_get_rmw_init_options(
    ffi.Pointer<rcl_init_options_t> init_options,
  ) {
    return _rcl_init_options_get_rmw_init_options(
      init_options,
    );
  }

  late final _rcl_init_options_get_rmw_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_init_options_get_rmw_init_options>>(
          'rcl_init_options_get_rmw_init_options');
  late final _dart_rcl_init_options_get_rmw_init_options
      _rcl_init_options_get_rmw_init_options =
      _rcl_init_options_get_rmw_init_options_ptr
          .asFunction<_dart_rcl_init_options_get_rmw_init_options>();

  /// Return a zero initialization context object.
  rcl_context_t rcl_get_zero_initialized_context() {
    return _rcl_get_zero_initialized_context();
  }

  late final _rcl_get_zero_initialized_context_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_context>>(
          'rcl_get_zero_initialized_context');
  late final _dart_rcl_get_zero_initialized_context
      _rcl_get_zero_initialized_context = _rcl_get_zero_initialized_context_ptr
          .asFunction<_dart_rcl_get_zero_initialized_context>();

  /// Finalize a context.
  /// /**
  ///  * The context to be finalized must have been previously initialized with
  ///  * `rcl_init()`, and then later invalidated with `rcl_shutdown()`.
  ///  * If context is `NULL`, then `RCL_RET_INVALID_ARGUMENT` is returned.
  ///  * If context is zero-initialized, then `RCL_RET_INVALID_ARGUMENT` is returned.
  ///  * If context is initialized and valid (`rcl_shutdown()` was not called on it),
  ///  * then `RCL_RET_INVALID_ARGUMENT` is returned.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \return `RCL_RET_OK` if the shutdown was completed successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occur.
  ///  */
  int rcl_context_fini(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_fini(
      context,
    );
  }

  late final _rcl_context_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_context_fini>>('rcl_context_fini');
  late final _dart_rcl_context_fini _rcl_context_fini =
      _rcl_context_fini_ptr.asFunction<_dart_rcl_context_fini>();

  /// Return the init options used during initialization for this context.
  /// /**
  ///  * This function can fail and return `NULL` if:
  ///  *   - context is NULL
  ///  *   - context is zero-initialized, e.g. context->impl is `NULL`
  ///  *
  ///  * If context is uninitialized then that is undefined behavior.
  ///  *
  ///  * If `NULL` is returned an error message will have been set.
  ///  *
  ///  * The options are for reference only, and therefore the returned pointer is
  ///  * const.
  ///  * Changing the values in the options is undefined behavior but will likely
  ///  * have no effect.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] context object from which the init options should be retrieved
  ///  * \return pointer to the the init options, or
  ///  * \return `NULL` if there was an error
  ///  */
  ffi.Pointer<rcl_init_options_t> rcl_context_get_init_options(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_get_init_options(
      context,
    );
  }

  late final _rcl_context_get_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_context_get_init_options>>(
          'rcl_context_get_init_options');
  late final _dart_rcl_context_get_init_options _rcl_context_get_init_options =
      _rcl_context_get_init_options_ptr
          .asFunction<_dart_rcl_context_get_init_options>();

  /// Returns an unsigned integer that is unique to the given context, or `0` if invalid.
  /// /**
  ///  * The given context must be non-`NULL`, but does not need to be initialized or valid.
  ///  * If context is `NULL`, then `0` will be returned.
  ///  * If context is uninitialized, then it is undefined behavior.
  ///  *
  ///  * The instance ID may be `0` if the context is zero-initialized or if the
  ///  * context has been invalidated by `rcl_shutdown()`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] context object from which the instance id should be retrieved
  ///  * \return a unique id specific to this context instance, or
  ///  * \return `0` if invalid, or
  ///  * \return `0` if context is `NULL`
  ///  */
  int rcl_context_get_instance_id(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_get_instance_id(
      context,
    );
  }

  late final _rcl_context_get_instance_id_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_context_get_instance_id>>(
          'rcl_context_get_instance_id');
  late final _dart_rcl_context_get_instance_id _rcl_context_get_instance_id =
      _rcl_context_get_instance_id_ptr
          .asFunction<_dart_rcl_context_get_instance_id>();

  /// Return `true` if the given context is currently valid, otherwise `false`.
  /// /**
  ///  * If context is `NULL`, then `false` is returned.
  ///  * If context is zero-initialized, then `false` is returned.
  ///  * If context is uninitialized, then it is undefined behavior.
  ///  *
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] context object which should be checked for validity
  ///  * \return `true` if valid, otherwise `false`
  ///  */
  bool rcl_context_is_valid(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_is_valid(
          context,
        ) !=
        0;
  }

  late final _rcl_context_is_valid_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_context_is_valid>>(
          'rcl_context_is_valid');
  late final _dart_rcl_context_is_valid _rcl_context_is_valid =
      _rcl_context_is_valid_ptr.asFunction<_dart_rcl_context_is_valid>();

  /// Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`.
  /// /**
  ///  * If context is `NULL`, then `NULL` is returned.
  ///  * If context is zero-initialized, then `NULL` is returned.
  ///  * If context is uninitialized, then it is undefined behavior.
  ///  *
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] context object from which the rmw context should be retrieved.
  ///  * \return pointer to rmw context if valid, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_context_t> rcl_context_get_rmw_context(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_context_get_rmw_context(
      context,
    );
  }

  late final _rcl_context_get_rmw_context_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_context_get_rmw_context>>(
          'rcl_context_get_rmw_context');
  late final _dart_rcl_context_get_rmw_context _rcl_context_get_rmw_context =
      _rcl_context_get_rmw_context_ptr
          .asFunction<_dart_rcl_context_get_rmw_context>();

  /// Return the default node options in a rcl_node_options_t.
  /// /**
  ///  * The default values are:
  ///  *
  ///  * - domain_id = RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID
  ///  * - allocator = rcl_get_default_allocator()
  ///  * - use_global_arguments = true
  ///  * - arguments = rcl_get_zero_initialized_arguments()
  ///  */
  rcl_node_options_t rcl_node_get_default_options() {
    return _rcl_node_get_default_options();
  }

  late final _rcl_node_get_default_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_default_options>>(
          'rcl_node_get_default_options');
  late final _dart_rcl_node_get_default_options _rcl_node_get_default_options =
      _rcl_node_get_default_options_ptr
          .asFunction<_dart_rcl_node_get_default_options>();

  /// Copy one options structure into another.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] options The structure to be copied.
  ///  *   Its allocator is used to copy memory into the new structure.
  ///  * \param[out] options_out An options structure containing default values.
  ///  * \return `RCL_RET_OK` if the structure was copied successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_node_options_copy(
    ffi.Pointer<rcl_node_options_t> options,
    ffi.Pointer<rcl_node_options_t> options_out,
  ) {
    return _rcl_node_options_copy(
      options,
      options_out,
    );
  }

  late final _rcl_node_options_copy_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_options_copy>>(
          'rcl_node_options_copy');
  late final _dart_rcl_node_options_copy _rcl_node_options_copy =
      _rcl_node_options_copy_ptr.asFunction<_dart_rcl_node_options_copy>();

  /// Finalize the given node_options.
  /// /**
  ///  * The given node_options must be non-`NULL` and valid, i.e. had
  ///  * `rcl_node_get_default_options()` called on it but not this function yet.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] node_options object to be finalized
  ///  * \return `RCL_RET_OK` if setup is successful, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_node_options_fini(
    ffi.Pointer<rcl_node_options_t> options,
  ) {
    return _rcl_node_options_fini(
      options,
    );
  }

  late final _rcl_node_options_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_options_fini>>(
          'rcl_node_options_fini');
  late final _dart_rcl_node_options_fini _rcl_node_options_fini =
      _rcl_node_options_fini_ptr.asFunction<_dart_rcl_node_options_fini>();

  /// Return a rcl_node_t struct with members initialized to `NULL`.
  rcl_node_t rcl_get_zero_initialized_node() {
    return _rcl_get_zero_initialized_node();
  }

  late final _rcl_get_zero_initialized_node_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_node>>(
          'rcl_get_zero_initialized_node');
  late final _dart_rcl_get_zero_initialized_node
      _rcl_get_zero_initialized_node = _rcl_get_zero_initialized_node_ptr
          .asFunction<_dart_rcl_get_zero_initialized_node>();

  /// Initialize a ROS node.
  /// /**
  ///  * Calling this on a rcl_node_t makes it a valid node handle until rcl_shutdown
  ///  * is called or until rcl_node_fini is called on it.
  ///  *
  ///  * After calling, the ROS node object can be used to create other middleware
  ///  * primitives like publishers, services, parameters, etc.
  ///  *
  ///  * The name of the node must not be NULL and adhere to naming restrictions,
  ///  * see the rmw_validate_node_name() function for rules.
  ///  *
  ///  * \todo TODO(wjwwood): node name uniqueness is no yet enforced
  ///  *
  ///  * The name of the node cannot coincide with another node of the same name.
  ///  * If a node of the same name is already in the domain, it will be shutdown.
  ///  *
  ///  * The namespace of the node should not be NULL and should also pass the
  ///  * rmw_validate_namespace() function's rules.
  ///  *
  ///  * Additionally this function allows namespaces which lack a leading forward
  ///  * slash.
  ///  * Because there is no notion of a relative namespace, there is no difference
  ///  * between a namespace which lacks a forward and the same namespace with a
  ///  * leasing forward slash.
  ///  * Therefore, a namespace like ``"foo/bar"`` is automatically changed to
  ///  * ``"/foo/bar"`` by this function.
  ///  * Similarly, the namespace ``""`` will implicitly become ``"/"`` which is a
  ///  * valid namespace.
  ///  *
  ///  * \todo TODO(wjwwood):
  ///  *   Parameter infrastructure is currently initialized in the language specific
  ///  *   client library, e.g. rclcpp for C++, but will be initialized here in the
  ///  *   future. When that happens there will be an option to avoid parameter
  ///  *   infrastructure with an option in the rcl_node_options_t struct.
  ///  *
  ///  * A node contains infrastructure for ROS parameters, which include advertising
  ///  * publishers and service servers.
  ///  * This function will create those external parameter interfaces even if
  ///  * parameters are not used later.
  ///  *
  ///  * The rcl_node_t given must be allocated and zero initialized.
  ///  * Passing an rcl_node_t which has already had this function called on it, more
  ///  * recently than rcl_node_fini, will fail.
  ///  * An allocated rcl_node_t with uninitialized memory is undefined behavior.
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * rcl_context_t context = rcl_get_zero_initialized_context();
  ///  * // ... initialize the context with rcl_init()
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * // ... node options customization
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/node_ns", &context, &node_ops);
  ///  * // ... error handling and then use the node, but eventually deinitialize it:
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_node_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \pre the node handle must be allocated, zero initialized, and invalid
  ///  * \pre the context handle must be allocated, initialized, and valid
  ///  * \post the node handle is valid and can be used in other `rcl_*` functions
  ///  *
  ///  * \param[inout] node a preallocated rcl_node_t
  ///  * \param[in] name the name of the node, must be a valid c-string
  ///  * \param[in] namespace_ the namespace of the node, must be a valid c-string
  ///  * \param[in] context the context instance with which the node should be
  ///  *   associated
  ///  * \param[in] options the node options.
  ///  *   The options are deep copied into the node.
  ///  *   The caller is always responsible for freeing memory used options they
  ///  *   pass in.
  ///  * \return `RCL_RET_OK` if the node was initialized successfully, or
  ///  * \return `RCL_RET_ALREADY_INIT` if the node has already be initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_NODE_INVALID_NAME` if the name is invalid, or
  ///  * \return `RCL_RET_NODE_INVALID_NAMESPACE` if the namespace_ is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_node_init(
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> namespace_,
    ffi.Pointer<rcl_context_t> context,
    ffi.Pointer<rcl_node_options_t> options,
  ) {
    return _rcl_node_init(
      node,
      name,
      namespace_,
      context,
      options,
    );
  }

  late final _rcl_node_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_init>>('rcl_node_init');
  late final _dart_rcl_node_init _rcl_node_init =
      _rcl_node_init_ptr.asFunction<_dart_rcl_node_init>();

  /// Finalize a rcl_node_t.
  /// /**
  ///  * Destroys any automatically created infrastructure and deallocates memory.
  ///  * After calling, the rcl_node_t can be safely deallocated.
  ///  *
  ///  * Any middleware primitives created by the user, e.g. publishers, services, etc.,
  ///  * are invalid after deinitialization.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] node rcl_node_t to be finalized
  ///  * \return `RCL_RET_OK` if node was finalized successfully, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node pointer is null, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_node_fini(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_fini(
      node,
    );
  }

  late final _rcl_node_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_fini>>('rcl_node_fini');
  late final _dart_rcl_node_fini _rcl_node_fini =
      _rcl_node_fini_ptr.asFunction<_dart_rcl_node_fini>();

  /// Return `true` if the node is valid, else `false`.
  /// /**
  ///  * Also return `false` if the node pointer is `NULL` or the allocator is invalid.
  ///  *
  ///  * A node is invalid if:
  ///  *   - the implementation is `NULL` (rcl_node_init not called or failed)
  ///  *   - rcl_shutdown has been called since the node has been initialized
  ///  *   - the node has been finalized with rcl_node_fini
  ///  *
  ///  * There is a possible validity race condition.
  ///  *
  ///  * Consider:
  ///  *
  ///  * ```c
  ///  * assert(rcl_node_is_valid(node));  // <-- thread 1
  ///  * rcl_shutdown();                   // <-- thread 2
  ///  * // use node as if valid           // <-- thread 1
  ///  * ```
  ///  *
  ///  * In the third line the node is now invalid, even though on the previous line
  ///  * of thread 1 it was checked to be valid.
  ///  * This is why this function is considered not thread-safe.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] node rcl_node_t to be validated
  ///  * \return `true` if the node and allocator are valid, otherwise `false`.
  ///  */
  bool rcl_node_is_valid(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_is_valid(
          node,
        ) !=
        0;
  }

  late final _rcl_node_is_valid_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_is_valid>>('rcl_node_is_valid');
  late final _dart_rcl_node_is_valid _rcl_node_is_valid =
      _rcl_node_is_valid_ptr.asFunction<_dart_rcl_node_is_valid>();

  /// Return true if node is valid, except for the context being valid.
  /// /**
  ///  * This is used in clean up functions that need to access the node, but do not
  ///  * need use any functions with the context.
  ///  *
  ///  * It is identical to rcl_node_is_valid except it ignores the state of the
  ///  * context associated with the node.
  ///  * \sa rcl_node_is_valid()
  ///  */
  bool rcl_node_is_valid_except_context(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_is_valid_except_context(
          node,
        ) !=
        0;
  }

  late final _rcl_node_is_valid_except_context_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_is_valid_except_context>>(
          'rcl_node_is_valid_except_context');
  late final _dart_rcl_node_is_valid_except_context
      _rcl_node_is_valid_except_context = _rcl_node_is_valid_except_context_ptr
          .asFunction<_dart_rcl_node_is_valid_except_context>();

  /// Return the name of the node.
  /// /**
  ///  * This function returns the node's internal name string.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned string is only valid as long as the given rcl_node_t is valid.
  ///  * The value of the string may change if the value in the rcl_node_t changes,
  ///  * and therefore copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Int8> rcl_node_get_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_name(
      node,
    );
  }

  late final _rcl_node_get_name_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_name>>('rcl_node_get_name');
  late final _dart_rcl_node_get_name _rcl_node_get_name =
      _rcl_node_get_name_ptr.asFunction<_dart_rcl_node_get_name>();

  /// Return the namespace of the node.
  /// /**
  ///  * This function returns the node's internal namespace string.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned string is only valid as long as the given rcl_node_t is valid.
  ///  * The value of the string may change if the value in the rcl_node_t changes,
  ///  * and therefore copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Int8> rcl_node_get_namespace(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_namespace(
      node,
    );
  }

  late final _rcl_node_get_namespace_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_namespace>>(
          'rcl_node_get_namespace');
  late final _dart_rcl_node_get_namespace _rcl_node_get_namespace =
      _rcl_node_get_namespace_ptr.asFunction<_dart_rcl_node_get_namespace>();

  /// Return the fully qualified name of the node.
  /// /**
  ///  * This function returns the node's internal namespace and name combined string.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return fully qualified name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Int8> rcl_node_get_fully_qualified_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_fully_qualified_name(
      node,
    );
  }

  late final _rcl_node_get_fully_qualified_name_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_fully_qualified_name>>(
          'rcl_node_get_fully_qualified_name');
  late final _dart_rcl_node_get_fully_qualified_name
      _rcl_node_get_fully_qualified_name =
      _rcl_node_get_fully_qualified_name_ptr
          .asFunction<_dart_rcl_node_get_fully_qualified_name>();

  /// Return the rcl node options.
  /// /**
  ///  * This function returns the node's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned struct is only valid as long as the given rcl_node_t is valid.
  ///  * The values in the struct may change if the options of the rcl_node_t changes,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_node_options_t> rcl_node_get_options(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_options(
      node,
    );
  }

  late final _rcl_node_get_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_options>>(
          'rcl_node_get_options');
  late final _dart_rcl_node_get_options _rcl_node_get_options =
      _rcl_node_get_options_ptr.asFunction<_dart_rcl_node_get_options>();

  /// Return the ROS domain ID that the node is using.
  /// /**
  ///  * This function returns the ROS domain ID that the node is in.
  ///  *
  ///  * This function should be used to determine what `domain_id` was used rather
  ///  * than checking the domin_id field in the node options, because if
  ///  * `RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID` is used when creating the node then
  ///  * it is not changed after creation, but this function will return the actual
  ///  * `domain_id` used.
  ///  *
  ///  * The `domain_id` field must point to an allocated `size_t` object to which
  ///  * the ROS domain ID will be written.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node the handle to the node being queried
  ///  * \param[out] domain_id storage for the domain id
  ///  * \return `RCL_RET_OK` if node the domain ID was retrieved successfully, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_node_get_domain_id(
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<ffi.Uint64> domain_id,
  ) {
    return _rcl_node_get_domain_id(
      node,
      domain_id,
    );
  }

  late final _rcl_node_get_domain_id_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_domain_id>>(
          'rcl_node_get_domain_id');
  late final _dart_rcl_node_get_domain_id _rcl_node_get_domain_id =
      _rcl_node_get_domain_id_ptr.asFunction<_dart_rcl_node_get_domain_id>();

  /// Manually assert that this node is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE)
  /// /**
  ///  * If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE, the creator of
  ///  * this node may manually call `assert_liveliness` at some point in time to signal to the rest
  ///  * of the system that this Node is still alive.
  ///  * This function must be called at least as often as the qos_profile's liveliness_lease_duration
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node handle to the node that needs liveliness to be asserted
  ///  * \return `RCL_RET_OK` if the liveliness assertion was completed successfully, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_node_assert_liveliness(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_assert_liveliness(
      node,
    );
  }

  late final _rcl_node_assert_liveliness_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_assert_liveliness>>(
          'rcl_node_assert_liveliness');
  late final _dart_rcl_node_assert_liveliness _rcl_node_assert_liveliness =
      _rcl_node_assert_liveliness_ptr
          .asFunction<_dart_rcl_node_assert_liveliness>();

  /// Return the rmw node handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned handle is made invalid if the node is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * node as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the node using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the rcl node
  ///  * \return rmw node handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_node_t> rcl_node_get_rmw_handle(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_rmw_handle(
      node,
    );
  }

  late final _rcl_node_get_rmw_handle_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_rmw_handle>>(
          'rcl_node_get_rmw_handle');
  late final _dart_rcl_node_get_rmw_handle _rcl_node_get_rmw_handle =
      _rcl_node_get_rmw_handle_ptr.asFunction<_dart_rcl_node_get_rmw_handle>();

  /// Return the associated rcl instance id.
  /// /**
  ///  * This id is stored when rcl_node_init is called and can be compared with the
  ///  * value returned by rcl_get_instance_id() to check if this node was created in
  ///  * the current rcl context (since the latest call to rcl_init().
  ///  *
  ///  * This function can fail, and therefore return `0`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * This function will succeed even if rcl_shutdown() has been called
  ///  * since the node was created.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the rcl node
  ///  * \return rcl instance id captured during node init or `0` on error
  ///  */
  int rcl_node_get_rcl_instance_id(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_rcl_instance_id(
      node,
    );
  }

  late final _rcl_node_get_rcl_instance_id_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_rcl_instance_id>>(
          'rcl_node_get_rcl_instance_id');
  late final _dart_rcl_node_get_rcl_instance_id _rcl_node_get_rcl_instance_id =
      _rcl_node_get_rcl_instance_id_ptr
          .asFunction<_dart_rcl_node_get_rcl_instance_id>();

  /// Return a guard condition which is triggered when the ROS graph changes.
  /// /**
  ///  * The handle returned is a pointer to an internally held rcl guard condition.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node is invalid
  ///  *
  ///  * The returned handle is made invalid if the node is finialized or if
  ///  * rcl_shutdown() is called.
  ///  *
  ///  * The guard condition will be triggered anytime a change to the ROS graph occurs.
  ///  * A ROS graph change includes things like (but not limited to) a new publisher
  ///  * advertises, a new subscription is created, a new service becomes available,
  ///  * a subscription is canceled, etc.
  ///  *
  ///  * \todo TODO(wjwwood): link to exhaustive list of graph events
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the rcl node
  ///  * \return rcl guard condition handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_guard_condition_t> rcl_node_get_graph_guard_condition(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_graph_guard_condition(
      node,
    );
  }

  late final _rcl_node_get_graph_guard_condition_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_graph_guard_condition>>(
          'rcl_node_get_graph_guard_condition');
  late final _dart_rcl_node_get_graph_guard_condition
      _rcl_node_get_graph_guard_condition =
      _rcl_node_get_graph_guard_condition_ptr
          .asFunction<_dart_rcl_node_get_graph_guard_condition>();

  /// Return the logger name of the node.
  /// /**
  ///  * This function returns the node's internal logger name string.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned string is only valid as long as the given rcl_node_t is valid.
  ///  * The value of the string may change if the value in the rcl_node_t changes,
  ///  * and therefore copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the node
  ///  * \return logger_name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Int8> rcl_node_get_logger_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_node_get_logger_name(
      node,
    );
  }

  late final _rcl_node_get_logger_name_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_node_get_logger_name>>(
          'rcl_node_get_logger_name');
  late final _dart_rcl_node_get_logger_name _rcl_node_get_logger_name =
      _rcl_node_get_logger_name_ptr
          .asFunction<_dart_rcl_node_get_logger_name>();

  /// Return a rcl_client_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_client_t before passing to
  ///  * rcl_client_init().
  ///  */
  rcl_client_t rcl_get_zero_initialized_client() {
    return _rcl_get_zero_initialized_client();
  }

  late final _rcl_get_zero_initialized_client_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_client>>(
          'rcl_get_zero_initialized_client');
  late final _dart_rcl_get_zero_initialized_client
      _rcl_get_zero_initialized_client = _rcl_get_zero_initialized_client_ptr
          .asFunction<_dart_rcl_get_zero_initialized_client>();

  /// Initialize a rcl client.
  /// /**
  ///  * After calling this function on a rcl_client_t, it can be used to send
  ///  * requests of the given type by calling rcl_send_request().
  ///  * If the request is received by a (possibly remote) service and if the service
  ///  * sends a response, the client can access the response through
  ///  * rcl_take_response() once the response is available to the client.
  ///  *
  ///  * The given rcl_node_t must be valid and the resulting rcl_client_t is only
  ///  * valid as long as the given rcl_node_t remains valid.
  ///  *
  ///  * The rosidl_service_type_support_t is obtained on a per `.srv` type basis.
  ///  * When the user defines a ROS service, code is generated which provides the
  ///  * required rosidl_service_type_support_t object.
  ///  * This object can be obtained using a language appropriate mechanism.
  ///  * \todo TODO(wjwwood) write these instructions once and link to it instead
  ///  *
  ///  * For C, a macro can be used (for example `example_interfaces/AddTwoInts`):
  ///  *
  ///  * ```c
  ///  * #include <rosidl_generator_c/service_type_support_struct.h>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  *
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  ///  * ```
  ///  *
  ///  * For C++, a template function is used:
  ///  *
  ///  * ```cpp
  ///  * #include <rosidl_typesupport_cpp/service_type_support.hpp>
  ///  * #include <example_interfaces/srv/add_two_ints.hpp>
  ///  *
  ///  * using rosidl_typesupport_cpp::get_service_type_support_handle;
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();
  ///  * ```
  ///  *
  ///  * The rosidl_service_type_support_t object contains service type specific
  ///  * information used to send or take requests and responses.
  ///  *
  ///  * The topic name must be a c string which follows the topic and service name
  ///  * format rules for unexpanded names, also known as non-fully qualified names:
  ///  *
  ///  * \see rcl_expand_topic_name
  ///  *
  ///  * The options struct allows the user to set the quality of service settings as
  ///  * well as a custom allocator which is used when initializing/finalizing the
  ///  * client to allocate space for incidentals, e.g. the service name string.
  ///  *
  ///  * Expected usage (for C services):
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  * #include <rosidl_generator_c/service_type_support_struct.h>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  *
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  ///  * // ... error handling
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  ///  * rcl_client_t client = rcl_get_zero_initialized_client();
  ///  * rcl_client_options_t client_ops = rcl_client_get_default_options();
  ///  * ret = rcl_client_init(&client, &node, ts, "add_two_ints", &client_ops);
  ///  * // ... error handling, and on shutdown do finalization:
  ///  * ret = rcl_client_fini(&client, &node);
  ///  * // ... error handling for rcl_client_fini()
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_node_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] client preallocated rcl_client_t structure
  ///  * \param[in] node valid rcl_node_t
  ///  * \param[in] type_support type support object for the service's type
  ///  * \param[in] service_name the name of the service to request
  ///  * \param[in] options client options, including quality of service settings
  ///  * \return `RCL_RET_OK` if the client was initialized successfully, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_ALREADY_INIT` if the client is already initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory fails, or
  ///  * \return `RCL_RET_SERVICE_NAME_INVALID` if the given service name is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_client_init(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> service_name,
    ffi.Pointer<rcl_client_options_t> options,
  ) {
    return _rcl_client_init(
      client,
      node,
      type_support,
      service_name,
      options,
    );
  }

  late final _rcl_client_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_client_init>>('rcl_client_init');
  late final _dart_rcl_client_init _rcl_client_init =
      _rcl_client_init_ptr.asFunction<_dart_rcl_client_init>();

  /// Finalize a rcl_client_t.
  /// /**
  ///  * After calling this function, calls to rcl_send_request() and
  ///  * rcl_take_response() will fail when using this client.
  ///  * However, the given node handle is still valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] client handle to the client to be finalized
  ///  * \param[in] node handle to the node used to create the client
  ///  * \return `RCL_RET_OK` if client was finalized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_client_fini(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_client_fini(
      client,
      node,
    );
  }

  late final _rcl_client_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_client_fini>>('rcl_client_fini');
  late final _dart_rcl_client_fini _rcl_client_fini =
      _rcl_client_fini_ptr.asFunction<_dart_rcl_client_fini>();

  /// Return the default client options in a rcl_client_options_t.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - qos = rmw_qos_profile_services_default
  ///  * - allocator = rcl_get_default_allocator()
  ///  */
  rcl_client_options_t rcl_client_get_default_options() {
    return _rcl_client_get_default_options();
  }

  late final _rcl_client_get_default_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_client_get_default_options>>(
          'rcl_client_get_default_options');
  late final _dart_rcl_client_get_default_options
      _rcl_client_get_default_options = _rcl_client_get_default_options_ptr
          .asFunction<_dart_rcl_client_get_default_options>();

  /// Send a ROS request using a client.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the `ros_request`
  ///  * parameter and the type associate with the client (via the type support)
  ///  * match.
  ///  * Passing a different type to `send_request` produces undefined behavior and
  ///  * cannot be checked by this function and therefore no deliberate error will
  ///  * occur.
  ///  *
  ///  * rcl_send_request() is an non-blocking call.
  ///  *
  ///  * The ROS request message given by the `ros_request` void pointer is always
  ///  * owned by the calling code, but should remain constant during `send_request`.
  ///  *
  ///  * This function is thread safe so long as access to both the client and the
  ///  * `ros_request` is synchronized.
  ///  * That means that calling rcl_send_request() from multiple threads is allowed,
  ///  * but calling rcl_send_request() at the same time as non-thread safe client
  ///  * functions is not, e.g. calling rcl_send_request() and rcl_client_fini()
  ///  * concurrently is not allowed.
  ///  * Before calling rcl_send_request() the message can change and after calling
  ///  * rcl_send_request() the message can change, but it cannot be changed during
  ///  * the `send_request` call.
  ///  * The same `ros_request`, however, can be passed to multiple calls of
  ///  * rcl_send_request() simultaneously, even if the clients differ.
  ///  * The `ros_request` is unmodified by rcl_send_request().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] for unique pairs of clients and requests, see above for more</i>
  ///  *
  ///  * \param[in] client handle to the client which will make the response
  ///  * \param[in] ros_request type-erased pointer to the ROS request message
  ///  * \param[out] sequence_number the sequence number
  ///  * \return `RCL_RET_OK` if the request was sent successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_CLIENT_INVALID` if the client is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_send_request(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Int64> sequence_number,
  ) {
    return _rcl_send_request(
      client,
      ros_request,
      sequence_number,
    );
  }

  late final _rcl_send_request_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_send_request>>('rcl_send_request');
  late final _dart_rcl_send_request _rcl_send_request =
      _rcl_send_request_ptr.asFunction<_dart_rcl_send_request>();

  /// Take a ROS response using a client
  /// /**
  ///  * It is the job of the caller to ensure that the type of the `ros_response`
  ///  * parameter and the type associate with the client (via the type support)
  ///  * match.
  ///  * Passing a different type to take_response produces undefined behavior and
  ///  * cannot be checked by this function and therefore no deliberate error will
  ///  * occur.
  ///  * The request_header is an rmw struct for meta-information about the request
  ///  * sent (e.g. the sequence number).
  ///  * The caller must provide a pointer to an allocated struct.
  ///  * This function will populate the struct's fields.
  ///  * `ros_response` should point to an already allocated ROS response message
  ///  * struct of the correct type, into which the response from the service will be
  ///  * copied.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if required when filling the message, avoided for fixed sizes</i>
  ///  *
  ///  * \param[in] client handle to the client which will take the response
  ///  * \param[inout] request_header pointer to the request header
  ///  * \param[inout] ros_response type-erased pointer to the ROS response message
  ///  * \return `RCL_RET_OK` if the response was taken successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_CLIENT_INVALID` if the client is invalid, or
  ///  * \return `RCL_RET_CLIENT_TAKE_FAILED` if take failed but no error occurred
  ///  *         in the middleware, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_take_response(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return _rcl_take_response(
      client,
      request_header,
      ros_response,
    );
  }

  late final _rcl_take_response_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_take_response>>('rcl_take_response');
  late final _dart_rcl_take_response _rcl_take_response =
      _rcl_take_response_ptr.asFunction<_dart_rcl_take_response>();

  /// Get the name of the service that this client will request a response from.
  /// /**
  ///  * This function returns the client's internal service name string.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - client is `NULL`
  ///  *   - client is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned string is only valid as long as the rcl_client_t is valid.
  ///  * The value of the string may change if the service name changes, and therefore
  ///  * copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the client
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Int8> rcl_client_get_service_name(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_get_service_name(
      client,
    );
  }

  late final _rcl_client_get_service_name_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_client_get_service_name>>(
          'rcl_client_get_service_name');
  late final _dart_rcl_client_get_service_name _rcl_client_get_service_name =
      _rcl_client_get_service_name_ptr
          .asFunction<_dart_rcl_client_get_service_name>();

  /// Return the rcl client options.
  /// /**
  ///  * This function returns the client's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - client is `NULL`
  ///  *   - client is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned struct is only valid as long as the rcl_client_t is valid.
  ///  * The values in the struct may change if the options of the client change,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the client
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_client_options_t> rcl_client_get_options(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_get_options(
      client,
    );
  }

  late final _rcl_client_get_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_client_get_options>>(
          'rcl_client_get_options');
  late final _dart_rcl_client_get_options _rcl_client_get_options =
      _rcl_client_get_options_ptr.asFunction<_dart_rcl_client_get_options>();

  /// Return the rmw client handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - client is `NULL`
  ///  *   - client is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned handle is made invalid if the client is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * client as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the client using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the rcl client
  ///  * \return rmw client handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_client_t> rcl_client_get_rmw_handle(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_get_rmw_handle(
      client,
    );
  }

  late final _rcl_client_get_rmw_handle_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_client_get_rmw_handle>>(
          'rcl_client_get_rmw_handle');
  late final _dart_rcl_client_get_rmw_handle _rcl_client_get_rmw_handle =
      _rcl_client_get_rmw_handle_ptr
          .asFunction<_dart_rcl_client_get_rmw_handle>();

  /// Check that the client is valid.
  /// /**
  ///  * The bool returned is `false` if client is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] client pointer to the rcl client
  ///  * \return `true` if `client` is valid, otherwise `false`
  ///  */
  bool rcl_client_is_valid(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return _rcl_client_is_valid(
          client,
        ) !=
        0;
  }

  late final _rcl_client_is_valid_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_client_is_valid>>(
          'rcl_client_is_valid');
  late final _dart_rcl_client_is_valid _rcl_client_is_valid =
      _rcl_client_is_valid_ptr.asFunction<_dart_rcl_client_is_valid>();

  /// Initialize a rcl guard_condition.
  /// /**
  ///  * After calling this function on a rcl_guard_condition_t, it can be passed to
  ///  * rcl_wait() and then concurrently it can be triggered to wake-up rcl_wait().
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  *
  ///  * // ... error handling
  ///  * rcl_guard_condition_t guard_condition = rcl_get_zero_initialized_guard_condition();
  ///  * // ... customize guard condition options
  ///  * rcl_ret_t ret = rcl_guard_condition_init(
  ///  *   &guard_condition, context, rcl_guard_condition_get_default_options());
  ///  * // ... error handling, and on shutdown do deinitialization:
  ///  * ret = rcl_guard_condition_fini(&guard_condition);
  ///  * // ... error handling for rcl_guard_condition_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] guard_condition preallocated guard_condition structure
  ///  * \param[in] context the context instance with which the guard condition
  ///  *   should be associated
  ///  * \param[in] options the guard_condition's options
  ///  * \return `RCL_RET_OK` if guard_condition was initialized successfully, or
  ///  * \return `RCL_RET_ALREADY_INIT` if the guard condition is already initialized, or
  ///  * \return `RCL_RET_NOT_INIT` if the given context is invalid, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_guard_condition_init(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<rcl_context_t> context,
    rcl_guard_condition_options_t options,
  ) {
    return _rcl_guard_condition_init(
      guard_condition,
      context,
      options,
    );
  }

  late final _rcl_guard_condition_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_guard_condition_init>>(
          'rcl_guard_condition_init');
  late final _dart_rcl_guard_condition_init _rcl_guard_condition_init =
      _rcl_guard_condition_init_ptr
          .asFunction<_dart_rcl_guard_condition_init>();

  /// Same as rcl_guard_condition_init(), but reusing an existing rmw handle.
  /// /**
  ///  * In addition to the documentation for rcl_guard_condition_init(), the
  ///  * `rmw_guard_condition` parameter must not be `NULL` and must point to a valid
  ///  * rmw guard condition.
  ///  *
  ///  * Also the life time of the rcl guard condition is tied to the life time of
  ///  * the rmw guard condition.
  ///  * So if the rmw guard condition is destroyed before the rcl guard condition,
  ///  * the rcl guard condition becomes invalid.
  ///  *
  ///  * Similarly if the resulting rcl guard condition is fini'ed before the rmw
  ///  * guard condition, then the rmw guard condition is no longer valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] guard_condition preallocated guard_condition structure
  ///  * \param[in] rmw_guard_condition existing rmw guard condition to reuse
  ///  * \param[in] context the context instance with which the rmw guard condition
  ///  *   was initialized with, i.e. the rmw context inside rcl context needs to
  ///  *   match rmw context in rmw guard condition
  ///  * \param[in] options the guard_condition's options
  ///  * \return `RCL_RET_OK` if guard_condition was initialized successfully, or
  ///  * \return `RCL_RET_ALREADY_INIT` if the guard condition is already initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_guard_condition_init_from_rmw(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<rmw_guard_condition_t> rmw_guard_condition,
    ffi.Pointer<rcl_context_t> context,
    rcl_guard_condition_options_t options,
  ) {
    return _rcl_guard_condition_init_from_rmw(
      guard_condition,
      rmw_guard_condition,
      context,
      options,
    );
  }

  late final _rcl_guard_condition_init_from_rmw_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_guard_condition_init_from_rmw>>(
          'rcl_guard_condition_init_from_rmw');
  late final _dart_rcl_guard_condition_init_from_rmw
      _rcl_guard_condition_init_from_rmw =
      _rcl_guard_condition_init_from_rmw_ptr
          .asFunction<_dart_rcl_guard_condition_init_from_rmw>();

  /// Finalize a rcl_guard_condition_t.
  /// /**
  ///  * After calling, calls to rcl_trigger_guard_condition() will fail when using
  ///  * this guard condition.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] specifically not thread-safe with rcl_trigger_guard_condition()</i>
  ///  *
  ///  * \param[inout] guard_condition handle to the guard_condition to be finalized
  ///  * \return `RCL_RET_OK` if guard_condition was finalized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_guard_condition_fini(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return _rcl_guard_condition_fini(
      guard_condition,
    );
  }

  late final _rcl_guard_condition_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_guard_condition_fini>>(
          'rcl_guard_condition_fini');
  late final _dart_rcl_guard_condition_fini _rcl_guard_condition_fini =
      _rcl_guard_condition_fini_ptr
          .asFunction<_dart_rcl_guard_condition_fini>();

  /// Return the default options in a rcl_guard_condition_options_t struct.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - allocator = rcl_get_default_allocator()
  ///  */
  rcl_guard_condition_options_t rcl_guard_condition_get_default_options() {
    return _rcl_guard_condition_get_default_options();
  }

  late final _rcl_guard_condition_get_default_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_guard_condition_get_default_options>>(
          'rcl_guard_condition_get_default_options');
  late final _dart_rcl_guard_condition_get_default_options
      _rcl_guard_condition_get_default_options =
      _rcl_guard_condition_get_default_options_ptr
          .asFunction<_dart_rcl_guard_condition_get_default_options>();

  /// Trigger a rcl guard condition.
  /// /**
  ///  * This function can fail, and return RCL_RET_INVALID_ARGUMENT, if the:
  ///  *   - guard condition is `NULL`
  ///  *   - guard condition is invalid (never called init or called fini)
  ///  *
  ///  * A guard condition can be triggered from any thread.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] it can be called concurrently with itself, even on the same guard condition</i>
  ///  *
  ///  * \param[in] guard_condition handle to the guard_condition to be triggered
  ///  * \return `RCL_RET_OK` if the guard condition was triggered, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_trigger_guard_condition(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return _rcl_trigger_guard_condition(
      guard_condition,
    );
  }

  late final _rcl_trigger_guard_condition_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_trigger_guard_condition>>(
          'rcl_trigger_guard_condition');
  late final _dart_rcl_trigger_guard_condition _rcl_trigger_guard_condition =
      _rcl_trigger_guard_condition_ptr
          .asFunction<_dart_rcl_trigger_guard_condition>();

  /// Return the guard condition options.
  /// /**
  ///  * Returned is a pointer to the internally held rcl_guard_condition_options_t.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - guard_condition is `NULL`
  ///  *   - guard_condition is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned pointer is made invalid if the guard condition is finalized.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] guard_condition pointer to the rcl guard_condition
  ///  * \return rcl guard condition options if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_guard_condition_options_t> rcl_guard_condition_get_options(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return _rcl_guard_condition_get_options(
      guard_condition,
    );
  }

  late final _rcl_guard_condition_get_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_guard_condition_get_options>>(
          'rcl_guard_condition_get_options');
  late final _dart_rcl_guard_condition_get_options
      _rcl_guard_condition_get_options = _rcl_guard_condition_get_options_ptr
          .asFunction<_dart_rcl_guard_condition_get_options>();

  /// Return the rmw guard condition handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - guard_condition is `NULL`
  ///  *   - guard_condition is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned handle is made invalid if the guard condition is finalized or
  ///  * if rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * guard condition as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the guard condition using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] guard_condition pointer to the rcl guard_condition
  ///  * \return rmw guard condition handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_guard_condition_t> rcl_guard_condition_get_rmw_handle(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return _rcl_guard_condition_get_rmw_handle(
      guard_condition,
    );
  }

  late final _rcl_guard_condition_get_rmw_handle_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_guard_condition_get_rmw_handle>>(
          'rcl_guard_condition_get_rmw_handle');
  late final _dart_rcl_guard_condition_get_rmw_handle
      _rcl_guard_condition_get_rmw_handle =
      _rcl_guard_condition_get_rmw_handle_ptr
          .asFunction<_dart_rcl_guard_condition_get_rmw_handle>();

  /// Return a rcl_service_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_service_t before passing to
  ///  * rcl_service_init().
  ///  */
  rcl_service_t rcl_get_zero_initialized_service() {
    return _rcl_get_zero_initialized_service();
  }

  late final _rcl_get_zero_initialized_service_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_service>>(
          'rcl_get_zero_initialized_service');
  late final _dart_rcl_get_zero_initialized_service
      _rcl_get_zero_initialized_service = _rcl_get_zero_initialized_service_ptr
          .asFunction<_dart_rcl_get_zero_initialized_service>();

  /// Initialize a rcl service.
  /// /**
  ///  * After calling this function on a rcl_service_t, it can be used to take
  ///  * requests of the given type to the given topic using rcl_take_request().
  ///  * It can also send a response to a request using rcl_send_response().
  ///  *
  ///  * The given rcl_node_t must be valid and the resulting rcl_service_t is
  ///  * only valid as long as the given rcl_node_t remains valid.
  ///  *
  ///  * The rosidl_service_type_support_t is obtained on a per .srv type basis.
  ///  * When the user defines a ROS service, code is generated which provides the
  ///  * required rosidl_service_type_support_t object.
  ///  * This object can be obtained using a language appropriate mechanism.
  ///  * \todo TODO(wjwwood) write these instructions once and link to it instead
  ///  *
  ///  * For C, a macro can be used (for example `example_interfaces/AddTwoInts`):
  ///  *
  ///  * ```c
  ///  * #include <rosidl_generator_c/service_type_support_struct.h>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  ///  * ```
  ///  *
  ///  * For C++, a template function is used:
  ///  *
  ///  * ```cpp
  ///  * #include <rosidl_generator_cpp/service_type_support.hpp>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  * using rosidl_typesupport_cpp::get_service_type_support_handle;
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();
  ///  * ```
  ///  *
  ///  * The rosidl_service_type_support_t object contains service type specific
  ///  * information used to send or take requests and responses.
  ///  *
  ///  * The topic name must be a c string which follows the topic and service name
  ///  * format rules for unexpanded names, also known as non-fully qualified names:
  ///  *
  ///  * \see rcl_expand_topic_name
  ///  *
  ///  * The options struct allows the user to set the quality of service settings as
  ///  * well as a custom allocator which is used when initializing/finalizing the
  ///  * client to allocate space for incidentals, e.g. the service name string.
  ///  *
  ///  * Expected usage (for C services):
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  * #include <rosidl_generator_c/service_type_support_struct.h>
  ///  * #include <example_interfaces/srv/add_two_ints.h>
  ///  *
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  ///  * // ... error handling
  ///  * const rosidl_service_type_support_t * ts =
  ///  *   ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  ///  * rcl_service_t service = rcl_get_zero_initialized_service();
  ///  * rcl_service_options_t service_ops = rcl_service_get_default_options();
  ///  * ret = rcl_service_init(&service, &node, ts, "add_two_ints", &service_ops);
  ///  * // ... error handling, and on shutdown do finalization:
  ///  * ret = rcl_service_fini(&service, &node);
  ///  * // ... error handling for rcl_service_fini()
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_node_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[out] service preallocated service structure
  ///  * \param[in] node valid rcl node handle
  ///  * \param[in] type_support type support object for the service's type
  ///  * \param[in] service_name the name of the service
  ///  * \param[in] options service options, including quality of service settings
  ///  * \return `RCL_RET_OK` if service was initialized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_SERVICE_NAME_INVALID` if the given service name is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_service_init(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> service_name,
    ffi.Pointer<rcl_service_options_t> options,
  ) {
    return _rcl_service_init(
      service,
      node,
      type_support,
      service_name,
      options,
    );
  }

  late final _rcl_service_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_service_init>>('rcl_service_init');
  late final _dart_rcl_service_init _rcl_service_init =
      _rcl_service_init_ptr.asFunction<_dart_rcl_service_init>();

  /// Finalize a rcl_service_t.
  /// /**
  ///  * After calling, the node will no longer listen for requests for this service.
  ///  * (assuming this is the only service of this type in this node).
  ///  *
  ///  * After calling, calls to rcl_wait(), rcl_take_request(), and
  ///  * rcl_send_response() will fail when using this service.
  ///  * Additionally rcl_wait() will be interrupted if currently blocking.
  ///  * However, the given node handle is still valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] service handle to the service to be deinitialized
  ///  * \param[in] node handle to the node used to create the service
  ///  * \return `RCL_RET_OK` if service was deinitialized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SERVICE_INVALID` if the service is invalid, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_service_fini(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_service_fini(
      service,
      node,
    );
  }

  late final _rcl_service_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_service_fini>>('rcl_service_fini');
  late final _dart_rcl_service_fini _rcl_service_fini =
      _rcl_service_fini_ptr.asFunction<_dart_rcl_service_fini>();

  /// Return the default service options in a rcl_service_options_t.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - qos = rmw_qos_profile_services_default
  ///  * - allocator = rcl_get_default_allocator()
  ///  */
  rcl_service_options_t rcl_service_get_default_options() {
    return _rcl_service_get_default_options();
  }

  late final _rcl_service_get_default_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_service_get_default_options>>(
          'rcl_service_get_default_options');
  late final _dart_rcl_service_get_default_options
      _rcl_service_get_default_options = _rcl_service_get_default_options_ptr
          .asFunction<_dart_rcl_service_get_default_options>();

  /// Take a pending ROS request using a rcl service.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the ros_request
  ///  * argument and the type associate with the service, via the type
  ///  * support, match.
  ///  * Passing a different type to rcl_take produces undefined behavior and cannot
  ///  * be checked by this function and therefore no deliberate error will occur.
  ///  *
  ///  * TODO(jacquelinekay) blocking of take?
  ///  * TODO(jacquelinekay) pre-, during-, and post-conditions for message ownership?
  ///  * TODO(jacquelinekay) is rcl_take_request thread-safe?
  ///  * TODO(jacquelinekay) Should there be an rcl_request_id_t?
  ///  *
  ///  * The ros_request pointer should point to an already allocated ROS request message
  ///  * struct of the correct type, into which the taken ROS request will be copied
  ///  * if one is available.
  ///  * If taken is false after calling, then the ROS request will be unmodified.
  ///  *
  ///  * If allocation is required when taking the request, e.g. if space needs to
  ///  * be allocated for a dynamically sized array in the target message, then the
  ///  * allocator given in the service options is used.
  ///  *
  ///  * request_header is a pointer to pre-allocated a rmw struct containing
  ///  * meta-information about the request (e.g. the sequence number).
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if required when filling the request, avoided for fixed sizes</i>
  ///  *
  ///  * \param[in] service the handle to the service from which to take
  ///  * \param[inout] request_header ptr to the struct holding metadata about the request ID
  ///  * \param[inout] ros_request type-erased ptr to an allocated ROS request message
  ///  * \return `RCL_RET_OK` if the request was taken, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SERVICE_INVALID` if the service is invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_SERVICE_TAKE_FAILED` if take failed but no error occurred
  ///  *         in the middleware, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_take_request(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_request,
  ) {
    return _rcl_take_request(
      service,
      request_header,
      ros_request,
    );
  }

  late final _rcl_take_request_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_take_request>>('rcl_take_request');
  late final _dart_rcl_take_request _rcl_take_request =
      _rcl_take_request_ptr.asFunction<_dart_rcl_take_request>();

  /// Send a ROS response to a client using a service.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the `ros_response`
  ///  * parameter and the type associate with the service (via the type support)
  ///  * match.
  ///  * Passing a different type to send_response produces undefined behavior and
  ///  * cannot be checked by this function and therefore no deliberate error will
  ///  * occur.
  ///  *
  ///  * send_response() is an non-blocking call.
  ///  *
  ///  * The ROS response message given by the `ros_response` void pointer is always
  ///  * owned by the calling code, but should remain constant during
  ///  * rcl_send_response().
  ///  *
  ///  * This function is thread safe so long as access to both the service and the
  ///  * `ros_response` is synchronized.
  ///  * That means that calling rcl_send_response() from multiple threads is
  ///  * allowed, but calling rcl_send_response() at the same time as non-thread safe
  ///  * service functions is not, e.g. calling rcl_send_response() and
  ///  * rcl_service_fini() concurrently is not allowed.
  ///  * Before calling rcl_send_response() the message can change and after calling
  ///  * rcl_send_response() the message can change, but it cannot be changed during
  ///  * the rcl_send_response() call.
  ///  * The same `ros_response`, however, can be passed to multiple calls of
  ///  * rcl_send_response() simultaneously, even if the services differ.
  ///  * The `ros_response` is unmodified by rcl_send_response().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] for unique pairs of services and responses, see above for more</i>
  ///  *
  ///  * \param[in] service handle to the service which will make the response
  ///  * \param[inout] response_header ptr to the struct holding metadata about the request ID
  ///  * \param[in] ros_response type-erased pointer to the ROS response message
  ///  * \return `RCL_RET_OK` if the response was sent successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SERVICE_INVALID` if the service is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_send_response(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rmw_request_id_t> response_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return _rcl_send_response(
      service,
      response_header,
      ros_response,
    );
  }

  late final _rcl_send_response_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_send_response>>('rcl_send_response');
  late final _dart_rcl_send_response _rcl_send_response =
      _rcl_send_response_ptr.asFunction<_dart_rcl_send_response>();

  /// Get the topic name for the service.
  /// /**
  ///  * This function returns the service's internal topic name string.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - service is `NULL`
  ///  *   - service is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned string is only valid as long as the service is valid.
  ///  * The value of the string may change if the topic name changes, and therefore
  ///  * copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service the pointer to the service
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Int8> rcl_service_get_service_name(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_get_service_name(
      service,
    );
  }

  late final _rcl_service_get_service_name_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_service_get_service_name>>(
          'rcl_service_get_service_name');
  late final _dart_rcl_service_get_service_name _rcl_service_get_service_name =
      _rcl_service_get_service_name_ptr
          .asFunction<_dart_rcl_service_get_service_name>();

  /// Return the rcl service options.
  /// /**
  ///  * This function returns the service's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - service is `NULL`
  ///  *   - service is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned struct is only valid as long as the service is valid.
  ///  * The values in the struct may change if the service's options change,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service pointer to the service
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_service_options_t> rcl_service_get_options(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_get_options(
      service,
    );
  }

  late final _rcl_service_get_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_service_get_options>>(
          'rcl_service_get_options');
  late final _dart_rcl_service_get_options _rcl_service_get_options =
      _rcl_service_get_options_ptr.asFunction<_dart_rcl_service_get_options>();

  /// Return the rmw service handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - service is `NULL`
  ///  *   - service is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned handle is made invalid if the service is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * service as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the service using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service pointer to the rcl service
  ///  * \return rmw service handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_service_t> rcl_service_get_rmw_handle(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_get_rmw_handle(
      service,
    );
  }

  late final _rcl_service_get_rmw_handle_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_service_get_rmw_handle>>(
          'rcl_service_get_rmw_handle');
  late final _dart_rcl_service_get_rmw_handle _rcl_service_get_rmw_handle =
      _rcl_service_get_rmw_handle_ptr
          .asFunction<_dart_rcl_service_get_rmw_handle>();

  /// Check that the service is valid.
  /// /**
  ///  * The bool returned is `false` if `service` is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] service pointer to the rcl service
  ///  * \return `true` if `service` is valid, otherwise `false`
  ///  */
  bool rcl_service_is_valid(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return _rcl_service_is_valid(
          service,
        ) !=
        0;
  }

  late final _rcl_service_is_valid_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_service_is_valid>>(
          'rcl_service_is_valid');
  late final _dart_rcl_service_is_valid _rcl_service_is_valid =
      _rcl_service_is_valid_ptr.asFunction<_dart_rcl_service_is_valid>();

  ffi.Pointer<rosidl_message_type_support_t> get_message_typesupport_handle(
    ffi.Pointer<rosidl_message_type_support_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return _get_message_typesupport_handle(
      handle,
      identifier,
    );
  }

  late final _get_message_typesupport_handle_ptr =
      _lookup<ffi.NativeFunction<_c_get_message_typesupport_handle>>(
          'get_message_typesupport_handle');
  late final _dart_get_message_typesupport_handle
      _get_message_typesupport_handle = _get_message_typesupport_handle_ptr
          .asFunction<_dart_get_message_typesupport_handle>();

  ffi.Pointer<rosidl_message_type_support_t>
      get_message_typesupport_handle_function(
    ffi.Pointer<rosidl_message_type_support_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return _get_message_typesupport_handle_function(
      handle,
      identifier,
    );
  }

  late final _get_message_typesupport_handle_function_ptr =
      _lookup<ffi.NativeFunction<_c_get_message_typesupport_handle_function>>(
          'get_message_typesupport_handle_function');
  late final _dart_get_message_typesupport_handle_function
      _get_message_typesupport_handle_function =
      _get_message_typesupport_handle_function_ptr
          .asFunction<_dart_get_message_typesupport_handle_function>();

  /// Return a rcl_subscription_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_subscription_t before passing to
  ///  * rcl_subscription_init().
  ///  */
  rcl_subscription_t rcl_get_zero_initialized_subscription() {
    return _rcl_get_zero_initialized_subscription();
  }

  late final _rcl_get_zero_initialized_subscription_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_subscription>>(
          'rcl_get_zero_initialized_subscription');
  late final _dart_rcl_get_zero_initialized_subscription
      _rcl_get_zero_initialized_subscription =
      _rcl_get_zero_initialized_subscription_ptr
          .asFunction<_dart_rcl_get_zero_initialized_subscription>();

  /// Initialize a ROS subscription.
  /// /**
  ///  * After calling this function on a rcl_subscription_t, it can be used to take
  ///  * messages of the given type to the given topic using rcl_take().
  ///  *
  ///  * The given rcl_node_t must be valid and the resulting rcl_subscription_t is
  ///  * only valid as long as the given rcl_node_t remains valid.
  ///  *
  ///  * The rosidl_message_type_support_t is obtained on a per .msg type basis.
  ///  * When the user defines a ROS message, code is generated which provides the
  ///  * required rosidl_message_type_support_t object.
  ///  * This object can be obtained using a language appropriate mechanism.
  ///  * \todo TODO(wjwwood) write these instructions once and link to it instead
  ///  * For C a macro can be used (for example `std_msgs/String`):
  ///  *
  ///  * ```c
  ///  * #include <rosidl_generator_c/message_type_support_struct.h>
  ///  * #include <std_msgs/msg/string.h>
  ///  * const rosidl_message_type_support_t * string_ts =
  ///  *   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  ///  * ```
  ///  *
  ///  * For C++ a template function is used:
  ///  *
  ///  * ```cpp
  ///  * #include <rosidl_generator_cpp/message_type_support.hpp>
  ///  * #include <std_msgs/msgs/string.hpp>
  ///  * using rosidl_typesupport_cpp::get_message_type_support_handle;
  ///  * const rosidl_message_type_support_t * string_ts =
  ///  *   get_message_type_support_handle<std_msgs::msg::String>();
  ///  * ```
  ///  *
  ///  * The rosidl_message_type_support_t object contains message type specific
  ///  * information used to publish messages.
  ///  *
  ///  * The topic name must be a c string which follows the topic and service name
  ///  * format rules for unexpanded names, also known as non-fully qualified names:
  ///  *
  ///  * \see rcl_expand_topic_name
  ///  *
  ///  * The options struct allows the user to set the quality of service settings as
  ///  * well as a custom allocator which is used when (de)initializing the
  ///  * subscription to allocate space for incidental things, e.g. the topic
  ///  * name string.
  ///  *
  ///  * Expected usage (for C messages):
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  * #include <rosidl_generator_c/message_type_support_struct.h>
  ///  * #include <std_msgs/msg/string.h>
  ///  *
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  ///  * // ... error handling
  ///  * const rosidl_message_type_support_t * ts =
  ///  *   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  ///  * rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();
  ///  * rcl_subscription_options_t subscription_ops = rcl_subscription_get_default_options();
  ///  * ret = rcl_subscription_init(&subscription, &node, ts, "chatter", &subscription_ops);
  ///  * // ... error handling, and when finished deinitialization
  ///  * ret = rcl_subscription_fini(&subscription, &node);
  ///  * // ... error handling for rcl_subscription_fini()
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_node_fini()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[out] subscription preallocated subscription structure
  ///  * \param[in] node valid rcl node handle
  ///  * \param[in] type_support type support object for the topic's type
  ///  * \param[in] topic_name the name of the topic
  ///  * \param[in] options subscription options, including quality of service settings
  ///  * \return `RCL_RET_OK` if subscription was initialized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_TOPIC_NAME_INVALID` if the given topic name is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_subscription_init(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<rcl_subscription_options_t> options,
  ) {
    return _rcl_subscription_init(
      subscription,
      node,
      type_support,
      topic_name,
      options,
    );
  }

  late final _rcl_subscription_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_init>>(
          'rcl_subscription_init');
  late final _dart_rcl_subscription_init _rcl_subscription_init =
      _rcl_subscription_init_ptr.asFunction<_dart_rcl_subscription_init>();

  /// Finalize a rcl_subscription_t.
  /// /**
  ///  * After calling, the node will no longer be subscribed on this topic
  ///  * (assuming this is the only subscription on this topic in this node).
  ///  *
  ///  * After calling, calls to rcl_wait and rcl_take will fail when using this
  ///  * subscription.
  ///  * Additioanlly rcl_wait will be interrupted if currently blocking.
  ///  * However, the given node handle is still valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] subscription handle to the subscription to be deinitialized
  ///  * \param[in] node handle to the node used to create the subscription
  ///  * \return `RCL_RET_OK` if subscription was deinitialized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_subscription_fini(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_subscription_fini(
      subscription,
      node,
    );
  }

  late final _rcl_subscription_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_fini>>(
          'rcl_subscription_fini');
  late final _dart_rcl_subscription_fini _rcl_subscription_fini =
      _rcl_subscription_fini_ptr.asFunction<_dart_rcl_subscription_fini>();

  /// Return the default subscription options in a rcl_subscription_options_t.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - ignore_local_publications = false
  ///  * - qos = rmw_qos_profile_default
  ///  * - allocator = rcl_get_default_allocator()
  ///  */
  rcl_subscription_options_t rcl_subscription_get_default_options() {
    return _rcl_subscription_get_default_options();
  }

  late final _rcl_subscription_get_default_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_get_default_options>>(
          'rcl_subscription_get_default_options');
  late final _dart_rcl_subscription_get_default_options
      _rcl_subscription_get_default_options =
      _rcl_subscription_get_default_options_ptr
          .asFunction<_dart_rcl_subscription_get_default_options>();

  /// Take a ROS message from a topic using a rcl subscription.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the ros_message
  ///  * argument and the type associate with the subscription, via the type
  ///  * support, match.
  ///  * Passing a different type to rcl_take produces undefined behavior and cannot
  ///  * be checked by this function and therefore no deliberate error will occur.
  ///  *
  ///  * TODO(wjwwood) blocking of take?
  ///  * TODO(wjwwood) pre-, during-, and post-conditions for message ownership?
  ///  * TODO(wjwwood) is rcl_take thread-safe?
  ///  * TODO(wjwwood) Should there be an rcl_message_info_t?
  ///  *
  ///  * The ros_message pointer should point to an already allocated ROS message
  ///  * struct of the correct type, into which the taken ROS message will be copied
  ///  * if one is available.
  ///  * If taken is false after calling, then the ROS message will be unmodified.
  ///  *
  ///  * The taken boolean may be false even if a wait set reports that the
  ///  * subscription was ready to be taken from in some cases, e.g. when the
  ///  * state of the subscription changes it may cause the wait set to wake up
  ///  * but subsequent takes to fail to take anything.
  ///  *
  ///  * If allocation is required when taking the message, e.g. if space needs to
  ///  * be allocated for a dynamically sized array in the target message, then the
  ///  * allocator given in the subscription options is used.
  ///  *
  ///  * The rmw message_info struct contains meta information about this particular
  ///  * message instance, like what the GUID of the publisher which published it
  ///  * originally or whether or not the message received from within the same
  ///  * process.
  ///  * The message_info argument should be an already allocated rmw_message_info_t
  ///  * structure.
  ///  * Passing `NULL` for message_info will result in the argument being ignored.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if required when filling the message, avoided for fixed sizes</i>
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take
  ///  * \param[inout] ros_message type-erased ptr to a allocated ROS message
  ///  * \param[out] message_info rmw struct which contains meta-data for the message
  ///  * \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  ///  * \return `RCL_RET_OK` if the message was published, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
  ///  *         occurred in the middleware, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_take(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rcl_take(
      subscription,
      ros_message,
      message_info,
      allocation,
    );
  }

  late final _rcl_take_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_take>>('rcl_take');
  late final _dart_rcl_take _rcl_take =
      _rcl_take_ptr.asFunction<_dart_rcl_take>();

  /// Take a serialized raw message from a topic using a rcl subscription.
  /// /**
  ///  * In contrast to `rcl_take`, this function stores the taken message in
  ///  * its raw binary representation.
  ///  * It is the job of the caller to ensure that the type associate with the subscription
  ///  * matches, and can optionally be deserialized into its ROS message via, the correct
  ///  * type support.
  ///  * If the `serialized_message` parameter contains enough preallocated memory, the incoming
  ///  * message can be taken without any additional memory allocation.
  ///  * If not, the function will dynamically allocate enough memory for the message.
  ///  * Passing a different type to rcl_take produces undefined behavior and cannot
  ///  * be checked by this function and therefore no deliberate error will occur.
  ///  *
  ///  * Apart from the differences above, this function behaves like `rcl_take`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Maybe [1]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] only if storage in the serialized_message is insufficient</i>
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take
  ///  * \param[inout] serialized_message pointer to a (pre-allocated) serialized message.
  ///  * \param[out] message_info rmw struct which contains meta-data for the message
  ///  * \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  ///  * \return `RCL_RET_OK` if the message was published, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
  ///  *         occurred in the middleware, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_take_serialized_message(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rcl_take_serialized_message(
      subscription,
      serialized_message,
      message_info,
      allocation,
    );
  }

  late final _rcl_take_serialized_message_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_take_serialized_message>>(
          'rcl_take_serialized_message');
  late final _dart_rcl_take_serialized_message _rcl_take_serialized_message =
      _rcl_take_serialized_message_ptr
          .asFunction<_dart_rcl_take_serialized_message>();

  /// Take a loaned message from a topic using a rcl subscription.
  /// /**
  ///  * Depending on the middleware, incoming messages can be loaned to the user's callback
  ///  * without further copying.
  ///  * The implicit contract here is that the middleware owns the memory allocated for this message.
  ///  * The user must not destroy the message, but rather has to return it with a call to
  ///  * \sa rcl_return_loaned_message to the middleware.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take
  ///  * \param[inout] loaned_message a pointer to the loaned messages.
  ///  * \param[out] message_info rmw struct which contains meta-data for the message.
  ///  * \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  ///  * \return `RCL_RET_OK` if the loaned message sequence was taken, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
  ///  *         occurred in the middleware, or
  ///  * \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_take_loaned_message(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rcl_take_loaned_message(
      subscription,
      loaned_message,
      message_info,
      allocation,
    );
  }

  late final _rcl_take_loaned_message_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_take_loaned_message>>(
          'rcl_take_loaned_message');
  late final _dart_rcl_take_loaned_message _rcl_take_loaned_message =
      _rcl_take_loaned_message_ptr.asFunction<_dart_rcl_take_loaned_message>();

  /// Return a loaned message from a topic using a rcl subscription.
  /// /**
  ///  * If a loaned message was previously obtained from the middleware with a call to
  ///  * \sa rcl_take_loaned_message, this message has to be returned to indicate to the middleware
  ///  * that the user no longer needs that memory.
  ///  * The user must not delete the message.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription the handle to the subscription from which to take
  ///  * \param[in] loaned_message a pointer to the loaned messages.
  ///  * \return `RCL_RET_OK` if the message was published, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  ///  * \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_return_loaned_message_from_subscription(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return _rcl_return_loaned_message_from_subscription(
      subscription,
      loaned_message,
    );
  }

  late final _rcl_return_loaned_message_from_subscription_ptr = _lookup<
          ffi.NativeFunction<_c_rcl_return_loaned_message_from_subscription>>(
      'rcl_return_loaned_message_from_subscription');
  late final _dart_rcl_return_loaned_message_from_subscription
      _rcl_return_loaned_message_from_subscription =
      _rcl_return_loaned_message_from_subscription_ptr
          .asFunction<_dart_rcl_return_loaned_message_from_subscription>();

  /// Get the topic name for the subscription.
  /// /**
  ///  * This function returns the subscription's internal topic name string.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - subscription is `NULL`
  ///  *   - subscription is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned string is only valid as long as the subscription is valid.
  ///  * The value of the string may change if the topic name changes, and therefore
  ///  * copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription the pointer to the subscription
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Int8> rcl_subscription_get_topic_name(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_get_topic_name(
      subscription,
    );
  }

  late final _rcl_subscription_get_topic_name_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_get_topic_name>>(
          'rcl_subscription_get_topic_name');
  late final _dart_rcl_subscription_get_topic_name
      _rcl_subscription_get_topic_name = _rcl_subscription_get_topic_name_ptr
          .asFunction<_dart_rcl_subscription_get_topic_name>();

  /// Return the rcl subscription options.
  /// /**
  ///  * This function returns the subscription's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - subscription is `NULL`
  ///  *   - subscription is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned struct is only valid as long as the subscription is valid.
  ///  * The values in the struct may change if the subscription's options change,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription pointer to the subscription
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_subscription_options_t> rcl_subscription_get_options(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_get_options(
      subscription,
    );
  }

  late final _rcl_subscription_get_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_get_options>>(
          'rcl_subscription_get_options');
  late final _dart_rcl_subscription_get_options _rcl_subscription_get_options =
      _rcl_subscription_get_options_ptr
          .asFunction<_dart_rcl_subscription_get_options>();

  /// Return the rmw subscription handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - subscription is `NULL`
  ///  *   - subscription is invalid (never called init, called fini, or invalid)
  ///  *
  ///  * The returned handle is made invalid if the subscription is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * subscription as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the subscription using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription pointer to the rcl subscription
  ///  * \return rmw subscription handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_subscription_t> rcl_subscription_get_rmw_handle(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_get_rmw_handle(
      subscription,
    );
  }

  late final _rcl_subscription_get_rmw_handle_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_get_rmw_handle>>(
          'rcl_subscription_get_rmw_handle');
  late final _dart_rcl_subscription_get_rmw_handle
      _rcl_subscription_get_rmw_handle = _rcl_subscription_get_rmw_handle_ptr
          .asFunction<_dart_rcl_subscription_get_rmw_handle>();

  /// Check that the subscription is valid.
  /// /**
  ///  * The bool returned is `false` if `subscription` is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription pointer to the rcl subscription
  ///  * \return `true` if `subscription` is valid, otherwise `false`
  ///  */
  bool rcl_subscription_is_valid(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_is_valid(
          subscription,
        ) !=
        0;
  }

  late final _rcl_subscription_is_valid_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_is_valid>>(
          'rcl_subscription_is_valid');
  late final _dart_rcl_subscription_is_valid _rcl_subscription_is_valid =
      _rcl_subscription_is_valid_ptr
          .asFunction<_dart_rcl_subscription_is_valid>();

  /// Get the number of publishers matched to a subscription.
  /// /**
  ///  * Used to get the internal count of publishers matched to a subscription.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] only if the underlying rmw doesn't make use of this feature </i>
  ///  *
  ///  * \param[in] subscription pointer to the rcl subscription
  ///  * \param[out] publisher_count number of matched publishers
  ///  * \return `RCL_RET_OK` if the count was retrieved, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_subscription_get_publisher_count(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Uint64> publisher_count,
  ) {
    return _rcl_subscription_get_publisher_count(
      subscription,
      publisher_count,
    );
  }

  late final _rcl_subscription_get_publisher_count_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_get_publisher_count>>(
          'rcl_subscription_get_publisher_count');
  late final _dart_rcl_subscription_get_publisher_count
      _rcl_subscription_get_publisher_count =
      _rcl_subscription_get_publisher_count_ptr
          .asFunction<_dart_rcl_subscription_get_publisher_count>();

  /// Get the actual qos settings of the subscription.
  /// /**
  ///  * Used to get the actual qos settings of the subscription.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the subscription, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The returned struct is only valid as long as the rcl_subscription_t is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] subscription pointer to the rcl subscription
  ///  * \return qos struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_qos_profile_t> rcl_subscription_get_actual_qos(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_get_actual_qos(
      subscription,
    );
  }

  late final _rcl_subscription_get_actual_qos_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_get_actual_qos>>(
          'rcl_subscription_get_actual_qos');
  late final _dart_rcl_subscription_get_actual_qos
      _rcl_subscription_get_actual_qos = _rcl_subscription_get_actual_qos_ptr
          .asFunction<_dart_rcl_subscription_get_actual_qos>();

  /// Check if subscription instance can loan messages.
  /// /**
  ///  * Depending on the middleware and the message type, this will return true if the middleware
  ///  * can allocate a ROS message instance.
  ///  */
  bool rcl_subscription_can_loan_messages(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return _rcl_subscription_can_loan_messages(
          subscription,
        ) !=
        0;
  }

  late final _rcl_subscription_can_loan_messages_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_can_loan_messages>>(
          'rcl_subscription_can_loan_messages');
  late final _dart_rcl_subscription_can_loan_messages
      _rcl_subscription_can_loan_messages =
      _rcl_subscription_can_loan_messages_ptr
          .asFunction<_dart_rcl_subscription_can_loan_messages>();

  /// Check if the clock has valid values.
  /// /**
  ///  * This function returns true if the time source appears to be valid.
  ///  * It will check that the type is not uninitialized, and that pointers
  ///  * are not invalid.
  ///  * Note that if data is uninitialized it may give a false positive.
  ///  *
  ///  * \param[in] clock the handle to the clock which is being queried
  ///  * \return true if the source is believed to be valid, otherwise return false.
  ///  */
  bool rcl_clock_valid(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_clock_valid(
          clock,
        ) !=
        0;
  }

  late final _rcl_clock_valid_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_clock_valid>>('rcl_clock_valid');
  late final _dart_rcl_clock_valid _rcl_clock_valid =
      _rcl_clock_valid_ptr.asFunction<_dart_rcl_clock_valid>();

  /// Initialize a clock based on the passed type.
  /// /**
  ///  * This will allocate all necessary internal structures, and initialize variables.
  ///  *
  ///  * \param[in] clock_type the type identifying the time source to provide
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \param[in] allocator The allocator to use for allocations
  ///  * \return `RCL_RET_OK` if the time source was successfully initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_clock_init(
    int clock_type,
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcl_clock_init(
      clock_type,
      clock,
      allocator,
    );
  }

  late final _rcl_clock_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_clock_init>>('rcl_clock_init');
  late final _dart_rcl_clock_init _rcl_clock_init =
      _rcl_clock_init_ptr.asFunction<_dart_rcl_clock_init>();

  /// Finalize a clock.
  /// /**
  ///  * This will deallocate all necessary internal structures, and clean up any variables.
  ///  * It can be combined with any of the init functions.
  ///  *
  ///  * Passing a clock with type RCL_CLOCK_UNINITIALIZED will result in
  ///  * RCL_RET_INVALID_ARGUMENT being returned.
  ///  *
  ///  * \param[in] clock the handle to the clock which is being finalized
  ///  * \return `RCL_RET_OK` if the time source was successfully finalized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_clock_fini(
      clock,
    );
  }

  late final _rcl_clock_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_clock_fini>>('rcl_clock_fini');
  late final _dart_rcl_clock_fini _rcl_clock_fini =
      _rcl_clock_fini_ptr.asFunction<_dart_rcl_clock_fini>();

  /// Initialize a clock as a RCL_ROS_TIME time source.
  /// /**
  ///  * This will allocate all necessary internal structures, and initialize variables.
  ///  * It is specifically setting up a RCL_ROS_TIME time source.
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \param[in] allocator The allocator to use for allocations
  ///  * \return `RCL_RET_OK` if the time source was successfully initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_ros_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcl_ros_clock_init(
      clock,
      allocator,
    );
  }

  late final _rcl_ros_clock_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_ros_clock_init>>('rcl_ros_clock_init');
  late final _dart_rcl_ros_clock_init _rcl_ros_clock_init =
      _rcl_ros_clock_init_ptr.asFunction<_dart_rcl_ros_clock_init>();

  /// Finalize a clock as a `RCL_ROS_TIME` time source.
  /// /**
  ///  * This will deallocate all necessary internal structures, and clean up any variables.
  ///  * It is specifically setting up a `RCL_ROS_TIME` time source. It is expected
  ///  * to be paired with the init fuction.
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \return `RCL_RET_OK` if the time source was successfully finalized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_ros_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_ros_clock_fini(
      clock,
    );
  }

  late final _rcl_ros_clock_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_ros_clock_fini>>('rcl_ros_clock_fini');
  late final _dart_rcl_ros_clock_fini _rcl_ros_clock_fini =
      _rcl_ros_clock_fini_ptr.asFunction<_dart_rcl_ros_clock_fini>();

  /// Initialize a clock as a `RCL_STEADY_TIME` time source.
  /// /**
  ///  * This will allocate all necessary internal structures, and initialize variables.
  ///  * It is specifically setting up a `RCL_STEADY_TIME` time source.
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \param[in] allocator The allocator to use for allocations
  ///  * \return `RCL_RET_OK` if the time source was successfully initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_steady_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcl_steady_clock_init(
      clock,
      allocator,
    );
  }

  late final _rcl_steady_clock_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_steady_clock_init>>(
          'rcl_steady_clock_init');
  late final _dart_rcl_steady_clock_init _rcl_steady_clock_init =
      _rcl_steady_clock_init_ptr.asFunction<_dart_rcl_steady_clock_init>();

  /// Finalize a clock as a `RCL_STEADY_TIME` time source.
  /// /**
  ///  * Finalize the clock as a `RCL_STEADY_TIME` time source.
  ///  *
  ///  * This will deallocate all necessary internal structures, and clean up any variables.
  ///  * It is specifically setting up a steady time source. It is expected to be
  ///  * paired with the init fuction.
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \return `RCL_RET_OK` if the time source was successfully finalized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_steady_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_steady_clock_fini(
      clock,
    );
  }

  late final _rcl_steady_clock_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_steady_clock_fini>>(
          'rcl_steady_clock_fini');
  late final _dart_rcl_steady_clock_fini _rcl_steady_clock_fini =
      _rcl_steady_clock_fini_ptr.asFunction<_dart_rcl_steady_clock_fini>();

  /// Initialize a clock as a `RCL_SYSTEM_TIME` time source.
  /// /**
  ///  * Initialize the clock as a `RCL_SYSTEM_TIME` time source.
  ///  *
  ///  * This will allocate all necessary internal structures, and initialize variables.
  ///  * It is specifically setting up a system time source.
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized
  ///  * \param[in] allocator The allocator to use for allocations
  ///  * \return `RCL_RET_OK` if the time source was successfully initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_system_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcl_system_clock_init(
      clock,
      allocator,
    );
  }

  late final _rcl_system_clock_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_system_clock_init>>(
          'rcl_system_clock_init');
  late final _dart_rcl_system_clock_init _rcl_system_clock_init =
      _rcl_system_clock_init_ptr.asFunction<_dart_rcl_system_clock_init>();

  /// Finalize a clock as a `RCL_SYSTEM_TIME` time source.
  /// /**
  ///  * Finalize the clock as a `RCL_SYSTEM_TIME` time source.
  ///  *
  ///  * This will deallocate all necessary internal structures, and clean up any variables.
  ///  * It is specifically setting up a system time source. It is expected to be paired with
  ///  * the init fuction.
  ///  *
  ///  * \param[in] clock the handle to the clock which is being initialized.
  ///  * \return `RCL_RET_OK` if the time source was successfully finalized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_system_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_system_clock_fini(
      clock,
    );
  }

  late final _rcl_system_clock_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_system_clock_fini>>(
          'rcl_system_clock_fini');
  late final _dart_rcl_system_clock_fini _rcl_system_clock_fini =
      _rcl_system_clock_fini_ptr.asFunction<_dart_rcl_system_clock_fini>();

  /// Compute the difference between two time points
  /// /**
  ///  * This function takes two time points and computes the duration between them.
  ///  * The two time points must be using the same time abstraction, and the
  ///  * resultant duration will also be of the same abstraction.
  ///  *
  ///  * The value will be computed as duration = finish - start. If start is after
  ///  * finish the duration will be negative.
  ///  *
  ///  * \param[in] start The time point for the start of the duration.
  ///  * \param[in] finish The time point for the end of the duration.
  ///  * \param[out] delta The duration between the start and finish.
  ///  * \return `RCL_RET_OK` if the difference was computed successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_difference_times(
    ffi.Pointer<rcl_time_point_t> start,
    ffi.Pointer<rcl_time_point_t> finish,
    ffi.Pointer<rcl_duration_t> delta,
  ) {
    return _rcl_difference_times(
      start,
      finish,
      delta,
    );
  }

  late final _rcl_difference_times_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_difference_times>>(
          'rcl_difference_times');
  late final _dart_rcl_difference_times _rcl_difference_times =
      _rcl_difference_times_ptr.asFunction<_dart_rcl_difference_times>();

  /// Fill the time point value with the current value of the associated clock.
  /// /**
  ///  * This function will populate the data of the time_point_value object with the
  ///  * current value from it's associated time abstraction.
  ///  * \param[in] clock The time source from which to set the value.
  ///  * \param[out] time_point_value The time_point value to populate.
  ///  * \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_clock_get_now(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<ffi.Int64> time_point_value,
  ) {
    return _rcl_clock_get_now(
      clock,
      time_point_value,
    );
  }

  late final _rcl_clock_get_now_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_clock_get_now>>('rcl_clock_get_now');
  late final _dart_rcl_clock_get_now _rcl_clock_get_now =
      _rcl_clock_get_now_ptr.asFunction<_dart_rcl_clock_get_now>();

  /// Enable the ROS time abstraction override.
  /// /**
  ///  * This method will enable the ROS time abstraction override values,
  ///  * such that the time source will report the set value instead of falling
  ///  * back to system time.
  ///  *
  ///  * \param[in] clock The clock to enable.
  ///  * \return `RCL_RET_OK` if the time source was enabled successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_enable_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_enable_ros_time_override(
      clock,
    );
  }

  late final _rcl_enable_ros_time_override_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_enable_ros_time_override>>(
          'rcl_enable_ros_time_override');
  late final _dart_rcl_enable_ros_time_override _rcl_enable_ros_time_override =
      _rcl_enable_ros_time_override_ptr
          .asFunction<_dart_rcl_enable_ros_time_override>();

  /// Disable the ROS time abstraction override.
  /// /**
  ///  * This method will disable the `RCL_ROS_TIME` time abstraction override values,
  ///  * such that the time source will report the system time even if a custom
  ///  * value has been set.
  ///  *
  ///  * \param[in] clock The clock to disable.
  ///  * \return `RCL_RET_OK` if the time source was disabled successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_disable_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return _rcl_disable_ros_time_override(
      clock,
    );
  }

  late final _rcl_disable_ros_time_override_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_disable_ros_time_override>>(
          'rcl_disable_ros_time_override');
  late final _dart_rcl_disable_ros_time_override
      _rcl_disable_ros_time_override = _rcl_disable_ros_time_override_ptr
          .asFunction<_dart_rcl_disable_ros_time_override>();

  /// Check if the `RCL_ROS_TIME` time source has the override enabled.
  /// /**
  ///  * This will populate the is_enabled object to indicate if the
  ///  * time overide is enabled. If it is enabled, the set value will be returned.
  ///  * Otherwise this time source will return the equivalent to system time abstraction.
  ///  *
  ///  * \param[in] clock The clock to query.
  ///  * \param[out] is_enabled Whether the override is enabled..
  ///  * \return `RCL_RET_OK` if the time source was queried successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_is_enabled_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<ffi.Uint8> is_enabled,
  ) {
    return _rcl_is_enabled_ros_time_override(
      clock,
      is_enabled,
    );
  }

  late final _rcl_is_enabled_ros_time_override_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_is_enabled_ros_time_override>>(
          'rcl_is_enabled_ros_time_override');
  late final _dart_rcl_is_enabled_ros_time_override
      _rcl_is_enabled_ros_time_override = _rcl_is_enabled_ros_time_override_ptr
          .asFunction<_dart_rcl_is_enabled_ros_time_override>();

  /// Set the current time for this `RCL_ROS_TIME` time source.
  /// /**
  ///  * This function will update the internal storage for the `RCL_ROS_TIME`
  ///  * time source.
  ///  * If queried and override enabled the time source will return this value,
  ///  * otherwise it will return the system time.
  ///  *
  ///  * \param[in] clock The clock to update.
  ///  * \param[in] time_value The new current time.
  ///  * \return `RCL_RET_OK` if the time source was set successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_set_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
    int time_value,
  ) {
    return _rcl_set_ros_time_override(
      clock,
      time_value,
    );
  }

  late final _rcl_set_ros_time_override_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_set_ros_time_override>>(
          'rcl_set_ros_time_override');
  late final _dart_rcl_set_ros_time_override _rcl_set_ros_time_override =
      _rcl_set_ros_time_override_ptr
          .asFunction<_dart_rcl_set_ros_time_override>();

  /// Add a callback to be called when a time jump exceeds a threshold.
  /// /**
  ///  * The callback is called twice when the threshold is exceeded: once before the clock is
  ///  * updated, and once after.
  ///  * The user_data pointer is passed to the callback as the last argument.
  ///  * A callback and user_data pair must be unique among the callbacks added to a clock.
  ///  *
  ///  * \param[in] clock A clock to add a jump callback to.
  ///  * \param[in] threshold Criteria indicating when to call the callback.
  ///  * \param[in] callback A callback to call.
  ///  * \param[in] user_data A pointer to be passed to the callback.
  ///  * \return `RCL_RET_OK` if the callback was added successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occurs.
  ///  */
  int rcl_clock_add_jump_callback(
    ffi.Pointer<rcl_clock_t> clock,
    rcl_jump_threshold_t threshold,
    ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rcl_clock_add_jump_callback(
      clock,
      threshold,
      callback,
      user_data,
    );
  }

  late final _rcl_clock_add_jump_callback_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_clock_add_jump_callback>>(
          'rcl_clock_add_jump_callback');
  late final _dart_rcl_clock_add_jump_callback _rcl_clock_add_jump_callback =
      _rcl_clock_add_jump_callback_ptr
          .asFunction<_dart_rcl_clock_add_jump_callback>();

  /// Remove a previously added time jump callback.
  /// /**
  ///  * \param[in] clock The clock to remove a jump callback from.
  ///  * \param[in] threshold Criteria indicating when to call callback.
  ///  * \param[in] callback The callback to call.
  ///  * \param[in] user_data A pointer to be passed to the callback.
  ///  * \return `RCL_RET_OK` if the callback was added successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` the callback was not found or an unspecified error occurs.
  ///  */
  int rcl_clock_remove_jump_callback(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return _rcl_clock_remove_jump_callback(
      clock,
      callback,
      user_data,
    );
  }

  late final _rcl_clock_remove_jump_callback_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_clock_remove_jump_callback>>(
          'rcl_clock_remove_jump_callback');
  late final _dart_rcl_clock_remove_jump_callback
      _rcl_clock_remove_jump_callback = _rcl_clock_remove_jump_callback_ptr
          .asFunction<_dart_rcl_clock_remove_jump_callback>();

  ffi.Pointer<rosidl_message_bounds_t> get_message_bounds_handle(
    ffi.Pointer<rosidl_message_bounds_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return _get_message_bounds_handle(
      handle,
      identifier,
    );
  }

  late final _get_message_bounds_handle_ptr =
      _lookup<ffi.NativeFunction<_c_get_message_bounds_handle>>(
          'get_message_bounds_handle');
  late final _dart_get_message_bounds_handle _get_message_bounds_handle =
      _get_message_bounds_handle_ptr
          .asFunction<_dart_get_message_bounds_handle>();

  ffi.Pointer<rosidl_message_bounds_t> get_message_bounds_handle_function(
    ffi.Pointer<rosidl_message_bounds_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return _get_message_bounds_handle_function(
      handle,
      identifier,
    );
  }

  late final _get_message_bounds_handle_function_ptr =
      _lookup<ffi.NativeFunction<_c_get_message_bounds_handle_function>>(
          'get_message_bounds_handle_function');
  late final _dart_get_message_bounds_handle_function
      _get_message_bounds_handle_function =
      _get_message_bounds_handle_function_ptr
          .asFunction<_dart_get_message_bounds_handle_function>();

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_sensor_data =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_sensor_data');

  rmw_qos_profile_t get rmw_qos_profile_sensor_data =>
      _rmw_qos_profile_sensor_data.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_parameters =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_parameters');

  rmw_qos_profile_t get rmw_qos_profile_parameters =>
      _rmw_qos_profile_parameters.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_default =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_default');

  rmw_qos_profile_t get rmw_qos_profile_default => _rmw_qos_profile_default.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_services_default =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_services_default');

  rmw_qos_profile_t get rmw_qos_profile_services_default =>
      _rmw_qos_profile_services_default.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_parameter_events =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_parameter_events');

  rmw_qos_profile_t get rmw_qos_profile_parameter_events =>
      _rmw_qos_profile_parameter_events.ref;

  late final ffi.Pointer<rmw_qos_profile_t> _rmw_qos_profile_system_default =
      _lookup<rmw_qos_profile_t>('rmw_qos_profile_system_default');

  rmw_qos_profile_t get rmw_qos_profile_system_default =>
      _rmw_qos_profile_system_default.ref;

  /// Return a rmw_subscription_options_t initialized with default values.
  rmw_subscription_options_t rmw_get_default_subscription_options() {
    return _rmw_get_default_subscription_options();
  }

  late final _rmw_get_default_subscription_options_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_default_subscription_options>>(
          'rmw_get_default_subscription_options');
  late final _dart_rmw_get_default_subscription_options
      _rmw_get_default_subscription_options =
      _rmw_get_default_subscription_options_ptr
          .asFunction<_dart_rmw_get_default_subscription_options>();

  ffi.Pointer<ffi.Int8> rmw_get_implementation_identifier() {
    return _rmw_get_implementation_identifier();
  }

  late final _rmw_get_implementation_identifier_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_implementation_identifier>>(
          'rmw_get_implementation_identifier');
  late final _dart_rmw_get_implementation_identifier
      _rmw_get_implementation_identifier =
      _rmw_get_implementation_identifier_ptr
          .asFunction<_dart_rmw_get_implementation_identifier>();

  /// Get the unique serialization format for this middleware.
  /// /**
  ///  * Return the format in which binary data is serialized.
  ///  * One middleware can only have one encoding.
  ///  * In contrast to the implementation identifier, the serialization format can be equal between
  ///  * multiple RMW implementations.
  ///  * This means, that the same binary messages can be deserialized by RMW implementations with the
  ///  * same format.
  ///  * \sa rmw_serialize
  ///  * \sa rmw_deserialize
  ///  * \return serialization format
  ///  */
  ffi.Pointer<ffi.Int8> rmw_get_serialization_format() {
    return _rmw_get_serialization_format();
  }

  late final _rmw_get_serialization_format_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_serialization_format>>(
          'rmw_get_serialization_format');
  late final _dart_rmw_get_serialization_format _rmw_get_serialization_format =
      _rmw_get_serialization_format_ptr
          .asFunction<_dart_rmw_get_serialization_format>();

  /// TODO(wjwwood): refactor this API to return a return code when updated to use an allocator
  /// Create a node and return a handle to that node.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - context, name, namespace_, or security_options is `NULL`
  ///  *   - context, security_options is invalid
  ///  *   - memory allocation fails during node creation
  ///  *   - an unspecified error occurs
  ///  *
  ///  * The context must be non-null and valid, i.e. it has been initialized
  ///  * by `rmw_init()` and has not been finalized by `rmw_shutdown()`.
  ///  *
  ///  * The name and namespace_ should be valid node name and namespace,
  ///  * and this should be asserted by the caller (e.g. `rcl`).
  ///  *
  ///  * The domain ID should be used to physically separate nodes at the
  ///  * communication graph level by the middleware.
  ///  * For RTPS/DDS this maps naturally to their concept of domain id.
  ///  *
  ///  * The security options should always be non-null and encapsulate the
  ///  * essential security configurations for the node and its entities.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No [1]
  ///  * Lock-Free          | No [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] context init context that this node should be associated with
  ///  * \param[in] name the node name
  ///  * \param[in] namespace_ the node namespace
  ///  * \param[in] domain_id the id of the domain that the node should join
  ///  * \param[in] security_options the security configurations for the node
  ///  * \param[in] localhost_only whenever to use loopback only for communication or default
  ///  * network interfaces.
  ///  * \return rmw node handle or `NULL` if there was an error
  ///  */
  ffi.Pointer<rmw_node_t> rmw_create_node(
    ffi.Pointer<rmw_context_t> context,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> namespace_,
    int domain_id,
    ffi.Pointer<rmw_node_security_options_t> security_options,
    bool localhost_only,
  ) {
    return _rmw_create_node(
      context,
      name,
      namespace_,
      domain_id,
      security_options,
      localhost_only ? 1 : 0,
    );
  }

  late final _rmw_create_node_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_create_node>>('rmw_create_node');
  late final _dart_rmw_create_node _rmw_create_node =
      _rmw_create_node_ptr.asFunction<_dart_rmw_create_node>();

  /// Finalize a given node handle, reclaim the resources, and deallocate the node handle.
  /// /**
  ///  * \param node the node handle to be destroyed
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if node is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_destroy_node(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return _rmw_destroy_node(
      node,
    );
  }

  late final _rmw_destroy_node_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_destroy_node>>('rmw_destroy_node');
  late final _dart_rmw_destroy_node _rmw_destroy_node =
      _rmw_destroy_node_ptr.asFunction<_dart_rmw_destroy_node>();

  /// Manually assert that this node is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE)
  /// /**
  ///  * If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE, the creator of
  ///  * this node may manually call `assert_liveliness` at some point in time to signal to the rest
  ///  * of the system that this Node is still alive.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node handle to the node that needs liveliness to be asserted
  ///  * \return `RMW_RET_OK` if the liveliness assertion was completed successfully, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the rmw implementation does not support asserting liveliness.
  ///  */
  int rmw_node_assert_liveliness(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return _rmw_node_assert_liveliness(
      node,
    );
  }

  late final _rmw_node_assert_liveliness_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_node_assert_liveliness>>(
          'rmw_node_assert_liveliness');
  late final _dart_rmw_node_assert_liveliness _rmw_node_assert_liveliness =
      _rmw_node_assert_liveliness_ptr
          .asFunction<_dart_rmw_node_assert_liveliness>();

  /// Return a guard condition which is triggered when the ROS graph changes.
  /// /**
  ///  * The handle returned is a pointer to an internally held rmw guard condition.
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - node is `NULL`
  ///  *   - node is invalid
  ///  *
  ///  * The returned handle is made invalid if the node is destroyed or if
  ///  * rmw_shutdown() is called.
  ///  *
  ///  * The guard condition will be triggered anytime a change to the ROS graph
  ///  * occurs.
  ///  * A ROS graph change includes things like (but not limited to) a new publisher
  ///  * advertises, a new subscription is created, a new service becomes available,
  ///  * a subscription is canceled, etc.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] node pointer to the rmw node
  ///  * \return rmw guard condition handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_guard_condition_t> rmw_node_get_graph_guard_condition(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return _rmw_node_get_graph_guard_condition(
      node,
    );
  }

  late final _rmw_node_get_graph_guard_condition_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_node_get_graph_guard_condition>>(
          'rmw_node_get_graph_guard_condition');
  late final _dart_rmw_node_get_graph_guard_condition
      _rmw_node_get_graph_guard_condition =
      _rmw_node_get_graph_guard_condition_ptr
          .asFunction<_dart_rmw_node_get_graph_guard_condition>();

  /// Initialize a publisher allocation to be used with later publications.
  /// /**
  ///  * This creates an allocation object that can be used in conjunction with
  ///  * the rmw_publish method to perform more carefully control memory allocations.
  ///  *
  ///  * This will allow the middleware to preallocate the correct amount of memory
  ///  * for a given message type and message bounds.
  ///  * As allocation is performed in this method, it will not be necessary to allocate
  ///  * in the `rmw_publish` method.
  ///  *
  ///  * \param[in] type_support Type support of the message to be preallocated.
  ///  * \param[in] message_bounds Bounds structure of the message to be preallocated.
  ///  * \param[out] allocation Allocation structure to be passed to `rmw_publish`.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_init_publisher_allocation(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_message_bounds_t> message_bounds,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_init_publisher_allocation(
      type_support,
      message_bounds,
      allocation,
    );
  }

  late final _rmw_init_publisher_allocation_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_init_publisher_allocation>>(
          'rmw_init_publisher_allocation');
  late final _dart_rmw_init_publisher_allocation
      _rmw_init_publisher_allocation = _rmw_init_publisher_allocation_ptr
          .asFunction<_dart_rmw_init_publisher_allocation>();

  /// Destroy a publisher allocation object.
  /// /**
  ///  * This deallocates any memory allocated by `rmw_init_publisher_allocation`.
  ///  *
  ///  * \param[in] allocation Allocation object to be destroyed.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_fini_publisher_allocation(
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_fini_publisher_allocation(
      allocation,
    );
  }

  late final _rmw_fini_publisher_allocation_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_fini_publisher_allocation>>(
          'rmw_fini_publisher_allocation');
  late final _dart_rmw_fini_publisher_allocation
      _rmw_fini_publisher_allocation = _rmw_fini_publisher_allocation_ptr
          .asFunction<_dart_rmw_fini_publisher_allocation>();

  /// Return a rmw_publisher_options_t initialized with default values.
  rmw_publisher_options_t rmw_get_default_publisher_options() {
    return _rmw_get_default_publisher_options();
  }

  late final _rmw_get_default_publisher_options_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_default_publisher_options>>(
          'rmw_get_default_publisher_options');
  late final _dart_rmw_get_default_publisher_options
      _rmw_get_default_publisher_options =
      _rmw_get_default_publisher_options_ptr
          .asFunction<_dart_rmw_get_default_publisher_options>();

  /// Create and return an rmw publisher.
  /// /**
  ///  * \TODO(wjwwood): add detailed documentation, adding a not about one of the
  ///  *   arguments for now.
  ///  *
  ///  * The argument `publisher_options` must not be nullptr.
  ///  *
  ///  * \param[in] publisher_options options for configuring the publisher
  ///  */
  ffi.Pointer<rmw_publisher_t> rmw_create_publisher(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<rmw_qos_profile_t> qos_policies,
    ffi.Pointer<rmw_publisher_options_t> publisher_options,
  ) {
    return _rmw_create_publisher(
      node,
      type_support,
      topic_name,
      qos_policies,
      publisher_options,
    );
  }

  late final _rmw_create_publisher_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_create_publisher>>(
          'rmw_create_publisher');
  late final _dart_rmw_create_publisher _rmw_create_publisher =
      _rmw_create_publisher_ptr.asFunction<_dart_rmw_create_publisher>();

  int rmw_destroy_publisher(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_publisher_t> publisher,
  ) {
    return _rmw_destroy_publisher(
      node,
      publisher,
    );
  }

  late final _rmw_destroy_publisher_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_destroy_publisher>>(
          'rmw_destroy_publisher');
  late final _dart_rmw_destroy_publisher _rmw_destroy_publisher =
      _rmw_destroy_publisher_ptr.asFunction<_dart_rmw_destroy_publisher>();

  /// Borrow a loaned message.
  /// /**
  ///  * The memory allocated for the ros message belongs to the middleware and must not be deallocated.
  ///  * A call to \sa rmw_publish_loned_message as well as \sa rmw_return_loaned_message_from_publisher`
  ///  * will return ownership of the loaned message back to the middleware.
  ///  *
  ///  * In order to react to failures, the ros message is passed by pointer as an output parameter.
  ///  * Therefore, the pointer to the ros message has to be `null` and not previously allocated or
  ///  * else that memory is lost.
  ///  *
  ///  * \param[in] publisher Publisher to which the allocated message is associated.
  ///  * \param[in] type_support Typesupport to which the internal ros message is allocated.
  ///  * \param[out] ros_message The pointer to be filled with a valid ros message by the middleware.
  ///  * \return RMW_RET_OK if the ros message was correctly initialized, or
  ///  * \return RMW_RET_INVALID_ARGUMENT if an argument other than the ros message is null, or
  ///  * \return RMW_RET_BAD_ALLOC if the ros message could not be correctly created, or
  ///  * \return RMW_RET_ERROR if an unexpected error occured.
  ///  */
  int rmw_borrow_loaned_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
  ) {
    return _rmw_borrow_loaned_message(
      publisher,
      type_support,
      ros_message,
    );
  }

  late final _rmw_borrow_loaned_message_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_borrow_loaned_message>>(
          'rmw_borrow_loaned_message');
  late final _dart_rmw_borrow_loaned_message _rmw_borrow_loaned_message =
      _rmw_borrow_loaned_message_ptr
          .asFunction<_dart_rmw_borrow_loaned_message>();

  /// Return a loaned message previously borrow from a publisher.
  /// /**
  ///  * The ownership of the passed in ros message will be transferred back to the middleware.
  ///  * The middleware might deallocate and destroy the message so that the pointer is no longer
  ///  * guaranteed to be valid after this call.
  ///  *
  ///  * \param[in] publisher Publisher to which the loaned message is associated.
  ///  * \param[in] loaned_message Loaned message to be returned.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs and no message can be initialized.
  ///  */
  int rmw_return_loaned_message_from_publisher(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return _rmw_return_loaned_message_from_publisher(
      publisher,
      loaned_message,
    );
  }

  late final _rmw_return_loaned_message_from_publisher_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_return_loaned_message_from_publisher>>(
          'rmw_return_loaned_message_from_publisher');
  late final _dart_rmw_return_loaned_message_from_publisher
      _rmw_return_loaned_message_from_publisher =
      _rmw_return_loaned_message_from_publisher_ptr
          .asFunction<_dart_rmw_return_loaned_message_from_publisher>();

  /// Publish a given ros_message
  /// /**
  ///  * Publish a given ROS message via a publisher.
  ///  *
  ///  * \param[in] publisher Publisher to be used to send message.
  ///  * \param[in] ros_message Message to be sent.
  ///  * \param[in] allocation Specify preallocated memory to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if publisher or ros_message is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publish(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_publish(
      publisher,
      ros_message,
      allocation,
    );
  }

  late final _rmw_publish_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_publish>>('rmw_publish');
  late final _dart_rmw_publish _rmw_publish =
      _rmw_publish_ptr.asFunction<_dart_rmw_publish>();

  /// Publish a loaned ros_message.
  /// /**
  ///  * Publish a loaned ROS message via a publisher and return ownership of the loaned message
  ///  * back to the middleware.
  ///  *
  ///  * In contrast to \sa `rmw_publish` the ownership of the ros message is being transferred to the
  ///  * middleware which might deallocate the memory for it.
  ///  * Similar to \sa `rmw_return_loaned_message_from_publisher` the passed in ros message might
  ///  * not be valid after this call and thus should only be called with messages previously loaned with
  ///  * a call to \sa `rmw_borrow_loaned_message`.
  ///  *
  ///  * \param[in] publisher Publisher to be used to send message.
  ///  * \param[in] ros_message Message to be sent.
  ///  * \param[in] allocation Specify preallocated memory to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if publisher or ros_message is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publish_loaned_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_publish_loaned_message(
      publisher,
      ros_message,
      allocation,
    );
  }

  late final _rmw_publish_loaned_message_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_publish_loaned_message>>(
          'rmw_publish_loaned_message');
  late final _dart_rmw_publish_loaned_message _rmw_publish_loaned_message =
      _rmw_publish_loaned_message_ptr
          .asFunction<_dart_rmw_publish_loaned_message>();

  /// Retrieve the number of matched subscriptions to a publisher.
  /// /**
  ///  * Query the underlying middleware to determine how many subscriptions are
  ///  * matched to a given publisher.
  ///  *
  ///  * \param[in] publisher the publisher object to inspect
  ///  * \param[out] subscription_count the number of subscriptions matched
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publisher_count_matched_subscriptions(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Uint64> subscription_count,
  ) {
    return _rmw_publisher_count_matched_subscriptions(
      publisher,
      subscription_count,
    );
  }

  late final _rmw_publisher_count_matched_subscriptions_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_publisher_count_matched_subscriptions>>(
          'rmw_publisher_count_matched_subscriptions');
  late final _dart_rmw_publisher_count_matched_subscriptions
      _rmw_publisher_count_matched_subscriptions =
      _rmw_publisher_count_matched_subscriptions_ptr
          .asFunction<_dart_rmw_publisher_count_matched_subscriptions>();

  /// Retrieve the actual qos settings of the publisher.
  /// /**
  ///  * Query the underlying middleware to determine the qos settings
  ///  * of the publisher.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the publisher, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The value of avoid_ros_namespace_conventions field is not resolved
  ///  * with this function. The rcl function rcl_publisher_get_actual_qos
  ///  * resolves it.
  ///  *
  ///  * \param[in] publisher the publisher object to inspect
  ///  * \param[out] qos the actual qos settings
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publisher_get_actual_qos(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return _rmw_publisher_get_actual_qos(
      publisher,
      qos,
    );
  }

  late final _rmw_publisher_get_actual_qos_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_publisher_get_actual_qos>>(
          'rmw_publisher_get_actual_qos');
  late final _dart_rmw_publisher_get_actual_qos _rmw_publisher_get_actual_qos =
      _rmw_publisher_get_actual_qos_ptr
          .asFunction<_dart_rmw_publisher_get_actual_qos>();

  /// Publish an already serialized message.
  /// /**
  ///  * The publisher must already be registered with the correct message type
  ///  * support so that it can send serialized data corresponding to that type.
  ///  * This function sends the serialized byte stream directly over the wire without
  ///  * having to serialize the message first.
  ///  * A ROS message can be serialized manually using the rmw_serialize() function.
  ///  *
  ///  * \param[in] publisher The publisher object registered to send the message.
  ///  * \param[in] serialized_message The serialized message holding the byte stream.
  ///  * \param[in] allocation Specify preallocated memory to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_publish_serialized_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rmw_publish_serialized_message(
      publisher,
      serialized_message,
      allocation,
    );
  }

  late final _rmw_publish_serialized_message_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_publish_serialized_message>>(
          'rmw_publish_serialized_message');
  late final _dart_rmw_publish_serialized_message
      _rmw_publish_serialized_message = _rmw_publish_serialized_message_ptr
          .asFunction<_dart_rmw_publish_serialized_message>();

  /// Compute the size of a serialized message.
  /// /**
  ///  * Given a message definition and bounds, compute the serialized size.
  ///  *
  ///  * \param[in] type_support The type support of the message to compute.
  ///  * \param[in] bounds Artifical bounds to use on unbounded fields.
  ///  * \param[out] size The computed size of the serialized message.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_get_serialized_message_size(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_message_bounds_t> message_bounds,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return _rmw_get_serialized_message_size(
      type_support,
      message_bounds,
      size,
    );
  }

  late final _rmw_get_serialized_message_size_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_serialized_message_size>>(
          'rmw_get_serialized_message_size');
  late final _dart_rmw_get_serialized_message_size
      _rmw_get_serialized_message_size = _rmw_get_serialized_message_size_ptr
          .asFunction<_dart_rmw_get_serialized_message_size>();

  /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
  /// /**
  ///  * If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
  ///  * this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
  ///  * of the system that this Node is still alive.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher handle to the publisher that needs liveliness to be asserted
  ///  * \return `RMW_RET_OK` if the liveliness assertion was completed successfully, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs, or
  ///  * \return `RMW_RET_UNSUPPORTED` if the rmw implementation does not support asserting liveliness.
  ///  */
  int rmw_publisher_assert_liveliness(
    ffi.Pointer<rmw_publisher_t> publisher,
  ) {
    return _rmw_publisher_assert_liveliness(
      publisher,
    );
  }

  late final _rmw_publisher_assert_liveliness_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_publisher_assert_liveliness>>(
          'rmw_publisher_assert_liveliness');
  late final _dart_rmw_publisher_assert_liveliness
      _rmw_publisher_assert_liveliness = _rmw_publisher_assert_liveliness_ptr
          .asFunction<_dart_rmw_publisher_assert_liveliness>();

  /// Serialize a ROS message into a rmw_serialized_message_t.
  /// /**
  ///  * The ROS message is serialized into a byte stream contained within the
  ///  * rmw_serialized_message_t structure.
  ///  * The serialization format depends on the underlying middleware.
  ///  *
  ///  * \param ros_message the typed ROS message
  ///  * \param type_support the typesupport for the ROS message
  ///  * \param serialized_message the destination for the serialize ROS message
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_serialize(
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ) {
    return _rmw_serialize(
      ros_message,
      type_support,
      serialized_message,
    );
  }

  late final _rmw_serialize_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_serialize>>('rmw_serialize');
  late final _dart_rmw_serialize _rmw_serialize =
      _rmw_serialize_ptr.asFunction<_dart_rmw_serialize>();

  /// Deserialize a ROS message.
  /// /**
  ///  * The given rmw_serialized_message_t's internal byte stream buffer is deserialized
  ///  * into the given ROS message.
  ///  * The ROS message must already be allocated and initialized, and must match
  ///  * the given typesupport structure.
  ///  * The serialization format expected in the rmw_serialized_message_t depends on the
  ///  * underlying middleware.
  ///  *
  ///  * \param serialized_message the serialized message holding the byte stream
  ///  * \param type_support the typesupport for the typed ros message
  ///  * \param ros_message destination for the deserialized ROS message
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_deserialize(
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Void> ros_message,
  ) {
    return _rmw_deserialize(
      serialized_message,
      type_support,
      ros_message,
    );
  }

  late final _rmw_deserialize_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_deserialize>>('rmw_deserialize');
  late final _dart_rmw_deserialize _rmw_deserialize =
      _rmw_deserialize_ptr.asFunction<_dart_rmw_deserialize>();

  /// Initialize a subscription allocation to be used with later `take`s.
  /// /**
  ///  * This creates an allocation object that can be used in conjunction with
  ///  * the rmw_take method to perform more carefully control memory allocations.
  ///  *
  ///  * This will allow the middleware to preallocate the correct amount of memory
  ///  * for a given message type and message bounds.
  ///  * As allocation is performed in this method, it will not be necessary to allocate
  ///  * in the `rmw_take` method.
  ///  *
  ///  * \param[in] type_support Type support of the message to be preallocated.
  ///  * \param[in] message_bounds Bounds structure of the message to be preallocated.
  ///  * \param[out] allocation Allocation structure to be passed to `rmw_take`.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_init_subscription_allocation(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_message_bounds_t> message_bounds,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_init_subscription_allocation(
      type_support,
      message_bounds,
      allocation,
    );
  }

  late final _rmw_init_subscription_allocation_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_init_subscription_allocation>>(
          'rmw_init_subscription_allocation');
  late final _dart_rmw_init_subscription_allocation
      _rmw_init_subscription_allocation = _rmw_init_subscription_allocation_ptr
          .asFunction<_dart_rmw_init_subscription_allocation>();

  /// Destroy a publisher allocation object.
  /// /**
  ///  * This deallocates memory allocated by `rmw_init_subscription_allocation`.
  ///  *
  ///  * \param[in] allocation Allocation object to be destroyed.
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_fini_subscription_allocation(
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_fini_subscription_allocation(
      allocation,
    );
  }

  late final _rmw_fini_subscription_allocation_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_fini_subscription_allocation>>(
          'rmw_fini_subscription_allocation');
  late final _dart_rmw_fini_subscription_allocation
      _rmw_fini_subscription_allocation = _rmw_fini_subscription_allocation_ptr
          .asFunction<_dart_rmw_fini_subscription_allocation>();

  /// Create and return an rmw subscription.
  /// /**
  ///  * \TODO(wjwwood): add detailed documentation, adding a not about one of the
  ///  *   arguments for now.
  ///  *
  ///  * The argument `subscription_options` must not be nullptr.
  ///  *
  ///  * \param[in] subscription_options options for configuring the subscription
  ///  */
  ffi.Pointer<rmw_subscription_t> rmw_create_subscription(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<rmw_qos_profile_t> qos_policies,
    ffi.Pointer<rmw_subscription_options_t> subscription_options,
  ) {
    return _rmw_create_subscription(
      node,
      type_support,
      topic_name,
      qos_policies,
      subscription_options,
    );
  }

  late final _rmw_create_subscription_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_create_subscription>>(
          'rmw_create_subscription');
  late final _dart_rmw_create_subscription _rmw_create_subscription =
      _rmw_create_subscription_ptr.asFunction<_dart_rmw_create_subscription>();

  int rmw_destroy_subscription(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_subscription_t> subscription,
  ) {
    return _rmw_destroy_subscription(
      node,
      subscription,
    );
  }

  late final _rmw_destroy_subscription_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_destroy_subscription>>(
          'rmw_destroy_subscription');
  late final _dart_rmw_destroy_subscription _rmw_destroy_subscription =
      _rmw_destroy_subscription_ptr
          .asFunction<_dart_rmw_destroy_subscription>();

  /// Retrieve the number of matched publishers to a subscription.
  /// /**
  ///  * Query the underlying middleware to determine how many publishers are
  ///  * matched to a given subscription.
  ///  *
  ///  * \param[in] subscription the subscription object to inspect
  ///  * \param[out] publisher_count the number of publishers matched
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_subscription_count_matched_publishers(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Uint64> publisher_count,
  ) {
    return _rmw_subscription_count_matched_publishers(
      subscription,
      publisher_count,
    );
  }

  late final _rmw_subscription_count_matched_publishers_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_subscription_count_matched_publishers>>(
          'rmw_subscription_count_matched_publishers');
  late final _dart_rmw_subscription_count_matched_publishers
      _rmw_subscription_count_matched_publishers =
      _rmw_subscription_count_matched_publishers_ptr
          .asFunction<_dart_rmw_subscription_count_matched_publishers>();

  /// Retrieve the actual qos settings of the subscription.
  /// /**
  ///  * Query the underlying middleware to determine the qos settings
  ///  * of the subscription.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the subscription, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The value of avoid_ros_namespace_conventions field is not resolved
  ///  * with this function. The rcl function rcl_subscription_get_actual_qos
  ///  * resolves it.
  ///  *
  ///  * \param[in] subscription the subscription object to inspect
  ///  * \param[out] qos the actual qos settings
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_subscription_get_actual_qos(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return _rmw_subscription_get_actual_qos(
      subscription,
      qos,
    );
  }

  late final _rmw_subscription_get_actual_qos_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_subscription_get_actual_qos>>(
          'rmw_subscription_get_actual_qos');
  late final _dart_rmw_subscription_get_actual_qos
      _rmw_subscription_get_actual_qos = _rmw_subscription_get_actual_qos_ptr
          .asFunction<_dart_rmw_subscription_get_actual_qos>();

  /// Take an incoming message from a subscription.
  /// /**
  ///  * Take an incoming ROS message from a given subscription.
  ///  *
  ///  * \param[in] subscription The subscription object to take from.
  ///  * \param[out] ros_message The ROS message data on success.
  ///  * \param[out] taken Boolean flag indicating if a message was taken or not.
  ///  * \param[in] allocation Preallocated buffer to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take(
      subscription,
      ros_message,
      taken,
      allocation,
    );
  }

  late final _rmw_take_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_take>>('rmw_take');
  late final _dart_rmw_take _rmw_take =
      _rmw_take_ptr.asFunction<_dart_rmw_take>();

  /// Take an incoming message from a subscription with additional metadata.
  /// /**
  ///  * Take an incoming ROS message from a given subscription.
  ///  *
  ///  * \param[in] subscription The subscription object to take from.
  ///  * \param[out] ros_message The ROS message data on success.
  ///  * \param[out] taken Boolean flag indicating if a message was taken or not.
  ///  * \param[out] message_info Additional message metadata.
  ///  * \param[in] allocation Preallocated buffer to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_with_info(
      subscription,
      ros_message,
      taken,
      message_info,
      allocation,
    );
  }

  late final _rmw_take_with_info_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_take_with_info>>('rmw_take_with_info');
  late final _dart_rmw_take_with_info _rmw_take_with_info =
      _rmw_take_with_info_ptr.asFunction<_dart_rmw_take_with_info>();

  /// Take a message without deserializing it.
  /// /**
  ///  * The message is taken in its serialized form. In contrast to rmw_take, the message
  ///  * is not deserialized in its ROS type but rather returned as a byte stream.
  ///  * The subscriber has to be registered for a specific type. But instead of receiving
  ///  * the message as its corresponding message type, it is taken as a byte stream.
  ///  * If needed, this byte stream can then be deserialized in a ROS message with a call to
  ///  * rmw_deserialize.
  ///  *
  ///  * \param[in] subscription Subscription object to take from.
  ///  * \param[out] serialized_message The destination in which to store the serialized message.
  ///  * \param[out] taken Boolean flag indicating if a message was taken or not.
  ///  * \param[in] allocation Preallocated buffer to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_serialized_message(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_serialized_message(
      subscription,
      serialized_message,
      taken,
      allocation,
    );
  }

  late final _rmw_take_serialized_message_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_take_serialized_message>>(
          'rmw_take_serialized_message');
  late final _dart_rmw_take_serialized_message _rmw_take_serialized_message =
      _rmw_take_serialized_message_ptr
          .asFunction<_dart_rmw_take_serialized_message>();

  /// Take a message without deserializing it and with its additional message information.
  /// /**
  ///  * The same as rmw_take_serialized_message(), except it also includes the
  ///  * rmw_message_info_t.
  ///  *
  ///  * \param[in] subscription Subscription object to take from.
  ///  * \param[out] serialized_message The destination in which to store the serialized message.
  ///  * \param[out] taken Boolean flag indicating if a message was taken or not.
  ///  * \param[out] message_info A structure containing meta information about the taken message.
  ///  * \param[in] allocation Preallocated buffer to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_serialized_message_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_serialized_message_with_info(
      subscription,
      serialized_message,
      taken,
      message_info,
      allocation,
    );
  }

  late final _rmw_take_serialized_message_with_info_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_take_serialized_message_with_info>>(
          'rmw_take_serialized_message_with_info');
  late final _dart_rmw_take_serialized_message_with_info
      _rmw_take_serialized_message_with_info =
      _rmw_take_serialized_message_with_info_ptr
          .asFunction<_dart_rmw_take_serialized_message_with_info>();

  /// Take a loaned message.
  /// /**
  ///  * If capable, the middleware can loan messages containing incoming messages.
  ///  * The message is owned by the middleware and thus has to be returned
  ///  * with a call to \sa rmw_return_loaned_message_from_subscription.
  ///  *
  ///  * \param[in] subscription Subscription object to take from.
  ///  * \param[inout] loaned_message The destination in which to store the loaned message.
  ///  * \param[out] taken Boolean flag indicating if a message was taken or not.
  ///  * \param[in] allocation Preallocated buffer to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_loaned_message(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_loaned_message(
      subscription,
      loaned_message,
      taken,
      allocation,
    );
  }

  late final _rmw_take_loaned_message_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_take_loaned_message>>(
          'rmw_take_loaned_message');
  late final _dart_rmw_take_loaned_message _rmw_take_loaned_message =
      _rmw_take_loaned_message_ptr.asFunction<_dart_rmw_take_loaned_message>();

  /// Take a loaned message and with its additional message information.
  /// /**
  ///  * If capable, the middleware can loan messages containing incoming messages.
  ///  * The message is owned by the middleware and thus has to be returned
  ///  * with a call to \sa rmw_release_loaned_message.
  ///  *
  ///  * \param[in] subscription Subscription object to take from.
  ///  * \param[inout] loaned_message The destination in which to store the loaned message.
  ///  * \param[out] taken Boolean flag indicating if a message was taken or not.
  ///  * \param[out] message_info A structure containing meta information about the taken message.
  ///  * \param[in] allocation Preallocated buffer to use (may be NULL).
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_take_loaned_message_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return _rmw_take_loaned_message_with_info(
      subscription,
      loaned_message,
      taken,
      message_info,
      allocation,
    );
  }

  late final _rmw_take_loaned_message_with_info_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_take_loaned_message_with_info>>(
          'rmw_take_loaned_message_with_info');
  late final _dart_rmw_take_loaned_message_with_info
      _rmw_take_loaned_message_with_info =
      _rmw_take_loaned_message_with_info_ptr
          .asFunction<_dart_rmw_take_loaned_message_with_info>();

  /// Return a loaned message previously taken from a subscription.
  /// /**
  ///  * After the taking a loaned message from the middleware, the middleware has to keep the memory
  ///  * for the loaned message alive and valid as long as the user is working with that loan.
  ///  * In order to indicate that the loaned message is no longer needed, the call to
  ///  * \sa rmw_return_loaned_message_from_subscription tells the middleware that memory can be
  ///  * deallocated/destroyed.
  ///  *
  ///  * \param[in] subscription The subscription instance which loaned the message.
  ///  * \param[in] loaned_message The message to be released.
  ///  */
  int rmw_return_loaned_message_from_subscription(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return _rmw_return_loaned_message_from_subscription(
      subscription,
      loaned_message,
    );
  }

  late final _rmw_return_loaned_message_from_subscription_ptr = _lookup<
          ffi.NativeFunction<_c_rmw_return_loaned_message_from_subscription>>(
      'rmw_return_loaned_message_from_subscription');
  late final _dart_rmw_return_loaned_message_from_subscription
      _rmw_return_loaned_message_from_subscription =
      _rmw_return_loaned_message_from_subscription_ptr
          .asFunction<_dart_rmw_return_loaned_message_from_subscription>();

  ffi.Pointer<rmw_client_t> rmw_create_client(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> service_name,
    ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ) {
    return _rmw_create_client(
      node,
      type_support,
      service_name,
      qos_policies,
    );
  }

  late final _rmw_create_client_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_create_client>>('rmw_create_client');
  late final _dart_rmw_create_client _rmw_create_client =
      _rmw_create_client_ptr.asFunction<_dart_rmw_create_client>();

  int rmw_destroy_client(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_client_t> client,
  ) {
    return _rmw_destroy_client(
      node,
      client,
    );
  }

  late final _rmw_destroy_client_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_destroy_client>>('rmw_destroy_client');
  late final _dart_rmw_destroy_client _rmw_destroy_client =
      _rmw_destroy_client_ptr.asFunction<_dart_rmw_destroy_client>();

  int rmw_send_request(
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Int64> sequence_id,
  ) {
    return _rmw_send_request(
      client,
      ros_request,
      sequence_id,
    );
  }

  late final _rmw_send_request_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_send_request>>('rmw_send_request');
  late final _dart_rmw_send_request _rmw_send_request =
      _rmw_send_request_ptr.asFunction<_dart_rmw_send_request>();

  int rmw_take_response(
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
    ffi.Pointer<ffi.Uint8> taken,
  ) {
    return _rmw_take_response(
      client,
      request_header,
      ros_response,
      taken,
    );
  }

  late final _rmw_take_response_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_take_response>>('rmw_take_response');
  late final _dart_rmw_take_response _rmw_take_response =
      _rmw_take_response_ptr.asFunction<_dart_rmw_take_response>();

  ffi.Pointer<rmw_service_t> rmw_create_service(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> service_name,
    ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ) {
    return _rmw_create_service(
      node,
      type_support,
      service_name,
      qos_policies,
    );
  }

  late final _rmw_create_service_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_create_service>>('rmw_create_service');
  late final _dart_rmw_create_service _rmw_create_service =
      _rmw_create_service_ptr.asFunction<_dart_rmw_create_service>();

  int rmw_destroy_service(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_service_t> service,
  ) {
    return _rmw_destroy_service(
      node,
      service,
    );
  }

  late final _rmw_destroy_service_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_destroy_service>>(
          'rmw_destroy_service');
  late final _dart_rmw_destroy_service _rmw_destroy_service =
      _rmw_destroy_service_ptr.asFunction<_dart_rmw_destroy_service>();

  int rmw_take_request(
    ffi.Pointer<rmw_service_t> service,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Uint8> taken,
  ) {
    return _rmw_take_request(
      service,
      request_header,
      ros_request,
      taken,
    );
  }

  late final _rmw_take_request_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_take_request>>('rmw_take_request');
  late final _dart_rmw_take_request _rmw_take_request =
      _rmw_take_request_ptr.asFunction<_dart_rmw_take_request>();

  int rmw_send_response(
    ffi.Pointer<rmw_service_t> service,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return _rmw_send_response(
      service,
      request_header,
      ros_response,
    );
  }

  late final _rmw_send_response_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_send_response>>('rmw_send_response');
  late final _dart_rmw_send_response _rmw_send_response =
      _rmw_send_response_ptr.asFunction<_dart_rmw_send_response>();

  /// TODO(wjwwood): refactor this API to return a return code when updated to use an allocator
  /// Create a guard condition and return a handle to that guard condition.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - context is `NULL`
  ///  *   - context is invalid
  ///  *   - memory allocation fails during guard condition creation
  ///  *   - an unspecified error occurs
  ///  *
  ///  * The context must be non-null and valid, i.e. it has been initialized
  ///  * by `rmw_init()` and has not been finalized by `rmw_shutdown()`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No [1]
  ///  * Lock-Free          | No [1]
  ///  * <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///  *
  ///  * This should be defined by the rmw implementation.
  ///  *
  ///  * \param[in] context init context that this node should be associated with
  ///  * \return rmw guard condition handle or `NULL` if there was an error
  ///  */
  ffi.Pointer<rmw_guard_condition_t> rmw_create_guard_condition(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return _rmw_create_guard_condition(
      context,
    );
  }

  late final _rmw_create_guard_condition_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_create_guard_condition>>(
          'rmw_create_guard_condition');
  late final _dart_rmw_create_guard_condition _rmw_create_guard_condition =
      _rmw_create_guard_condition_ptr
          .asFunction<_dart_rmw_create_guard_condition>();

  /// Finalize a given guard condition handle, reclaim the resources, and deallocate the handle.
  /// /**
  ///  * \param guard_condition the guard condition handle to be destroyed
  ///  * \return `RMW_RET_OK` if successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if guard_condition is null, or
  ///  * \return `RMW_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rmw_destroy_guard_condition(
    ffi.Pointer<rmw_guard_condition_t> guard_condition,
  ) {
    return _rmw_destroy_guard_condition(
      guard_condition,
    );
  }

  late final _rmw_destroy_guard_condition_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_destroy_guard_condition>>(
          'rmw_destroy_guard_condition');
  late final _dart_rmw_destroy_guard_condition _rmw_destroy_guard_condition =
      _rmw_destroy_guard_condition_ptr
          .asFunction<_dart_rmw_destroy_guard_condition>();

  int rmw_trigger_guard_condition(
    ffi.Pointer<rmw_guard_condition_t> guard_condition,
  ) {
    return _rmw_trigger_guard_condition(
      guard_condition,
    );
  }

  late final _rmw_trigger_guard_condition_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_trigger_guard_condition>>(
          'rmw_trigger_guard_condition');
  late final _dart_rmw_trigger_guard_condition _rmw_trigger_guard_condition =
      _rmw_trigger_guard_condition_ptr
          .asFunction<_dart_rmw_trigger_guard_condition>();

  /// Create a wait set to store conditions that the middleware will block on.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - context is `NULL`
  ///  *   - context is invalid
  ///  *   - memory allocation fails during wait set creation
  ///  *   - an unspecified error occurs
  ///  *
  ///  * If `max_conditions` is `0`, the wait set can store an unbounded number of
  ///  * conditions to wait on.
  ///  * If `max_conditions` is greater than `0`, the number of conditions that can
  ///  * be attached to the wait set is bounded at `max_conditions`.
  ///  *
  ///  * \param[in] context init context that this node should be associated with
  ///  * \param[in] max_conditions
  ///  *   The maximum number of conditions that can be attached to the wait set.
  ///  * \return A pointer to the created wait set, `NULL` if an error occurred.
  ///  */
  ffi.Pointer<rmw_wait_set_t> rmw_create_wait_set(
    ffi.Pointer<rmw_context_t> context,
    int max_conditions,
  ) {
    return _rmw_create_wait_set(
      context,
      max_conditions,
    );
  }

  late final _rmw_create_wait_set_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_create_wait_set>>(
          'rmw_create_wait_set');
  late final _dart_rmw_create_wait_set _rmw_create_wait_set =
      _rmw_create_wait_set_ptr.asFunction<_dart_rmw_create_wait_set>();

  int rmw_destroy_wait_set(
    ffi.Pointer<rmw_wait_set_t> wait_set,
  ) {
    return _rmw_destroy_wait_set(
      wait_set,
    );
  }

  late final _rmw_destroy_wait_set_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_destroy_wait_set>>(
          'rmw_destroy_wait_set');
  late final _dart_rmw_destroy_wait_set _rmw_destroy_wait_set =
      _rmw_destroy_wait_set_ptr.asFunction<_dart_rmw_destroy_wait_set>();

  /// Waits on sets of different waitable entities and returns when one is ready.
  /// /**
  ///  * Add conditions to the wait set and wait until a response comes in, or until
  ///  * the timeout is reached.
  ///  * The arrays contain type-erased representations of waitable entities.
  ///  * This function casts the pointers to middleware-specific conditions and adds
  ///  * them to the wait set.
  ///  *
  ///  * The count variables in the arrays represents the number of valid pointers
  ///  * in the array.
  ///  * `NULL` pointers are in the array considered invalid.
  ///  * If they are encountered, an error is returned.
  ///  *
  ///  * The array structs are allocated and deallocated outside of this function.
  ///  * They do not have any information about how much memory is allocated for the
  ///  * arrays.
  ///  *
  ///  * After the wait wakes up, the entries in each array that correspond to
  ///  * conditions that were not triggered are set to `NULL`.
  ///  *
  ///  * \param subscriptions Array of subscriptions to wait on
  ///  * \param guard_conditions Array of guard conditions to wait on
  ///  * \param services Array of services to wait on
  ///  * \param clients Array of clients to wait on
  ///  * \param wait_set Storage for the wait set
  ///  * \param wait_timeout
  ///  *   If NULL, block until a condition is ready.
  ///  *   If zero, check only for immediately available conditions and don't block.
  ///  *   Else, this represents the maximum time to wait for a response from the
  ///  *   wait set.
  ///  * \return `RMW_RET_OK` if success, or
  ///  * \return `RMW_RET_ERROR` if error, or
  ///  * \return `RMW_RET_TIMEOUT` if wait timed out.
  ///  */
  int rmw_wait(
    ffi.Pointer<rmw_subscriptions_t> subscriptions,
    ffi.Pointer<rmw_guard_conditions_t> guard_conditions,
    ffi.Pointer<rmw_services_t> services,
    ffi.Pointer<rmw_clients_t> clients,
    ffi.Pointer<rmw_events_t> events,
    ffi.Pointer<rmw_wait_set_t> wait_set,
    ffi.Pointer<rmw_time_t> wait_timeout,
  ) {
    return _rmw_wait(
      subscriptions,
      guard_conditions,
      services,
      clients,
      events,
      wait_set,
      wait_timeout,
    );
  }

  late final _rmw_wait_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_wait>>('rmw_wait');
  late final _dart_rmw_wait _rmw_wait =
      _rmw_wait_ptr.asFunction<_dart_rmw_wait>();

  /// Return a list of node name and namespaces discovered via a node.
  /// /**
  ///  * This function will return a list of node names and a list of node namespaces
  ///  * that are discovered via the middleware.
  ///  * The two lists represent pairs of namespace and name for each discovered
  ///  * node.
  ///  * The lists will be the same length and the same position will refer to the
  ///  * same node across lists.
  ///  *
  ///  * The node parameter must not be `NULL`, and must point to a valid node.
  ///  *
  ///  * The node_names parameter must not be `NULL`, and must point to a valid
  ///  * string array.
  ///  *
  ///  * The node_namespaces parameter must not be `NULL`, and must point to a
  ///  * valid string array.
  ///  *
  ///  * This function does manipulate heap memory.
  ///  * This function is not thread-safe.
  ///  * This function is lock-free.
  ///  *
  ///  * \param[in] node the handle to the node being used to query the ROS graph
  ///  * \param[out] node_names a list of discovered node names
  ///  * \param[out] node_namespaces a list of discovered node namespaces
  ///  * \return `RMW_RET_OK` if node the query was made successfully, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_get_node_names(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rcutils_string_array_t> node_names,
    ffi.Pointer<rcutils_string_array_t> node_namespaces,
  ) {
    return _rmw_get_node_names(
      node,
      node_names,
      node_namespaces,
    );
  }

  late final _rmw_get_node_names_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_node_names>>('rmw_get_node_names');
  late final _dart_rmw_get_node_names _rmw_get_node_names =
      _rmw_get_node_names_ptr.asFunction<_dart_rmw_get_node_names>();

  int rmw_count_publishers(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<ffi.Uint64> count,
  ) {
    return _rmw_count_publishers(
      node,
      topic_name,
      count,
    );
  }

  late final _rmw_count_publishers_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_count_publishers>>(
          'rmw_count_publishers');
  late final _dart_rmw_count_publishers _rmw_count_publishers =
      _rmw_count_publishers_ptr.asFunction<_dart_rmw_count_publishers>();

  int rmw_count_subscribers(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<ffi.Uint64> count,
  ) {
    return _rmw_count_subscribers(
      node,
      topic_name,
      count,
    );
  }

  late final _rmw_count_subscribers_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_count_subscribers>>(
          'rmw_count_subscribers');
  late final _dart_rmw_count_subscribers _rmw_count_subscribers =
      _rmw_count_subscribers_ptr.asFunction<_dart_rmw_count_subscribers>();

  int rmw_get_gid_for_publisher(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rmw_gid_t> gid,
  ) {
    return _rmw_get_gid_for_publisher(
      publisher,
      gid,
    );
  }

  late final _rmw_get_gid_for_publisher_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_gid_for_publisher>>(
          'rmw_get_gid_for_publisher');
  late final _dart_rmw_get_gid_for_publisher _rmw_get_gid_for_publisher =
      _rmw_get_gid_for_publisher_ptr
          .asFunction<_dart_rmw_get_gid_for_publisher>();

  int rmw_compare_gids_equal(
    ffi.Pointer<rmw_gid_t> gid1,
    ffi.Pointer<rmw_gid_t> gid2,
    ffi.Pointer<ffi.Uint8> result,
  ) {
    return _rmw_compare_gids_equal(
      gid1,
      gid2,
      result,
    );
  }

  late final _rmw_compare_gids_equal_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_compare_gids_equal>>(
          'rmw_compare_gids_equal');
  late final _dart_rmw_compare_gids_equal _rmw_compare_gids_equal =
      _rmw_compare_gids_equal_ptr.asFunction<_dart_rmw_compare_gids_equal>();

  /// Check if a service server is available for the given service client.
  /// /**
  ///  * This function will return true for `is_available` if there is a service
  ///  * server available for the given client.
  ///  *
  ///  * The node parameter must not be `NULL`, and must point to a valid node.
  ///  *
  ///  * The client parameter must not be `NULL`, and must point to a valid client.
  ///  *
  ///  * The given client and node must match, i.e. the client must have been created
  ///  * using the given node.
  ///  *
  ///  * The is_available parameter must not be `NULL`, and must point to a bool
  ///  * variable.
  ///  * The result of the check will be stored in the is_available parameter.
  ///  *
  ///  * This function does manipulate heap memory.
  ///  * This function is not thread-safe.
  ///  * This function is lock-free.
  ///  *
  ///  * \param[in] node the handle to the node being used to query the ROS graph
  ///  * \param[in] client the handle to the service client being queried
  ///  * \param[out] is_available
  ///  *   set to true if there is a service server available, else false
  ///  * \return `RMW_RET_OK` if node the check was made successfully, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_service_server_is_available(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<ffi.Uint8> is_available,
  ) {
    return _rmw_service_server_is_available(
      node,
      client,
      is_available,
    );
  }

  late final _rmw_service_server_is_available_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_service_server_is_available>>(
          'rmw_service_server_is_available');
  late final _dart_rmw_service_server_is_available
      _rmw_service_server_is_available = _rmw_service_server_is_available_ptr
          .asFunction<_dart_rmw_service_server_is_available>();

  int rmw_set_log_severity(
    int severity,
  ) {
    return _rmw_set_log_severity(
      severity,
    );
  }

  late final _rmw_set_log_severity_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_set_log_severity>>(
          'rmw_set_log_severity');
  late final _dart_rmw_set_log_severity _rmw_set_log_severity =
      _rmw_set_log_severity_ptr.asFunction<_dart_rmw_set_log_severity>();

  /// Return a zero initialized timer.
  rcl_timer_t rcl_get_zero_initialized_timer() {
    return _rcl_get_zero_initialized_timer();
  }

  late final _rcl_get_zero_initialized_timer_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_timer>>(
          'rcl_get_zero_initialized_timer');
  late final _dart_rcl_get_zero_initialized_timer
      _rcl_get_zero_initialized_timer = _rcl_get_zero_initialized_timer_ptr
          .asFunction<_dart_rcl_get_zero_initialized_timer>();

  /// Initialize a timer.
  /// /**
  ///  * A timer consists of a clock, a callback function and a period.
  ///  * A timer can be added to a wait set and waited on, such that the wait set
  ///  * will wake up when a timer is ready to be executed.
  ///  *
  ///  * A timer simply holds state and does not automatically call callbacks.
  ///  * It does not create any threads, register interrupts, or consume signals.
  ///  * For blocking behavior it can be used in conjunction with a wait set and
  ///  * rcl_wait().
  ///  * When rcl_timer_is_ready() returns true, the timer must still be called
  ///  * explicitly using rcl_timer_call().
  ///  *
  ///  * The timer handle must be a pointer to an allocated and zero initialized
  ///  * rcl_timer_t struct.
  ///  * Calling this function on an already initialized timer will fail.
  ///  * Calling this function on a timer struct which has been allocated but not
  ///  * zero initialized is undefined behavior.
  ///  *
  ///  * The clock handle must be a pointer to an initialized rcl_clock_t struct.
  ///  * The life time of the clock must exceed the life time of the timer.
  ///  *
  ///  * The period is a non-negative duration (rather an absolute time in the
  ///  * future).
  ///  * If the period is `0` then it will always be ready.
  ///  *
  ///  * The callback is an optional argument.
  ///  * Valid inputs are either a pointer to the function callback, or `NULL` to
  ///  * indicate that no callback will be stored in rcl.
  ///  * If the callback is `NULL`, the caller client library is responsible for
  ///  * firing the timer callback.
  ///  * Else, it must be a function which returns void and takes two arguments,
  ///  * the first being a pointer to the associated timer, and the second a int64_t
  ///  * which is the time since the previous call, or since the timer was created
  ///  * if it is the first call to the callback.
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  *
  ///  * void my_timer_callback(rcl_timer_t * timer, int64_t last_call_time)
  ///  * {
  ///  *   // Do timer work...
  ///  *   // Optionally reconfigure, cancel, or reset the timer...
  ///  * }
  ///  *
  ///  * rcl_context_t * context;  // initialized previously by rcl_init()...
  ///  * rcl_clock_t clock;
  ///  * rcl_allocator_t allocator = rcl_get_default_allocator();
  ///  * rcl_ret_t ret = rcl_clock_init(RCL_STEADY_TIME, &clock, &allocator);
  ///  * // ... error handling
  ///  *
  ///  * rcl_timer_t timer = rcl_get_zero_initialized_timer();
  ///  * ret = rcl_timer_init(
  ///  *   &timer, &clock, context, RCL_MS_TO_NS(100), my_timer_callback, allocator);
  ///  * // ... error handling, use the timer with a wait set, or poll it manually, then cleanup
  ///  * ret = rcl_timer_fini(&timer);
  ///  * // ... error handling
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1][2][3]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>
  ///  *
  ///  * <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///  *
  ///  * \param[inout] timer the timer handle to be initialized
  ///  * \param[in] clock the clock providing the current time
  ///  * \param[in] context the context that this timer is to be associated with
  ///  * \param[in] period the duration between calls to the callback in nanoseconds
  ///  * \param[in] callback the user defined function to be called every period
  ///  * \param[in] allocator the allocator to use for allocations
  ///  * \return `RCL_RET_OK` if the timer was initialized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ALREADY_INIT` if the timer was already initialized, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_init(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcl_context_t> context,
    int period,
    ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> callback,
    rcutils_allocator_t allocator,
  ) {
    return _rcl_timer_init(
      timer,
      clock,
      context,
      period,
      callback,
      allocator,
    );
  }

  late final _rcl_timer_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_init>>('rcl_timer_init');
  late final _dart_rcl_timer_init _rcl_timer_init =
      _rcl_timer_init_ptr.asFunction<_dart_rcl_timer_init>();

  /// Finalize a timer.
  /// /**
  ///  * This function will deallocate any memory and make the timer invalid.
  ///  *
  ///  * A timer that is already invalid (zero initialized) or `NULL` will not fail.
  ///  *
  ///  * This function is not thread-safe with any rcl_timer_* functions used on the
  ///  * same timer object.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1][2][3]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>
  ///  *
  ///  * <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///  *
  ///  * \param[inout] timer the handle to the timer to be finalized.
  ///  * \return `RCL_RET_OK` if the timer was finalized successfully, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_fini(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_fini(
      timer,
    );
  }

  late final _rcl_timer_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_fini>>('rcl_timer_fini');
  late final _dart_rcl_timer_fini _rcl_timer_fini =
      _rcl_timer_fini_ptr.asFunction<_dart_rcl_timer_fini>();

  /// Call the timer's callback and set the last call time.
  /// /**
  ///  * This function will call the callback and change the last call time even if
  ///  * the timer's period has not yet elapsed.
  ///  * It is up to the calling code to make sure the period has elapsed by first
  ///  * calling rcl_timer_is_ready().
  ///  * If the callback pointer is `NULL` (either set in init or exchanged after
  ///  * initialized), no callback is fired.
  ///  * However, this function should still be called by the client library to
  ///  * update the state of the timer.
  ///  * The order of operations in this command are as follows:
  ///  *
  ///  *  - Ensure the timer has not been canceled.
  ///  *  - Get the current time into a temporary rcl_steady_time_point_t.
  ///  *  - Exchange the current time with the last call time of the timer.
  ///  *  - Call the callback, passing this timer and the time since the last call.
  ///  *  - Return after the callback has completed.
  ///  *
  ///  * During the callback the timer can be canceled or have its period and/or
  ///  * callback modified.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [2]
  ///  * <i>[1] user callback might not be thread-safe</i>
  ///  *
  ///  * <i>[2] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[inout] timer the handle to the timer to call
  ///  * \return `RCL_RET_OK` if the timer was called successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_TIMER_CANCELED` if the timer has been canceled, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_call(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_call(
      timer,
    );
  }

  late final _rcl_timer_call_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_call>>('rcl_timer_call');
  late final _dart_rcl_timer_call _rcl_timer_call =
      _rcl_timer_call_ptr.asFunction<_dart_rcl_timer_call>();

  /// Retrieve the clock of the timer.
  /// /**
  ///  * This function retrieves the clock pointer and copies it into the given variable.
  ///  *
  ///  * The clock argument must be a pointer to an already allocated rcl_clock_t *.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] timer the handle to the timer which is being queried
  ///  * \param[out] clock the rcl_clock_t * in which the clock is stored
  ///  * \return `RCL_RET_OK` if the period was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_clock(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Pointer<rcl_clock_t>> clock,
  ) {
    return _rcl_timer_clock(
      timer,
      clock,
    );
  }

  late final _rcl_timer_clock_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_clock>>('rcl_timer_clock');
  late final _dart_rcl_timer_clock _rcl_timer_clock =
      _rcl_timer_clock_ptr.asFunction<_dart_rcl_timer_clock>();

  /// Calculates whether or not the timer should be called.
  /// /**
  ///  * The result is true if the time until next call is less than, or equal to, 0
  ///  * and the timer has not been canceled.
  ///  * Otherwise the result is false, indicating the timer should not be called.
  ///  *
  ///  * The is_ready argument must point to an allocated bool object, as the result
  ///  * is copied into it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer which is being checked
  ///  * \param[out] is_ready the bool used to store the result of the calculation
  ///  * \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_is_ready(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Uint8> is_ready,
  ) {
    return _rcl_timer_is_ready(
      timer,
      is_ready,
    );
  }

  late final _rcl_timer_is_ready_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_is_ready>>('rcl_timer_is_ready');
  late final _dart_rcl_timer_is_ready _rcl_timer_is_ready =
      _rcl_timer_is_ready_ptr.asFunction<_dart_rcl_timer_is_ready>();

  /// Calculate and retrieve the time until the next call in nanoseconds.
  /// /**
  ///  * This function calculates the time until the next call by adding the timer's
  ///  * period to the last call time and subtracting that sum from the current time.
  ///  * The calculated time until the next call can be positive, indicating that it
  ///  * is not ready to be called as the period has not elapsed since the last call.
  ///  * The calculated time until the next call can also be 0 or negative,
  ///  * indicating that the period has elapsed since the last call and the timer
  ///  * should be called.
  ///  * A negative value indicates the timer call is overdue by that amount.
  ///  *
  ///  * The `time_until_next_call` argument must point to an allocated int64_t, as
  ///  * the time until is copied into that instance.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer that is being queried
  ///  * \param[out] time_until_next_call the output variable for the result
  ///  * \return `RCL_RET_OK` if the timer until next call was successfully calculated, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_get_time_until_next_call(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> time_until_next_call,
  ) {
    return _rcl_timer_get_time_until_next_call(
      timer,
      time_until_next_call,
    );
  }

  late final _rcl_timer_get_time_until_next_call_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_get_time_until_next_call>>(
          'rcl_timer_get_time_until_next_call');
  late final _dart_rcl_timer_get_time_until_next_call
      _rcl_timer_get_time_until_next_call =
      _rcl_timer_get_time_until_next_call_ptr
          .asFunction<_dart_rcl_timer_get_time_until_next_call>();

  /// Retrieve the time since the previous call to rcl_timer_call() occurred.
  /// /**
  ///  * This function calculates the time since the last call and copies it into
  ///  * the given int64_t variable.
  ///  *
  ///  * Calling this function within a callback will not return the time since the
  ///  * previous call but instead the time since the current callback was called.
  ///  *
  ///  * The time_since_last_call argument must be a pointer to an already allocated
  ///  * int64_t.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer which is being queried
  ///  * \param[out] time_since_last_call the struct in which the time is stored
  ///  * \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_get_time_since_last_call(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> time_since_last_call,
  ) {
    return _rcl_timer_get_time_since_last_call(
      timer,
      time_since_last_call,
    );
  }

  late final _rcl_timer_get_time_since_last_call_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_get_time_since_last_call>>(
          'rcl_timer_get_time_since_last_call');
  late final _dart_rcl_timer_get_time_since_last_call
      _rcl_timer_get_time_since_last_call =
      _rcl_timer_get_time_since_last_call_ptr
          .asFunction<_dart_rcl_timer_get_time_since_last_call>();

  /// Retrieve the period of the timer.
  /// /**
  ///  * This function retrieves the period and copies it into the given variable.
  ///  *
  ///  * The period argument must be a pointer to an already allocated int64_t.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer which is being queried
  ///  * \param[out] period the int64_t in which the period is stored
  ///  * \return `RCL_RET_OK` if the period was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_get_period(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> period,
  ) {
    return _rcl_timer_get_period(
      timer,
      period,
    );
  }

  late final _rcl_timer_get_period_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_get_period>>(
          'rcl_timer_get_period');
  late final _dart_rcl_timer_get_period _rcl_timer_get_period =
      _rcl_timer_get_period_ptr.asFunction<_dart_rcl_timer_get_period>();

  /// Exchange the period of the timer and return the previous period.
  /// /**
  ///  * This function exchanges the period in the timer and copies the old one into
  ///  * the given variable.
  ///  *
  ///  * Exchanging (changing) the period will not affect already waiting wait sets.
  ///  *
  ///  * The old_period argument must be a pointer to an already allocated int64_t.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer the handle to the timer which is being modified
  ///  * \param[out] new_period the int64_t to exchange into the timer
  ///  * \param[out] old_period the int64_t in which the previous period is stored
  ///  * \return `RCL_RET_OK` if the period was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_exchange_period(
    ffi.Pointer<rcl_timer_t> timer,
    int new_period,
    ffi.Pointer<ffi.Int64> old_period,
  ) {
    return _rcl_timer_exchange_period(
      timer,
      new_period,
      old_period,
    );
  }

  late final _rcl_timer_exchange_period_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_exchange_period>>(
          'rcl_timer_exchange_period');
  late final _dart_rcl_timer_exchange_period _rcl_timer_exchange_period =
      _rcl_timer_exchange_period_ptr
          .asFunction<_dart_rcl_timer_exchange_period>();

  /// Return the current timer callback.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - timer is `NULL`
  ///  *   - timer has not been initialized (the implementation is invalid)
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[in] timer handle to the timer from the callback should be returned
  ///  * \return function pointer to the callback, or `NULL` if an error occurred
  ///  */
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> rcl_timer_get_callback(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_get_callback(
      timer,
    );
  }

  late final _rcl_timer_get_callback_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_get_callback>>(
          'rcl_timer_get_callback');
  late final _dart_rcl_timer_get_callback _rcl_timer_get_callback =
      _rcl_timer_get_callback_ptr.asFunction<_dart_rcl_timer_get_callback>();

  /// Exchange the current timer callback and return the current callback.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - timer is `NULL`
  ///  *   - timer has not been initialized (the implementation is invalid)
  ///  *
  ///  * This function can set callback to `NULL`, in which case the callback is
  ///  * ignored when rcl_timer_call is called.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[inout] timer handle to the timer from the callback should be exchanged
  ///  * \param[in] new_callback the callback to be exchanged into the timer
  ///  * \return function pointer to the old callback, or `NULL` if an error occurred
  ///  */
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>>
      rcl_timer_exchange_callback(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> new_callback,
  ) {
    return _rcl_timer_exchange_callback(
      timer,
      new_callback,
    );
  }

  late final _rcl_timer_exchange_callback_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_exchange_callback>>(
          'rcl_timer_exchange_callback');
  late final _dart_rcl_timer_exchange_callback _rcl_timer_exchange_callback =
      _rcl_timer_exchange_callback_ptr
          .asFunction<_dart_rcl_timer_exchange_callback>();

  /// Cancel a timer.
  /// /**
  ///  * When a timer is canceled, rcl_timer_is_ready() will return false for that
  ///  * timer, and rcl_timer_call() will fail with RCL_RET_TIMER_CANCELED.
  ///  *
  ///  * A canceled timer can be reset with rcl_timer_reset(), and then used again.
  ///  * Calling this function on an already canceled timer will succeed.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[inout] timer the timer to be canceled
  ///  * \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_cancel(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_cancel(
      timer,
    );
  }

  late final _rcl_timer_cancel_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_cancel>>('rcl_timer_cancel');
  late final _dart_rcl_timer_cancel _rcl_timer_cancel =
      _rcl_timer_cancel_ptr.asFunction<_dart_rcl_timer_cancel>();

  /// Retrieve the canceled state of a timer.
  /// /**
  ///  * If the timer is canceled true will be stored in the is_canceled argument.
  ///  * Otherwise false will be stored in the is_canceled argument.
  ///  *
  ///  * The is_canceled argument must point to an allocated bool, as the result is
  ///  * copied into this variable.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///  *
  ///  * \param[in] timer the timer to be queried
  ///  * \param[out] is_canceled storage for the is canceled bool
  ///  * \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_is_canceled(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Uint8> is_canceled,
  ) {
    return _rcl_timer_is_canceled(
      timer,
      is_canceled,
    );
  }

  late final _rcl_timer_is_canceled_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_is_canceled>>(
          'rcl_timer_is_canceled');
  late final _dart_rcl_timer_is_canceled _rcl_timer_is_canceled =
      _rcl_timer_is_canceled_ptr.asFunction<_dart_rcl_timer_is_canceled>();

  /// Reset a timer.
  /// /**
  ///  * This function can be called on a timer, canceled or not.
  ///  * For all timers it will reset the last call time to now.
  ///  * For canceled timers it will additionally make the timer not canceled.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///  *
  ///  * \param[inout] timer the timer to be reset
  ///  * \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_timer_reset(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_reset(
      timer,
    );
  }

  late final _rcl_timer_reset_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_reset>>('rcl_timer_reset');
  late final _dart_rcl_timer_reset _rcl_timer_reset =
      _rcl_timer_reset_ptr.asFunction<_dart_rcl_timer_reset>();

  /// Return the allocator for the timer.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if:
  ///  *   - timer is `NULL`
  ///  *   - timer has not been initialized (the implementation is invalid)
  ///  *
  ///  * The returned pointer is only valid as long as the timer object is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] timer handle to the timer object
  ///  * \return pointer to the allocator, or `NULL` if an error occurred
  ///  */
  ffi.Pointer<rcutils_allocator_t> rcl_timer_get_allocator(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_get_allocator(
      timer,
    );
  }

  late final _rcl_timer_get_allocator_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_get_allocator>>(
          'rcl_timer_get_allocator');
  late final _dart_rcl_timer_get_allocator _rcl_timer_get_allocator =
      _rcl_timer_get_allocator_ptr.asFunction<_dart_rcl_timer_get_allocator>();

  /// Retrieve a guard condition used by the timer to wake the waitset when using ROSTime.
  /// /**
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] timer the timer to be queried
  ///  * \return `NULL` if the timer is invalid or does not have a guard condition, or
  ///  * \return a guard condition pointer.
  ///  */
  ffi.Pointer<rcl_guard_condition_t> rcl_timer_get_guard_condition(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return _rcl_timer_get_guard_condition(
      timer,
    );
  }

  late final _rcl_timer_get_guard_condition_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_timer_get_guard_condition>>(
          'rcl_timer_get_guard_condition');
  late final _dart_rcl_timer_get_guard_condition
      _rcl_timer_get_guard_condition = _rcl_timer_get_guard_condition_ptr
          .asFunction<_dart_rcl_timer_get_guard_condition>();

  /// Return a rcl_publisher_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_publisher_t before passing to
  ///  * rcl_publisher_init().
  ///  */
  rcl_publisher_t rcl_get_zero_initialized_publisher() {
    return _rcl_get_zero_initialized_publisher();
  }

  late final _rcl_get_zero_initialized_publisher_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_publisher>>(
          'rcl_get_zero_initialized_publisher');
  late final _dart_rcl_get_zero_initialized_publisher
      _rcl_get_zero_initialized_publisher =
      _rcl_get_zero_initialized_publisher_ptr
          .asFunction<_dart_rcl_get_zero_initialized_publisher>();

  /// Initialize a rcl publisher.
  /// /**
  ///  * After calling this function on a rcl_publisher_t, it can be used to publish
  ///  * messages of the given type to the given topic using rcl_publish().
  ///  *
  ///  * The given rcl_node_t must be valid and the resulting rcl_publisher_t is only
  ///  * valid as long as the given rcl_node_t remains valid.
  ///  *
  ///  * The rosidl_message_type_support_t is obtained on a per .msg type basis.
  ///  * When the user defines a ROS message, code is generated which provides the
  ///  * required rosidl_message_type_support_t object.
  ///  * This object can be obtained using a language appropriate mechanism.
  ///  * \todo TODO(wjwwood) write these instructions once and link to it instead
  ///  *
  ///  * For C, a macro can be used (for example `std_msgs/String`):
  ///  *
  ///  * ```c
  ///  * #include <rosidl_generator_c/message_type_support_struct.h>
  ///  * #include <std_msgs/msg/string.h>
  ///  * const rosidl_message_type_support_t * string_ts =
  ///  *   ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  ///  * ```
  ///  *
  ///  * For C++, a template function is used:
  ///  *
  ///  * ```cpp
  ///  * #include <rosidl_typesupport_cpp/message_type_support.hpp>
  ///  * #include <std_msgs/msg/string.hpp>
  ///  * const rosidl_message_type_support_t * string_ts =
  ///  *   rosidl_typesupport_cpp::get_message_type_support_handle<std_msgs::msg::String>();
  ///  * ```
  ///  *
  ///  * The rosidl_message_type_support_t object contains message type specific
  ///  * information used to publish messages.
  ///  *
  ///  * The topic name must be a c string which follows the topic and service name
  ///  * format rules for unexpanded names, also known as non-fully qualified names:
  ///  *
  ///  * \see rcl_expand_topic_name
  ///  *
  ///  * The options struct allows the user to set the quality of service settings as
  ///  * well as a custom allocator which is used when initializing/finalizing the
  ///  * publisher to allocate space for incidentals, e.g. the topic name string.
  ///  *
  ///  * Expected usage (for C messages):
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  * #include <rosidl_generator_c/message_type_support_struct.h>
  ///  * #include <std_msgs/msg/string.h>
  ///  *
  ///  * rcl_node_t node = rcl_get_zero_initialized_node();
  ///  * rcl_node_options_t node_ops = rcl_node_get_default_options();
  ///  * rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  ///  * // ... error handling
  ///  * const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  ///  * rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();
  ///  * rcl_publisher_options_t publisher_ops = rcl_publisher_get_default_options();
  ///  * ret = rcl_publisher_init(&publisher, &node, ts, "chatter", &publisher_ops);
  ///  * // ... error handling, and on shutdown do finalization:
  ///  * ret = rcl_publisher_fini(&publisher, &node);
  ///  * // ... error handling for rcl_publisher_fini()
  ///  * ret = rcl_node_fini(&node);
  ///  * // ... error handling for rcl_deinitialize_node()
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] publisher preallocated publisher structure
  ///  * \param[in] node valid rcl node handle
  ///  * \param[in] type_support type support object for the topic's type
  ///  * \param[in] topic_name the name of the topic to publish on
  ///  * \param[in] options publisher options, including quality of service settings
  ///  * \return `RCL_RET_OK` if the publisher was initialized successfully, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_ALREADY_INIT` if the publisher is already initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory fails, or
  ///  * \return `RCL_RET_TOPIC_NAME_INVALID` if the given topic name is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_publisher_init(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<rcl_publisher_options_t> options,
  ) {
    return _rcl_publisher_init(
      publisher,
      node,
      type_support,
      topic_name,
      options,
    );
  }

  late final _rcl_publisher_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_init>>('rcl_publisher_init');
  late final _dart_rcl_publisher_init _rcl_publisher_init =
      _rcl_publisher_init_ptr.asFunction<_dart_rcl_publisher_init>();

  /// Finalize a rcl_publisher_t.
  /// /**
  ///  * After calling, the node will no longer be advertising that it is publishing
  ///  * on this topic (assuming this is the only publisher on this topic).
  ///  *
  ///  * After calling, calls to rcl_publish will fail when using this publisher.
  ///  * However, the given node handle is still valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] publisher handle to the publisher to be finalized
  ///  * \param[in] node handle to the node used to create the publisher
  ///  * \return `RCL_RET_OK` if publisher was finalized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  ///  * \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_publisher_fini(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return _rcl_publisher_fini(
      publisher,
      node,
    );
  }

  late final _rcl_publisher_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_fini>>('rcl_publisher_fini');
  late final _dart_rcl_publisher_fini _rcl_publisher_fini =
      _rcl_publisher_fini_ptr.asFunction<_dart_rcl_publisher_fini>();

  /// Return the default publisher options in a rcl_publisher_options_t.
  /// /**
  ///  * The defaults are:
  ///  *
  ///  * - qos = rmw_qos_profile_default
  ///  * - allocator = rcl_get_default_allocator()
  ///  */
  rcl_publisher_options_t rcl_publisher_get_default_options() {
    return _rcl_publisher_get_default_options();
  }

  late final _rcl_publisher_get_default_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_get_default_options>>(
          'rcl_publisher_get_default_options');
  late final _dart_rcl_publisher_get_default_options
      _rcl_publisher_get_default_options =
      _rcl_publisher_get_default_options_ptr
          .asFunction<_dart_rcl_publisher_get_default_options>();

  /// Borrow a loaned message.
  /// /**
  ///  * The memory allocated for the ros message belongs to the middleware and must not be deallocated
  ///  * other than by a call to \sa rcl_return_loaned_message_from_publisher.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No [0]
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * [0] the underlying middleware might allocate new memory or returns an existing chunk form a pool.
  ///  * The function in rcl however does not allocate any additional memory.
  ///  *
  ///  * \param[in] publisher Publisher to which the allocated message is associated.
  ///  * \param[in] type_support Typesupport to which the internal ros message is allocated.
  ///  * \param[out] ros_message The pointer to be filled to a valid ros message by the middleware.
  ///  * \return `RCL_RET_OK` if the ros message was correctly initialized, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if an argument other than the ros message is null, or
  ///  * \return `RCL_RET_BAD_ALLOC` if the ros message could not be correctly created, or
  ///  * \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  ///  * \return `RCL_RET_ERROR` if an unexpected error occured.
  ///  */
  int rcl_borrow_loaned_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
  ) {
    return _rcl_borrow_loaned_message(
      publisher,
      type_support,
      ros_message,
    );
  }

  late final _rcl_borrow_loaned_message_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_borrow_loaned_message>>(
          'rcl_borrow_loaned_message');
  late final _dart_rcl_borrow_loaned_message _rcl_borrow_loaned_message =
      _rcl_borrow_loaned_message_ptr
          .asFunction<_dart_rcl_borrow_loaned_message>();

  /// Return a loaned message previously borrowed from a publisher.
  /// /**
  ///  * The ownership of the passed in ros message will be transferred back to the middleware.
  ///  * The middleware might deallocate and destroy the message so that the pointer is no longer
  ///  * guaranteed to be valid after that call.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher Publisher to which the loaned message is associated.
  ///  * \param[in] loaned_message Loaned message to be deallocated and destroyed.
  ///  * \return `RCL_RET_OK` if successful, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if an argument is null, or
  ///  * \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  ///  * \return `RCL_RET_ERROR` if an unexpected error occurs and no message can be initialized.
  ///  */
  int rcl_return_loaned_message_from_publisher(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return _rcl_return_loaned_message_from_publisher(
      publisher,
      loaned_message,
    );
  }

  late final _rcl_return_loaned_message_from_publisher_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_return_loaned_message_from_publisher>>(
          'rcl_return_loaned_message_from_publisher');
  late final _dart_rcl_return_loaned_message_from_publisher
      _rcl_return_loaned_message_from_publisher =
      _rcl_return_loaned_message_from_publisher_ptr
          .asFunction<_dart_rcl_return_loaned_message_from_publisher>();

  /// Publish a ROS message on a topic using a publisher.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the ros_message
  ///  * parameter and the type associate with the publisher (via the type support)
  ///  * match.
  ///  * Passing a different type to publish produces undefined behavior and cannot
  ///  * be checked by this function and therefore no deliberate error will occur.
  ///  *
  ///  * \todo TODO(wjwwood):
  ///  *   The blocking behavior of publish is a still a point of dispute.
  ///  *   This section should be updated once the behavior is clearly defined.
  ///  *   See: https://github.com/ros2/ros2/issues/255
  ///  *
  ///  * Calling rcl_publish() is a potentially blocking call.
  ///  * When called rcl_publish() will immediately do any publishing related work,
  ///  * including, but not limited to, converting the message into a different type,
  ///  * serializing the message, collecting publish statistics, etc.
  ///  * The last thing it will do is call the underlying middleware's publish
  ///  * function which may or may not block based on the quality of service settings
  ///  * given via the publisher options in rcl_publisher_init().
  ///  * For example, if the reliability is set to reliable, then a publish may block
  ///  * until space in the publish queue is available, but if the reliability is set
  ///  * to best effort then it should not block.
  ///  *
  ///  * The ROS message given by the `ros_message` void pointer is always owned by
  ///  * the calling code, but should remain constant during publish.
  ///  *
  ///  * This function is thread safe so long as access to both the publisher and the
  ///  * `ros_message` is synchronized.
  ///  * That means that calling rcl_publish() from multiple threads is allowed, but
  ///  * calling rcl_publish() at the same time as non-thread safe publisher
  ///  * functions is not, e.g. calling rcl_publish() and rcl_publisher_fini()
  ///  * concurrently is not allowed.
  ///  * Before calling rcl_publish() the message can change and after calling
  ///  * rcl_publish() the message can change, but it cannot be changed during the
  ///  * publish call.
  ///  * The same `ros_message`, however, can be passed to multiple calls of
  ///  * rcl_publish() simultaneously, even if the publishers differ.
  ///  * The `ros_message` is unmodified by rcl_publish().
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///  *
  ///  * \param[in] publisher handle to the publisher which will do the publishing
  ///  * \param[in] ros_message type-erased pointer to the ROS message
  ///  * \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  ///  * \return `RCL_RET_OK` if the message was published successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_publish(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rcl_publish(
      publisher,
      ros_message,
      allocation,
    );
  }

  late final _rcl_publish_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publish>>('rcl_publish');
  late final _dart_rcl_publish _rcl_publish =
      _rcl_publish_ptr.asFunction<_dart_rcl_publish>();

  /// Publish a serialized message on a topic using a publisher.
  /// /**
  ///  * It is the job of the caller to ensure that the type of the serialized message
  ///  * parameter and the type associate with the publisher (via the type support)
  ///  * match.
  ///  * Even though this call to publish takes an already serialized serialized message,
  ///  * the publisher has to register its type as a ROS known message type.
  ///  * Passing a serialized message from a different type leads to undefined behavior on the subscriber side.
  ///  * The publish call might be able to send any abitrary serialized message, it is however
  ///  * not garantueed that the subscriber side successfully deserializes this byte stream.
  ///  *
  ///  * Apart from this, the `publish_serialized` function has the same behavior as `rcl_publish`
  ///  * expect that no serialization step is done.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///  *
  ///  * \param[in] publisher handle to the publisher which will do the publishing
  ///  * \param[in] serialized_message  pointer to the already serialized message in raw form
  ///  * \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  ///  * \return `RCL_RET_OK` if the message was published successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_publish_serialized_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rcl_publish_serialized_message(
      publisher,
      serialized_message,
      allocation,
    );
  }

  late final _rcl_publish_serialized_message_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publish_serialized_message>>(
          'rcl_publish_serialized_message');
  late final _dart_rcl_publish_serialized_message
      _rcl_publish_serialized_message = _rcl_publish_serialized_message_ptr
          .asFunction<_dart_rcl_publish_serialized_message>();

  /// Publish a loaned message on a topic using a publisher.
  /// /**
  ///  * A previously borrowed loaned message can be sent via this call to `rcl_publish_loaned_message`.
  ///  * By calling this function, the ownership of the loaned message is getting transferred back
  ///  * to the middleware.
  ///  * The pointer to the `ros_message` is not guaranteed to be valid after as the middleware
  ///  * migth deallocate the memory for this message internally.
  ///  * It is thus recommended to call this function only in combination with
  ///  * \sa `rcl_borrow_loaned_message`.
  ///  *
  ///  * Apart from this, the `publish_loaned_message` function has the same behavior as `rcl_publish`
  ///  * except that no serialization step is done.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No [0]
  ///  * Thread-Safe        | Yes [1]
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  * <i>[0] the middleware might deallocate the loaned message.
  ///  * The RCL function however does not allocate any memory.</i>
  ///  * <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///  *
  ///  * \param[in] publisher handle to the publisher which will do the publishing
  ///  * \param[in] ros_message  pointer to the previously borrow loaned message
  ///  * \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  ///  * \return `RCL_RET_OK` if the message was published successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  ///  * \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_publish_loaned_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return _rcl_publish_loaned_message(
      publisher,
      ros_message,
      allocation,
    );
  }

  late final _rcl_publish_loaned_message_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publish_loaned_message>>(
          'rcl_publish_loaned_message');
  late final _dart_rcl_publish_loaned_message _rcl_publish_loaned_message =
      _rcl_publish_loaned_message_ptr
          .asFunction<_dart_rcl_publish_loaned_message>();

  /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
  /// /**
  ///  * If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
  ///  * this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
  ///  * of the system that this Node is still alive.
  ///  * This function must be called at least as often as the qos_profile's liveliness_lease_duration
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher handle to the publisher that needs liveliness to be asserted
  ///  * \return `RCL_RET_OK` if the liveliness assertion was completed successfully, or
  ///  * \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_publisher_assert_liveliness(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_assert_liveliness(
      publisher,
    );
  }

  late final _rcl_publisher_assert_liveliness_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_assert_liveliness>>(
          'rcl_publisher_assert_liveliness');
  late final _dart_rcl_publisher_assert_liveliness
      _rcl_publisher_assert_liveliness = _rcl_publisher_assert_liveliness_ptr
          .asFunction<_dart_rcl_publisher_assert_liveliness>();

  /// Get the topic name for the publisher.
  /// /**
  ///  * This function returns the publisher's internal topic name string.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - publisher is `NULL`
  ///  *   - publisher is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned string is only valid as long as the rcl_publisher_t is valid.
  ///  * The value of the string may change if the topic name changes, and therefore
  ///  * copying the string is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the publisher
  ///  * \return name string if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<ffi.Int8> rcl_publisher_get_topic_name(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_topic_name(
      publisher,
    );
  }

  late final _rcl_publisher_get_topic_name_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_get_topic_name>>(
          'rcl_publisher_get_topic_name');
  late final _dart_rcl_publisher_get_topic_name _rcl_publisher_get_topic_name =
      _rcl_publisher_get_topic_name_ptr
          .asFunction<_dart_rcl_publisher_get_topic_name>();

  /// Return the rcl publisher options.
  /// /**
  ///  * This function returns the publisher's internal options struct.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - publisher is `NULL`
  ///  *   - publisher is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned struct is only valid as long as the rcl_publisher_t is valid.
  ///  * The values in the struct may change if the options of the publisher change,
  ///  * and therefore copying the struct is recommended if this is a concern.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the publisher
  ///  * \return options struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_publisher_options_t> rcl_publisher_get_options(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_options(
      publisher,
    );
  }

  late final _rcl_publisher_get_options_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_get_options>>(
          'rcl_publisher_get_options');
  late final _dart_rcl_publisher_get_options _rcl_publisher_get_options =
      _rcl_publisher_get_options_ptr
          .asFunction<_dart_rcl_publisher_get_options>();

  /// Return the rmw publisher handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - publisher is `NULL`
  ///  *   - publisher is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned handle is made invalid if the publisher is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * publisher as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the publisher using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \return rmw publisher handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_publisher_t> rcl_publisher_get_rmw_handle(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_rmw_handle(
      publisher,
    );
  }

  late final _rcl_publisher_get_rmw_handle_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_get_rmw_handle>>(
          'rcl_publisher_get_rmw_handle');
  late final _dart_rcl_publisher_get_rmw_handle _rcl_publisher_get_rmw_handle =
      _rcl_publisher_get_rmw_handle_ptr
          .asFunction<_dart_rcl_publisher_get_rmw_handle>();

  /// Return the context associated with this publisher.
  /// /**
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - publisher is `NULL`
  ///  *   - publisher is invalid (never called init, called fini, etc.)
  ///  *
  ///  * The returned context is made invalid if the publisher is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * Therefore it is recommended to get the handle from the publisher using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \return context if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rcl_context_t> rcl_publisher_get_context(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_context(
      publisher,
    );
  }

  late final _rcl_publisher_get_context_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_get_context>>(
          'rcl_publisher_get_context');
  late final _dart_rcl_publisher_get_context _rcl_publisher_get_context =
      _rcl_publisher_get_context_ptr
          .asFunction<_dart_rcl_publisher_get_context>();

  /// Return true if the publisher is valid, otherwise false.
  /// /**
  ///  * The bool returned is `false` if `publisher` is invalid.
  ///  * The bool returned is `true` otherwise.
  ///  * In the case where `false` is to be returned, an error message is set.
  ///  * This function cannot fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \return `true` if `publisher` is valid, otherwise `false`
  ///  */
  bool rcl_publisher_is_valid(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_is_valid(
          publisher,
        ) !=
        0;
  }

  late final _rcl_publisher_is_valid_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_is_valid>>(
          'rcl_publisher_is_valid');
  late final _dart_rcl_publisher_is_valid _rcl_publisher_is_valid =
      _rcl_publisher_is_valid_ptr.asFunction<_dart_rcl_publisher_is_valid>();

  /// Return true if the publisher is valid except the context, otherwise false.
  /// /**
  ///  * This is used in clean up functions that need to access the publisher, but do
  ///  * not need use any functions with the context.
  ///  *
  ///  * It is identical to rcl_publisher_is_valid except it ignores the state of the
  ///  * context associated with the publisher.
  ///  * \sa rcl_publisher_is_valid()
  ///  */
  bool rcl_publisher_is_valid_except_context(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_is_valid_except_context(
          publisher,
        ) !=
        0;
  }

  late final _rcl_publisher_is_valid_except_context_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_is_valid_except_context>>(
          'rcl_publisher_is_valid_except_context');
  late final _dart_rcl_publisher_is_valid_except_context
      _rcl_publisher_is_valid_except_context =
      _rcl_publisher_is_valid_except_context_ptr
          .asFunction<_dart_rcl_publisher_is_valid_except_context>();

  /// Get the number of subscriptions matched to a publisher.
  /// /**
  ///  * Used to get the internal count of subscriptions matched to a publisher.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Maybe [1]
  ///  * Lock-Free          | Maybe [1]
  ///  * <i>[1] only if the underlying rmw doesn't make use of this feature </i>
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \param[out] subscription_count number of matched subscriptions
  ///  * \return `RCL_RET_OK` if the count was retrieved, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_publisher_get_subscription_count(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Uint64> subscription_count,
  ) {
    return _rcl_publisher_get_subscription_count(
      publisher,
      subscription_count,
    );
  }

  late final _rcl_publisher_get_subscription_count_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_get_subscription_count>>(
          'rcl_publisher_get_subscription_count');
  late final _dart_rcl_publisher_get_subscription_count
      _rcl_publisher_get_subscription_count =
      _rcl_publisher_get_subscription_count_ptr
          .asFunction<_dart_rcl_publisher_get_subscription_count>();

  /// Get the actual qos settings of the publisher.
  /// /**
  ///  * Used to get the actual qos settings of the publisher.
  ///  * The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  ///  * can only be resolved after the creation of the publisher, and it
  ///  * depends on the underlying rmw implementation.
  ///  * If the underlying setting in use can't be represented in ROS terms,
  ///  * it will be set to RMW_*_UNKNOWN.
  ///  * The returned struct is only valid as long as the rcl_publisher_t is valid.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] publisher pointer to the rcl publisher
  ///  * \return qos struct if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_qos_profile_t> rcl_publisher_get_actual_qos(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_get_actual_qos(
      publisher,
    );
  }

  late final _rcl_publisher_get_actual_qos_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_get_actual_qos>>(
          'rcl_publisher_get_actual_qos');
  late final _dart_rcl_publisher_get_actual_qos _rcl_publisher_get_actual_qos =
      _rcl_publisher_get_actual_qos_ptr
          .asFunction<_dart_rcl_publisher_get_actual_qos>();

  /// Check if publisher instance can loan messages.
  /// /**
  ///  * Depending on the middleware and the message type, this will return true if the middleware
  ///  * can allocate a ROS message instance.
  ///  */
  bool rcl_publisher_can_loan_messages(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return _rcl_publisher_can_loan_messages(
          publisher,
        ) !=
        0;
  }

  late final _rcl_publisher_can_loan_messages_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_can_loan_messages>>(
          'rcl_publisher_can_loan_messages');
  late final _dart_rcl_publisher_can_loan_messages
      _rcl_publisher_can_loan_messages = _rcl_publisher_can_loan_messages_ptr
          .asFunction<_dart_rcl_publisher_can_loan_messages>();

  /// Return a rcl_event_t struct with members set to `NULL`.
  /// /**
  ///  * Should be called to get a null rcl_event_t before passing to
  ///  * rcl_event_init().
  ///  */
  rcl_event_t rcl_get_zero_initialized_event() {
    return _rcl_get_zero_initialized_event();
  }

  late final _rcl_get_zero_initialized_event_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_event>>(
          'rcl_get_zero_initialized_event');
  late final _dart_rcl_get_zero_initialized_event
      _rcl_get_zero_initialized_event = _rcl_get_zero_initialized_event_ptr
          .asFunction<_dart_rcl_get_zero_initialized_event>();

  /// Initialize an rcl_event_t with a publisher.
  /// /**
  ///  * Fill the rcl_event_t with the publisher and desired event_type.
  ///  *
  ///  * \param[in,out] event pointer to fill
  ///  * \param[in] publisher to get events from
  ///  * \param[in] event_type to listen for
  ///  * \return `RCL_RET_OK` if the rcl_event_t is filled, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_publisher_event_init(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<rcl_publisher_t> publisher,
    int event_type,
  ) {
    return _rcl_publisher_event_init(
      event,
      publisher,
      event_type,
    );
  }

  late final _rcl_publisher_event_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_publisher_event_init>>(
          'rcl_publisher_event_init');
  late final _dart_rcl_publisher_event_init _rcl_publisher_event_init =
      _rcl_publisher_event_init_ptr
          .asFunction<_dart_rcl_publisher_event_init>();

  /// Initialize an rcl_event_t with a subscription.
  /// /**
  ///  * Fill the rcl_event_t with the subscription and desired event_type.
  ///  *
  ///  * \param[in,out] event pointer to fill
  ///  * \param[in] subscription to get events from
  ///  * \param[in] event_type to listen for
  ///  * \return `RCL_RET_OK` if the rcl_event_t is filled, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_subscription_event_init(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<rcl_subscription_t> subscription,
    int event_type,
  ) {
    return _rcl_subscription_event_init(
      event,
      subscription,
      event_type,
    );
  }

  late final _rcl_subscription_event_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_subscription_event_init>>(
          'rcl_subscription_event_init');
  late final _dart_rcl_subscription_event_init _rcl_subscription_event_init =
      _rcl_subscription_event_init_ptr
          .asFunction<_dart_rcl_subscription_event_init>();

  /// Take event using the event handle.
  /// /**
  ///  * Take an event from the event handle.
  ///  *
  ///  * \param[in] event_handle event object to take from
  ///  * \param[in, out] event_info event info object to write taken data into
  ///  * \param[in, out] taken boolean flag indicating if an event was taken or not
  ///  * \return `RCL_RET_OK` if successful, or
  ///  * \return `RCL_RET_BAD_ALLOC` if memory allocation failed, or
  ///  * \return `RCL_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rcl_take_event(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<ffi.Void> event_info,
  ) {
    return _rcl_take_event(
      event,
      event_info,
    );
  }

  late final _rcl_take_event_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_take_event>>('rcl_take_event');
  late final _dart_rcl_take_event _rcl_take_event =
      _rcl_take_event_ptr.asFunction<_dart_rcl_take_event>();

  /// Finalize an event.
  /// /**
  ///  * Finalize an event.
  ///  *
  ///  * \param[in] event to finalize
  ///  * \return `RCL_RET_OK` if successful, or
  ///  * \return `RCL_RET_EVENT_INVALID` if event is null, or
  ///  * \return `RCL_RET_ERROR` if an unexpected error occurs.
  ///  */
  int rcl_event_fini(
    ffi.Pointer<rcl_event_t> event,
  ) {
    return _rcl_event_fini(
      event,
    );
  }

  late final _rcl_event_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_event_fini>>('rcl_event_fini');
  late final _dart_rcl_event_fini _rcl_event_fini =
      _rcl_event_fini_ptr.asFunction<_dart_rcl_event_fini>();

  /// Return the rmw event handle.
  /// /**
  ///  * The handle returned is a pointer to the internally held rmw handle.
  ///  * This function can fail, and therefore return `NULL`, if the:
  ///  *   - event is `NULL`
  ///  *   - event is invalid (never called init, called fini, or invalid node)
  ///  *
  ///  * The returned handle is made invalid if the event is finalized or if
  ///  * rcl_shutdown() is called.
  ///  * The returned handle is not guaranteed to be valid for the life time of the
  ///  * event as it may be finalized and recreated itself.
  ///  * Therefore it is recommended to get the handle from the event using
  ///  * this function each time it is needed and avoid use of the handle
  ///  * concurrently with functions that might change it.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] event pointer to the rcl event
  ///  * \return rmw event handle if successful, otherwise `NULL`
  ///  */
  ffi.Pointer<rmw_event_t> rcl_event_get_rmw_handle(
    ffi.Pointer<rcl_event_t> event,
  ) {
    return _rcl_event_get_rmw_handle(
      event,
    );
  }

  late final _rcl_event_get_rmw_handle_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_event_get_rmw_handle>>(
          'rcl_event_get_rmw_handle');
  late final _dart_rcl_event_get_rmw_handle _rcl_event_get_rmw_handle =
      _rcl_event_get_rmw_handle_ptr
          .asFunction<_dart_rcl_event_get_rmw_handle>();

  /// Return a rmw_names_and_types_t struct with members initialized to `NULL`.
  rmw_names_and_types_t rmw_get_zero_initialized_names_and_types() {
    return _rmw_get_zero_initialized_names_and_types();
  }

  late final _rmw_get_zero_initialized_names_and_types_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_zero_initialized_names_and_types>>(
          'rmw_get_zero_initialized_names_and_types');
  late final _dart_rmw_get_zero_initialized_names_and_types
      _rmw_get_zero_initialized_names_and_types =
      _rmw_get_zero_initialized_names_and_types_ptr
          .asFunction<_dart_rmw_get_zero_initialized_names_and_types>();

  /// Check that a rmw_topic_names_and_types_t struct is zero initialized.
  int rmw_names_and_types_check_zero(
    ffi.Pointer<rmw_names_and_types_t> names_and_types,
  ) {
    return _rmw_names_and_types_check_zero(
      names_and_types,
    );
  }

  late final _rmw_names_and_types_check_zero_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_names_and_types_check_zero>>(
          'rmw_names_and_types_check_zero');
  late final _dart_rmw_names_and_types_check_zero
      _rmw_names_and_types_check_zero = _rmw_names_and_types_check_zero_ptr
          .asFunction<_dart_rmw_names_and_types_check_zero>();

  /// Initialize a rmw_names_and_types_t object.
  /// /**
  ///  * This function initializes the string array for the names and allocates space
  ///  * for all the string arrays for the types according to the given size, but
  ///  * it does not initialize the string array for each setup of types.
  ///  * However, the string arrays for each set of types is zero initialized.
  ///  *
  ///  * \param[inout] names_and_types object to be initialized
  ///  * \param[in] size the number of names and sets of types to be stored
  ///  * \param[in] allocator to be used to allocate and deallocate memory
  ///  * \returns `RMW_RET_OK` on successfully running the check, or
  ///  * \returns `RMW_RET_INVALID_ARGUMENT` if names_and_types is NULL, or
  ///  * \returns `RMW_BAD_ALLOC` if memory allocation fails, or
  ///  * \returns `RMW_RET_ERROR` when an unspecified error occurs.
  ///  */
  int rmw_names_and_types_init(
    ffi.Pointer<rmw_names_and_types_t> names_and_types,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rmw_names_and_types_init(
      names_and_types,
      size,
      allocator,
    );
  }

  late final _rmw_names_and_types_init_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_names_and_types_init>>(
          'rmw_names_and_types_init');
  late final _dart_rmw_names_and_types_init _rmw_names_and_types_init =
      _rmw_names_and_types_init_ptr
          .asFunction<_dart_rmw_names_and_types_init>();

  /// Finalize a rmw_names_and_types_t object.
  /// /**
  ///  * The names_and_types_t objects are populated by one of the
  ///  * rmw_get_*_names_and_types() functions.
  ///  * During which memory is allocated to store the names and types.
  ///  * This function will reclaim any resources within the object so it is safe
  ///  * to destroy without leaking memory.
  ///  *
  ///  * The allocator within the rmw_names_and_types_t object is used to deallocate
  ///  * memory.
  ///  *
  ///  * \param[inout] names_and_types object to be finalized
  ///  * \returns `RMW_RET_OK` on successfully running the check, or
  ///  * \returns `RMW_RET_INVALID_ARGUMENT` if names_and_types is NULL, or
  ///  * \returns `RMW_RET_ERROR` when an unspecified error occurs.
  ///  */
  int rmw_names_and_types_fini(
    ffi.Pointer<rmw_names_and_types_t> names_and_types,
  ) {
    return _rmw_names_and_types_fini(
      names_and_types,
    );
  }

  late final _rmw_names_and_types_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_names_and_types_fini>>(
          'rmw_names_and_types_fini');
  late final _dart_rmw_names_and_types_fini _rmw_names_and_types_fini =
      _rmw_names_and_types_fini_ptr
          .asFunction<_dart_rmw_names_and_types_fini>();

  /// Return a list of topic names and their types.
  /// /**
  ///  * This function returns a list of topic names in the ROS graph and their types.
  ///  *
  ///  * The node parameter must not be `NULL`, and must point to a valid node.
  ///  *
  ///  * The topic_names_and_types parameter must be allocated and zero initialized.
  ///  * The topic_names_and_types is the output for this function, and contains
  ///  * allocated memory.
  ///  * Therefore, it should be passed to rmw_names_and_types_fini() when
  ///  * it is no longer needed.
  ///  * Failing to do so will result in leaked memory.
  ///  *
  ///  * There may be some demangling that occurs when listing the topics from the
  ///  * middleware implementation.
  ///  * This is the mechanism by which this function can discriminate between ROS
  ///  * topics, non-ROS topics, and topics which may be used to implement other
  ///  * concepts like ROS Services.
  ///  *
  ///  * For example, if the underlying implementation is DDS or RTPS, ROS specific
  ///  * prefixes may be prepended to the user namespace, and the namespace may be
  ///  * stripped of leading and trailing slashes, see:
  ///  *
  ///  * http://design.ros2.org/articles/topic_and_service_names.html#ros-namespaces-with-dds-partitions
  ///  *
  ///  * As well as:
  ///  *
  ///  * http://design.ros2.org/articles/topic_and_service_names.html#communicating-with-non-ros-topics
  ///  *
  ///  * If the no_demangle argument is true, then the topic names given by the
  ///  * middleware will be returned without any demangling or filtering.
  ///  * For example, the ROS topic `/foo` may be returned as `rt/foo` or the DDS
  ///  * topic (non-ROS topic) with a partition list `['foo', 'bar']` and topic `baz`
  ///  * may be returned as `foo/baz` (note that only the first partition is used but
  ///  * it is still concatenated to the topic).
  ///  *
  ///  * \param[in] node the handle to the node being used to query the ROS graph
  ///  * \param[in] allocator allocator to be used when allocating space for strings
  ///  * \param[in] no_demangle if true, list all topics without any demangling
  ///  * \param[out] topic_names_and_types list of topic names and their types
  ///  * \return `RMW_RET_OK` if the query was successful, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if the node is invalid, or
  ///  * \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  ///  * \return `RMW_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rmw_get_topic_names_and_types(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rcutils_allocator_t> allocator,
    bool no_demangle,
    ffi.Pointer<rmw_names_and_types_t> topic_names_and_types,
  ) {
    return _rmw_get_topic_names_and_types(
      node,
      allocator,
      no_demangle ? 1 : 0,
      topic_names_and_types,
    );
  }

  late final _rmw_get_topic_names_and_types_ptr =
      _lookup<ffi.NativeFunction<_c_rmw_get_topic_names_and_types>>(
          'rmw_get_topic_names_and_types');
  late final _dart_rmw_get_topic_names_and_types
      _rmw_get_topic_names_and_types = _rmw_get_topic_names_and_types_ptr
          .asFunction<_dart_rmw_get_topic_names_and_types>();

  /// Do lexical analysis on a string.
  /// /**
  ///  * This function analyzes a string to see if it starts with a valid lexeme.
  ///  * If the string does not begin with a valid lexeme then lexeme will be RCL_LEXEME_NONE, and the
  ///  * length will be set to include the character that made it impossible.
  ///  * If the first character is '\0' then lexeme will be RCL_LEXEME_EOF.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] text The string to analyze.
  ///  * \param[out] lexeme The type of lexeme found in the string.
  ///  * \param[out] length The length of text in the string that constitutes the found lexeme.
  ///  * \return `RCL_RET_OK` if analysis is successful regardless whether a valid lexeme is found, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an internal bug is detected.
  ///  */
  int rcl_lexer_analyze(
    ffi.Pointer<ffi.Int8> text,
    ffi.Pointer<ffi.Int32> lexeme,
    ffi.Pointer<ffi.Uint64> length,
  ) {
    return _rcl_lexer_analyze(
      text,
      lexeme,
      length,
    );
  }

  late final _rcl_lexer_analyze_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_lexer_analyze>>('rcl_lexer_analyze');
  late final _dart_rcl_lexer_analyze _rcl_lexer_analyze =
      _rcl_lexer_analyze_ptr.asFunction<_dart_rcl_lexer_analyze>();

  /// Initialization of rcl.
  /// /**
  ///  * This function can be run any number of times, so long as the given context
  ///  * has been properly prepared.
  ///  *
  ///  * The given `rcl_context_t` must be zero initialized with the function
  ///  * `rcl_get_zero_initialized_context()` and must not be already initialized
  ///  * by this function.
  ///  * If the context is already initialized this function will fail and return the
  ///  * `RCL_RET_ALREADY_INIT` error code.
  ///  * A context may be initialized again after it has been finalized with the
  ///  * `rcl_shutdown()` function and zero initialized again with
  ///  * `rcl_get_zero_initialized_context()`.
  ///  *
  ///  * The `argc` and `argv` parameters may contain command line arguments for the
  ///  * program.
  ///  * rcl specific arguments will be parsed, but not removed.
  ///  * If `argc` is `0` and `argv` is `NULL` no parameters will be parsed.
  ///  *
  ///  * The `options` argument must be non-`NULL` and must have been initialized
  ///  * with `rcl_init_options_init()`.
  ///  * It is unmodified by this function, and the ownership is not transfered to
  ///  * the context, but instead a copy is made into the context for later reference.
  ///  * Therefore, the given options need to be cleaned up with
  ///  * `rcl_init_options_fini()` after this function returns.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \param[in] argc number of strings in argv
  ///  * \param[in] argv command line arguments; rcl specific arguments are removed
  ///  * \param[in] options options used during initialization
  ///  * \param[out] context resulting context object that represents this init
  ///  * \return `RCL_RET_OK` if initialization is successful, or
  ///  * \return `RCL_RET_ALREADY_INIT` if rcl_init has already been called, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_init(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
    ffi.Pointer<rcl_init_options_t> options,
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_init(
      argc,
      argv,
      options,
      context,
    );
  }

  late final _rcl_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_init>>('rcl_init');
  late final _dart_rcl_init _rcl_init =
      _rcl_init_ptr.asFunction<_dart_rcl_init>();

  /// Shutdown a given rcl context.
  /// /**
  ///  * The given context must have been initialized with `rcl_init()`.
  ///  * If not, this function will fail with `RCL_RET_ALREADY_SHUTDOWN`.
  ///  *
  ///  * When this function is called:
  ///  *  - Any rcl objects created using this context are invalidated.
  ///  *  - Functions called on invalid objects may or may not fail.
  ///  *  - Calls to `rcl_context_is_initialized()` will return `false`.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | Yes
  ///  * Uses Atomics       | Yes
  ///  * Lock-Free          | Yes [1]
  ///  * <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///  *
  ///  * \return `RCL_RET_OK` if the shutdown was completed successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ALREADY_SHUTDOWN` if the context is not currently valid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occur.
  ///  */
  int rcl_shutdown(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return _rcl_shutdown(
      context,
    );
  }

  late final _rcl_shutdown_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_shutdown>>('rcl_shutdown');
  late final _dart_rcl_shutdown _rcl_shutdown =
      _rcl_shutdown_ptr.asFunction<_dart_rcl_shutdown>();

  /// Return a rcl_wait_set_t struct with members set to `NULL`.
  rcl_wait_set_t rcl_get_zero_initialized_wait_set() {
    return _rcl_get_zero_initialized_wait_set();
  }

  late final _rcl_get_zero_initialized_wait_set_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_get_zero_initialized_wait_set>>(
          'rcl_get_zero_initialized_wait_set');
  late final _dart_rcl_get_zero_initialized_wait_set
      _rcl_get_zero_initialized_wait_set =
      _rcl_get_zero_initialized_wait_set_ptr
          .asFunction<_dart_rcl_get_zero_initialized_wait_set>();

  /// Initialize a rcl wait set with space for items to be waited on.
  /// /**
  ///  * This function allocates space for the subscriptions and other wait-able
  ///  * entities that can be stored in the wait set.
  ///  * It also sets the allocator to the given allocator and initializes the pruned
  ///  * member to be false.
  ///  *
  ///  * The wait_set struct should be allocated and initialized to `NULL`.
  ///  * If the wait_set is allocated but the memory is uninitialized the behavior is
  ///  * undefined.
  ///  * Calling this function on a wait set that has already been initialized will
  ///  * result in an error.
  ///  * A wait set can be reinitialized if rcl_wait_set_fini() was called on it.
  ///  *
  ///  * To use the default allocator use rcl_get_default_allocator().
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * #include <rcl/wait.h>
  ///  *
  ///  * rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
  ///  * rcl_ret_t ret =
  ///  *   rcl_wait_set_init(&wait_set, 42, 42, 42, 42, 42, &context, rcl_get_default_allocator());
  ///  * // ... error handling, then use it, then call the matching fini:
  ///  * ret = rcl_wait_set_fini(&wait_set);
  ///  * // ... error handling
  ///  * ```
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set the wait set struct to be initialized
  ///  * \param[in] number_of_subscriptions non-zero size of the subscriptions set
  ///  * \param[in] number_of_guard_conditions non-zero size of the guard conditions set
  ///  * \param[in] number_of_timers non-zero size of the timers set
  ///  * \param[in] number_of_clients non-zero size of the clients set
  ///  * \param[in] number_of_services non-zero size of the services set
  ///  * \param[in] context the context that the wait set should be associated with
  ///  * \param[in] allocator the allocator to use when allocating space in the sets
  ///  * \return `RCL_RET_OK` if the wait set is initialized successfully, or
  ///  * \return `RCL_RET_ALREADY_INIT` if the wait set is not zero initialized, or
  ///  * \return `RCL_RET_NOT_INIT` if the given context is invalid, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_wait_set_init(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int number_of_subscriptions,
    int number_of_guard_conditions,
    int number_of_timers,
    int number_of_clients,
    int number_of_services,
    int number_of_events,
    ffi.Pointer<rcl_context_t> context,
    rcutils_allocator_t allocator,
  ) {
    return _rcl_wait_set_init(
      wait_set,
      number_of_subscriptions,
      number_of_guard_conditions,
      number_of_timers,
      number_of_clients,
      number_of_services,
      number_of_events,
      context,
      allocator,
    );
  }

  late final _rcl_wait_set_init_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_init>>('rcl_wait_set_init');
  late final _dart_rcl_wait_set_init _rcl_wait_set_init =
      _rcl_wait_set_init_ptr.asFunction<_dart_rcl_wait_set_init>();

  /// Finalize a rcl wait set.
  /// /**
  ///  * Deallocates any memory in the wait set that was allocated in
  ///  * rcl_wait_set_init() using the allocator given in the initialization.
  ///  *
  ///  * Calling this function on a zero initialized wait set will do nothing and
  ///  * return RCL_RET_OK.
  ///  * Calling this function on uninitialized memory results in undefined behavior.
  ///  * After calling this function the wait set will once again be zero initialized
  ///  * and so calling this function or rcl_wait_set_init() immediately after will
  ///  * succeed.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set the wait set struct to be finalized.
  ///  * \return `RCL_RET_OK` if the finalization was successful, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_wait_set_fini(
    ffi.Pointer<rcl_wait_set_t> wait_set,
  ) {
    return _rcl_wait_set_fini(
      wait_set,
    );
  }

  late final _rcl_wait_set_fini_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_fini>>('rcl_wait_set_fini');
  late final _dart_rcl_wait_set_fini _rcl_wait_set_fini =
      _rcl_wait_set_fini_ptr.asFunction<_dart_rcl_wait_set_fini>();

  /// Retrieve the wait set's allocator.
  /// /**
  ///  * The allocator must be an allocated rcl_allocator_t struct, as the result is
  ///  * copied into this variable.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[in] wait_set the handle to the wait set
  ///  * \param[out] allocator the rcl_allocator_t struct to which the result is copied
  ///  * \return `RCL_RET_OK` if the allocator was successfully retrieved, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_wait_set_get_allocator(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return _rcl_wait_set_get_allocator(
      wait_set,
      allocator,
    );
  }

  late final _rcl_wait_set_get_allocator_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_get_allocator>>(
          'rcl_wait_set_get_allocator');
  late final _dart_rcl_wait_set_get_allocator _rcl_wait_set_get_allocator =
      _rcl_wait_set_get_allocator_ptr
          .asFunction<_dart_rcl_wait_set_get_allocator>();

  /// Store a pointer to the given subscription in the next empty spot in the set.
  /// /**
  ///  * This function does not guarantee that the subscription is not already in the
  ///  * wait set.
  ///  *
  ///  * Also add the rmw representation to the underlying rmw array and increment
  ///  * the rmw array count.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set struct in which the subscription is to be stored
  ///  * \param[in] subscription the subscription to be added to the wait set
  ///  * \param[out] index the index of the added subscription in the storage container.
  ///  *   This parameter is optional and can be set to `NULL` to be ignored.
  ///  * \return `RCL_RET_OK` if added successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or
  ///  * \return `RCL_RET_WAIT_SET_FULL` if the subscription set is full, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_wait_set_add_subscription(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return _rcl_wait_set_add_subscription(
      wait_set,
      subscription,
      index,
    );
  }

  late final _rcl_wait_set_add_subscription_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_add_subscription>>(
          'rcl_wait_set_add_subscription');
  late final _dart_rcl_wait_set_add_subscription
      _rcl_wait_set_add_subscription = _rcl_wait_set_add_subscription_ptr
          .asFunction<_dart_rcl_wait_set_add_subscription>();

  /// Remove (sets to `NULL`) all entities in the wait set.
  /// /**
  ///  * This function should be used after passing using rcl_wait, but before
  ///  * adding new entities to the set.
  ///  * Sets all of the entries in the underlying rmw array to `NULL`, and sets the
  ///  * count in the rmw array to `0`.
  ///  *
  ///  * Calling this on an uninitialized (zero initialized) wait set will fail.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | No
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set struct to have its entities cleared
  ///  * \return `RCL_RET_OK` if cleared successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_wait_set_clear(
    ffi.Pointer<rcl_wait_set_t> wait_set,
  ) {
    return _rcl_wait_set_clear(
      wait_set,
    );
  }

  late final _rcl_wait_set_clear_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_clear>>('rcl_wait_set_clear');
  late final _dart_rcl_wait_set_clear _rcl_wait_set_clear =
      _rcl_wait_set_clear_ptr.asFunction<_dart_rcl_wait_set_clear>();

  /// Reallocate space for entities in the wait set.
  /// /**
  ///  * This function will deallocate and reallocate the memory for all entity sets.
  ///  *
  ///  * A size of 0 will just deallocate the memory and assign `NULL` to the array.
  ///  *
  ///  * Allocation and deallocation is done with the allocator given during the
  ///  * wait set's initialization.
  ///  *
  ///  * After calling this function all values in the set will be set to `NULL`,
  ///  * effectively the same as calling rcl_wait_set_clear().
  ///  * Similarly, the underlying rmw representation is reallocated and reset:
  ///  * all entries are set to `NULL` and the count is set to zero.
  ///  *
  ///  * If the requested size matches the current size, no allocation will be done.
  ///  *
  ///  * This can be called on an uninitialized (zero initialized) wait set.
  ///  *
  ///  * <hr>
  ///  * Attribute          | Adherence
  ///  * ------------------ | -------------
  ///  * Allocates Memory   | Yes
  ///  * Thread-Safe        | No
  ///  * Uses Atomics       | No
  ///  * Lock-Free          | Yes
  ///  *
  ///  * \param[inout] wait_set struct to be resized
  ///  * \param[in] subscriptions_size a size for the new subscriptions set
  ///  * \param[in] guard_conditions_size a size for the new guard conditions set
  ///  * \param[in] timers_size a size for the new timers set
  ///  * \param[in] clients_size a size for the new clients set
  ///  * \param[in] services_size a size for the new services set
  ///  * \return `RCL_RET_OK` if resized successfully, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  ///  * \return `RCL_RET_ERROR` if an unspecified error occurs.
  ///  */
  int rcl_wait_set_resize(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int subscriptions_size,
    int guard_conditions_size,
    int timers_size,
    int clients_size,
    int services_size,
    int events_size,
  ) {
    return _rcl_wait_set_resize(
      wait_set,
      subscriptions_size,
      guard_conditions_size,
      timers_size,
      clients_size,
      services_size,
      events_size,
    );
  }

  late final _rcl_wait_set_resize_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_resize>>(
          'rcl_wait_set_resize');
  late final _dart_rcl_wait_set_resize _rcl_wait_set_resize =
      _rcl_wait_set_resize_ptr.asFunction<_dart_rcl_wait_set_resize>();

  /// Store a pointer to the guard condition in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_guard_condition(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return _rcl_wait_set_add_guard_condition(
      wait_set,
      guard_condition,
      index,
    );
  }

  late final _rcl_wait_set_add_guard_condition_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_add_guard_condition>>(
          'rcl_wait_set_add_guard_condition');
  late final _dart_rcl_wait_set_add_guard_condition
      _rcl_wait_set_add_guard_condition = _rcl_wait_set_add_guard_condition_ptr
          .asFunction<_dart_rcl_wait_set_add_guard_condition>();

  /// Store a pointer to the timer in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_timer(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return _rcl_wait_set_add_timer(
      wait_set,
      timer,
      index,
    );
  }

  late final _rcl_wait_set_add_timer_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_add_timer>>(
          'rcl_wait_set_add_timer');
  late final _dart_rcl_wait_set_add_timer _rcl_wait_set_add_timer =
      _rcl_wait_set_add_timer_ptr.asFunction<_dart_rcl_wait_set_add_timer>();

  /// Store a pointer to the client in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_client(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return _rcl_wait_set_add_client(
      wait_set,
      client,
      index,
    );
  }

  late final _rcl_wait_set_add_client_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_add_client>>(
          'rcl_wait_set_add_client');
  late final _dart_rcl_wait_set_add_client _rcl_wait_set_add_client =
      _rcl_wait_set_add_client_ptr.asFunction<_dart_rcl_wait_set_add_client>();

  /// Store a pointer to the service in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_service(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return _rcl_wait_set_add_service(
      wait_set,
      service,
      index,
    );
  }

  late final _rcl_wait_set_add_service_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_add_service>>(
          'rcl_wait_set_add_service');
  late final _dart_rcl_wait_set_add_service _rcl_wait_set_add_service =
      _rcl_wait_set_add_service_ptr
          .asFunction<_dart_rcl_wait_set_add_service>();

  /// Store a pointer to the event in the next empty spot in the set.
  /// /**
  ///  * This function behaves exactly the same as for subscriptions.
  ///  * \see rcl_wait_set_add_subscription
  ///  */
  int rcl_wait_set_add_event(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return _rcl_wait_set_add_event(
      wait_set,
      event,
      index,
    );
  }

  late final _rcl_wait_set_add_event_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait_set_add_event>>(
          'rcl_wait_set_add_event');
  late final _dart_rcl_wait_set_add_event _rcl_wait_set_add_event =
      _rcl_wait_set_add_event_ptr.asFunction<_dart_rcl_wait_set_add_event>();

  /// Block until the wait set is ready or until the timeout has been exceeded.
  /// /**
  ///  * This function will collect the items in the rcl_wait_set_t and pass them
  ///  * to the underlying rmw_wait function.
  ///  *
  ///  * The items in the wait set will be either left untouched or set to `NULL` after
  ///  * this function returns.
  ///  * Items that are not `NULL` are ready, where ready means different things based
  ///  * on the type of the item.
  ///  * For subscriptions this means there may be messages that can be taken, or
  ///  * perhaps that the state of the subscriptions has changed, in which case
  ///  * rcl_take may succeed but return with taken == false.
  ///  * For guard conditions this means the guard condition was triggered.
  ///  *
  ///  * Expected usage:
  ///  *
  ///  * ```c
  ///  * #include <rcl/rcl.h>
  ///  *
  ///  * // rcl_init() called successfully before here...
  ///  * rcl_node_t node;  // initialize this, see rcl_node_init()
  ///  * rcl_subscription_t sub1;  // initialize this, see rcl_subscription_init()
  ///  * rcl_subscription_t sub2;  // initialize this, see rcl_subscription_init()
  ///  * rcl_guard_condition_t gc1;  // initialize this, see rcl_guard_condition_init()
  ///  * rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
  ///  * rcl_ret_t ret = rcl_wait_set_init(&wait_set, 2, 1, 0, 0, 0, rcl_get_default_allocator());
  ///  * // ... error handling
  ///  * do {
  ///  *   ret = rcl_wait_set_clear(&wait_set);
  ///  *   // ... error handling
  ///  *   ret = rcl_wait_set_add_subscription(&wait_set, &sub1);
  ///  *   // ... error handling
  ///  *   ret = rcl_wait_set_add_subscription(&wait_set, &sub2);
  ///  *   // ... error handling
  ///  *   ret = rcl_wait_set_add_guard_condition(&wait_set, &gc1);
  ///  *   // ... error handling
  ///  *   ret = rcl_wait(&wait_set, RCL_MS_TO_NS(1000));  // 1000ms == 1s, passed as ns
  ///  *   if (ret == RCL_RET_TIMEOUT) {
  ///  *     continue;
  ///  *   }
  ///  *   for (int i = 0; i < wait_set.size_of_subscriptions; ++i) {
  ///  *     if (wait_set.subscriptions[i]) {
  ///  *       // The subscription is ready...
  ///  *     }
  ///  *   }
  ///  *   for (int i = 0; i < wait_set.size_of_guard_conditions; ++i) {
  ///  *     if (wait_set.guard_conditions[i]) {
  ///  *       // The subscription is ready...
  ///  *     }
  ///  *   }
  ///  * } while(check_some_condition());
  ///  * // ... fini node, and subscriptions and guard conditions...
  ///  * ret = rcl_wait_set_fini(&wait_set);
  ///  * // ... error handling
  ///  * ```
  ///  *
  ///  * The wait set struct must be allocated, initialized, and should have been
  ///  * cleared and then filled with items, e.g. subscriptions and guard conditions.
  ///  * Passing a wait set with no wait-able items in it will fail.
  ///  * `NULL` items in the sets are ignored, e.g. it is valid to have as input:
  ///  *  - `subscriptions[0]` = valid pointer
  ///  *  - `subscriptions[1]` = `NULL`
  ///  *  - `subscriptions[2]` = valid pointer
  ///  *  - `size_of_subscriptions` = 3
  ///  * Passing an uninitialized (zero initialized) wait set struct will fail.
  ///  * Passing a wait set struct with uninitialized memory is undefined behavior.
  ///  *
  ///  * The unit of timeout is nanoseconds.
  ///  * If the timeout is negative then this function will block indefinitely until
  ///  * something in the wait set is valid or it is interrupted.
  ///  * If the timeout is 0 then this function will be non-blocking; checking what's
  ///  * ready now, but not waiting if nothing is ready yet.
  ///  * If the timeout is greater than 0 then this function will return after
  ///  * that period of time has elapsed or the wait set becomes ready, which ever
  ///  * comes first.
  ///  * Passing a timeout struct with uninitialized memory is undefined behavior.
  ///  *
  ///  * This function is thread-safe for unique wait sets with unique contents.
  ///  * This function cannot operate on the same wait set in multiple threads, and
  ///  * the wait sets may not share content.
  ///  * For example, calling rcl_wait() in two threads on two different wait sets
  ///  * that both contain a single, shared guard condition is undefined behavior.
  ///  *
  ///  * \param[inout] wait_set the set of things to be waited on and to be pruned if not ready
  ///  * \param[in] timeout the duration to wait for the wait set to be ready, in nanoseconds
  ///  * \return `RCL_RET_OK` something in the wait set became ready, or
  ///  * \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  ///  * \return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or
  ///  * \return `RCL_RET_WAIT_SET_EMPTY` if the wait set contains no items, or
  ///  * \return `RCL_RET_TIMEOUT` if the timeout expired before something was ready, or
  ///  * \return `RCL_RET_ERROR` an unspecified error occur.
  ///  */
  int rcl_wait(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int timeout,
  ) {
    return _rcl_wait(
      wait_set,
      timeout,
    );
  }

  late final _rcl_wait_ptr =
      _lookup<ffi.NativeFunction<_c_rcl_wait>>('rcl_wait');
  late final _dart_rcl_wait _rcl_wait =
      _rcl_wait_ptr.asFunction<_dart_rcl_wait>();
}

class rosidl_service_type_support_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> typesupport_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<
      ffi.NativeFunction<rosidl_service_typesupport_handle_function>> func;
}

/// Encapsulation of an allocator.
/// /**
///  * The default allocator uses malloc(), free(), calloc(), and realloc().
///  * It can be obtained using rcutils_get_default_allocator().
///  *
///  * The allocator should be trivially copyable.
///  * Meaning that the struct should continue to work after being assignment
///  * copied into a new struct.
///  * Specifically the object pointed to by the state pointer should remain valid
///  * until all uses of the allocator have been made.
///  * Particular care should be taken when giving an allocator to functions like
///  * rcutils_*_init() where it is stored within another object and used later.
///  * Developers should note that, while the fields of a const-qualified allocator
///  * struct cannot be modified, the state of the allocator can be modified.
///  */
class rcutils_allocator_t extends ffi.Struct {
  /// Allocate memory, given a size and the `state` pointer.
  ///   /** An error should be indicated by returning `NULL`. */
  external ffi.Pointer<ffi.NativeFunction<_typedefC_1>> allocate;

  /// Deallocate previously allocated memory, mimicking free().
  ///   /** Also takes the `state` pointer. */
  external ffi.Pointer<ffi.NativeFunction<_typedefC_2>> deallocate;

  /// Reallocate if possible, otherwise it deallocates and allocates.
  ///   /**
  ///    * Also takes the `state` pointer.
  ///    *
  ///    * If unsupported then do deallocate and then allocate.
  ///    * This should behave as realloc() does, as opposed to posix's
  ///    * [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given
  ///    * by pointer will not be free'd automatically if realloc() fails.
  ///    * For reallocf-like behavior use rcutils_reallocf().
  ///    * This function must be able to take an input pointer of `NULL` and succeed.
  ///    */
  external ffi.Pointer<ffi.NativeFunction<_typedefC_3>> reallocate;

  /// Allocate memory with all elements set to zero, given a number of elements and their size.
  ///   /** An error should be indicated by returning `NULL`. */
  external ffi.Pointer<ffi.NativeFunction<_typedefC_4>> zero_allocate;

  /// Implementation defined state storage.
  ///   /**
  ///    * This is passed as the final parameter to other allocator functions.
  ///    * Note that the contents of the state can be modified even in const-qualified
  ///    * allocator objects.
  ///    */
  external ffi.Pointer<ffi.Void> state;
}

class __va_list_tag extends ffi.Struct {
  @ffi.Uint32()
  external int gp_offset;

  @ffi.Uint32()
  external int fp_offset;

  external ffi.Pointer<ffi.Void> overflow_arg_area;

  external ffi.Pointer<ffi.Void> reg_save_area;
}

/// Struct wrapping a fixed-size c string used for returning the formatted error string.
class rcutils_error_string_t extends ffi.Struct {
  @ffi.Array.multi([1024])
  external ffi.Array<ffi.Int8> str;
}

/// Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG().
class rcutils_error_state_t extends ffi.Struct {
  @ffi.Array.multi([768])
  external ffi.Array<ffi.Int8> message;

  @ffi.Array.multi([229])
  external ffi.Array<ffi.Int8> file;

  /// Line number of error.
  @ffi.Uint64()
  external int line_number;
}

class rcutils_array_list_impl_t extends ffi.Opaque {}

class rcutils_array_list_t extends ffi.Struct {
  external ffi.Pointer<rcutils_array_list_impl_t> impl;
}

class rcutils_char_array_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> buffer;

  /// if this is true, we may safely free/realloc the buffer as needed;
  /// otherwise we will leave the buffer alone and alloc new memory if
  /// more space is needed
  @ffi.Uint8()
  external int owns_buffer;

  @ffi.Uint64()
  external int buffer_length;

  @ffi.Uint64()
  external int buffer_capacity;

  external rcutils_allocator_t allocator;
}

class rcutils_hash_map_impl_t extends ffi.Opaque {}

class rcutils_hash_map_t extends ffi.Struct {
  external ffi.Pointer<rcutils_hash_map_impl_t> impl;
}

class rcutils_string_array_t extends ffi.Struct {
  @ffi.Uint64()
  external int size;

  external ffi.Pointer<ffi.Pointer<ffi.Int8>> data;

  external rcutils_allocator_t allocator;
}

class rcutils_string_map_impl_t extends ffi.Opaque {}

class rcutils_string_map_t extends ffi.Struct {
  external ffi.Pointer<rcutils_string_map_impl_t> impl;
}

class rcutils_uint8_array_t extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> buffer;

  @ffi.Uint64()
  external int buffer_length;

  @ffi.Uint64()
  external int buffer_capacity;

  external rcutils_allocator_t allocator;
}

/// The structure identifying the caller location in the source code.
class rcutils_log_location_t extends ffi.Struct {
  /// The name of the function containing the log call.
  external ffi.Pointer<ffi.Int8> function_name;

  /// The name of the source file containing the log call.
  external ffi.Pointer<ffi.Int8> file_name;

  /// The line number containing the log call.
  @ffi.Uint64()
  external int line_number;
}

/// The severity levels of log messages / loggers.
abstract class RCUTILS_LOG_SEVERITY {
  /// < The unset log level
  static const int RCUTILS_LOG_SEVERITY_UNSET = 0;

  /// < The debug log level
  static const int RCUTILS_LOG_SEVERITY_DEBUG = 10;

  /// < The info log level
  static const int RCUTILS_LOG_SEVERITY_INFO = 20;

  /// < The warn log level
  static const int RCUTILS_LOG_SEVERITY_WARN = 30;

  /// < The error log level
  static const int RCUTILS_LOG_SEVERITY_ERROR = 40;

  /// < The fatal log level
  static const int RCUTILS_LOG_SEVERITY_FATAL = 50;
}

class rmw_init_options_impl_t extends ffi.Opaque {}

/// Options structure used during rmw_init().
class rmw_init_options_t extends ffi.Struct {
  /// Locally (process local) unique ID that represents this init/shutdown cycle.
  ///   /**
  ///    * This should be set by the caller of `rmw_init()` to a number that is
  ///    * unique within this process.
  ///    * It is designed to be used with `rcl_init()` and `rcl_get_instance_id()`.
  ///    */
  @ffi.Uint64()
  external int instance_id;

  /// Implementation identifier, used to ensure two different implementations are not being mixed.
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// TODO(wjwwood): replace with rmw_allocator_t when that refactor happens
  /// Allocator used during internal allocation of init options, if needed.
  external rcutils_allocator_t allocator;

  /// Implementation defined init options.
  ///   /** May be NULL if there are no implementation defined options. */
  external ffi.Pointer<rmw_init_options_impl_t> impl;
}

class rmw_context_impl_t extends ffi.Opaque {}

/// Initialization context structure which is used to store init specific information.
class rmw_context_t extends ffi.Struct {
  /// Locally (process local) unique ID that represents this init/shutdown cycle.
  @ffi.Uint64()
  external int instance_id;

  /// Implementation identifier, used to ensure two different implementations are not being mixed.
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// Implementation defined context information.
  ///   /** May be NULL if there is no implementation defined context information. */
  external ffi.Pointer<rmw_context_impl_t> impl;
}

class rmw_loaned_message_sequence_t extends ffi.Struct {
  external ffi.Pointer<ffi.Void> message_sequence;

  @ffi.Uint64()
  external int size;

  @ffi.Uint64()
  external int capacity;
}

class rmw_node_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<ffi.Int8> name;

  external ffi.Pointer<ffi.Int8> namespace_;

  external ffi.Pointer<rmw_context_t> context;
}

/// Options that can be used to configure the creation of a publisher in rmw.
class rmw_publisher_options_t extends ffi.Struct {
  /// Used to pass rmw implementation specific resources during publisher creation.
  ///   /**
  ///    * This field is type erased (rather than forward declared) because it will
  ///    * usually be a non-owned reference to an language specific object, e.g.
  ///    * C++ it may be a polymorphic class that only the rmw implementation can use.
  ///    *
  ///    * The resource pointed to here needs to outlive this options structure, and
  ///    * any rmw_publisher objects that are created using it, as they copy this
  ///    * structure and may use this payload throughout their lifetime.
  ///    */
  external ffi.Pointer<ffi.Void> rmw_specific_publisher_payload;
}

class rmw_publisher_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<ffi.Int8> topic_name;

  /// Publisher options.
  ///   /**
  ///    * The options structure passed to rmw_create_publisher() should be
  ///    * assigned to this field by the rmw implementation.
  ///    * The fields should not be modified after creation, but
  ///    * the contents of the options structure may or may not be const, i.e.
  ///    * shallow const-ness.
  ///    * This field is not marked const to avoid any const casting during setup.
  ///    */
  external rmw_publisher_options_t options;

  @ffi.Uint8()
  external int can_loan_messages;
}

/// Options that can be used to configure the creation of a subscription in rmw.
class rmw_subscription_options_t extends ffi.Struct {
  /// Used to pass rmw implementation specific resources during subscription creation.
  ///   /**
  ///    * All the same details and restrictions of this field in
  ///    * rmw_publisher_options_t apply to this struct as well.
  ///    *
  ///    * \sa rmw_publisher_options_t.rmw_specific_publisher_payload
  ///    */
  external ffi.Pointer<ffi.Void> rmw_specific_subscription_payload;

  /// If true then the middleware should not deliver data from local publishers.
  ///   /**
  ///    * This setting is most often used when data should only be received from
  ///    * remote nodes, especially to avoid "double delivery" when both intra- and
  ///    * inter- process communication is taking place.
  ///    *
  ///    * \TODO(wjwwood): nail this down when participant mapping is sorted out.
  ///    *   See: https://github.com/ros2/design/pull/250
  ///    *
  ///    * The definition of local is somewhat vague at the moment.
  ///    * Right now it means local to the node, and that definition works best, but
  ///    * may become more complicated when/if participants map to a context instead.
  ///    */
  @ffi.Uint8()
  external int ignore_local_publications;
}

class rmw_subscription_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<ffi.Int8> topic_name;

  /// Subscription options.
  ///   /**
  ///    * The options structure passed to rmw_create_subscription() should be
  ///    * assigned to this field by the rmw implementation.
  ///    * The fields should not be modified after creation, but
  ///    * the contents of the options structure may or may not be const, i.e.
  ///    * shallow const-ness.
  ///    * This field is not marked const to avoid any const casting during setup.
  ///    */
  external rmw_subscription_options_t options;

  @ffi.Uint8()
  external int can_loan_messages;
}

class rmw_service_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<ffi.Int8> service_name;
}

class rmw_client_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<ffi.Int8> service_name;
}

class rmw_guard_condition_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<rmw_context_t> context;
}

class rmw_publisher_allocation_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<ffi.Void> data;
}

class rmw_subscription_allocation_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<ffi.Void> data;
}

/// Array of subscriber handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific subscriptions.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of subscriptions represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
class rmw_subscriptions_t extends ffi.Struct {
  /// The number of subscribers represented by the array.
  @ffi.Uint64()
  external int subscriber_count;

  /// Pointer to an array of void * pointers of subscriptions.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> subscribers;
}

/// Array of service handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific services.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of services represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
class rmw_services_t extends ffi.Struct {
  /// The number of services represented by the array.
  @ffi.Uint64()
  external int service_count;

  /// Pointer to an array of void * pointers of services.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> services;
}

/// Array of client handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific clients.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of clients represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
class rmw_clients_t extends ffi.Struct {
  /// The number of clients represented by the array.
  @ffi.Uint64()
  external int client_count;

  /// Pointer to an array of void * pointers of clients.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> clients;
}

class rmw_events_t extends ffi.Struct {
  /// The number of events represented by the array.
  @ffi.Uint64()
  external int event_count;

  /// Pointer to an array of void * pointers of events.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> events;
}

/// Array of guard condition handles.
/// /**
///  * An array of void * pointers representing type-erased middleware-specific guard conditions.
///  * The number of non-null entries may be smaller than the allocated size of the array.
///  * The number of guard conditions represented may be smaller than the allocated size of the array.
///  * The creator of this struct is responsible for allocating and deallocating the array.
///  */
class rmw_guard_conditions_t extends ffi.Struct {
  /// The number of guard conditions represented by the array.
  @ffi.Uint64()
  external int guard_condition_count;

  /// Pointer to an array of void * pointers of guard conditions.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> guard_conditions;
}

class rmw_wait_set_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  external ffi.Pointer<rmw_guard_conditions_t> guard_conditions;

  external ffi.Pointer<ffi.Void> data;
}

class rmw_request_id_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Int8> writer_guid;

  @ffi.Int64()
  external int sequence_number;
}

class rmw_time_t extends ffi.Struct {
  @ffi.Uint64()
  external int sec;

  @ffi.Uint64()
  external int nsec;
}

abstract class rmw_security_enforcement_policy_t {
  static const int RMW_SECURITY_ENFORCEMENT_PERMISSIVE = 0;
  static const int RMW_SECURITY_ENFORCEMENT_ENFORCE = 1;
}

class rmw_node_security_options_t extends ffi.Struct {
  @ffi.Int32()
  external int enforce_security;

  external ffi.Pointer<ffi.Int8> security_root_path;
}

abstract class rmw_qos_reliability_policy_t {
  static const int RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT = 0;
  static const int RMW_QOS_POLICY_RELIABILITY_RELIABLE = 1;
  static const int RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT = 2;
  static const int RMW_QOS_POLICY_RELIABILITY_UNKNOWN = 3;
}

abstract class rmw_qos_history_policy_t {
  static const int RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT = 0;
  static const int RMW_QOS_POLICY_HISTORY_KEEP_LAST = 1;
  static const int RMW_QOS_POLICY_HISTORY_KEEP_ALL = 2;
  static const int RMW_QOS_POLICY_HISTORY_UNKNOWN = 3;
}

abstract class rmw_qos_durability_policy_t {
  static const int RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT = 0;
  static const int RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL = 1;
  static const int RMW_QOS_POLICY_DURABILITY_VOLATILE = 2;
  static const int RMW_QOS_POLICY_DURABILITY_UNKNOWN = 3;
}

abstract class rmw_qos_liveliness_policy_t {
  static const int RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT = 0;
  static const int RMW_QOS_POLICY_LIVELINESS_AUTOMATIC = 1;
  static const int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE = 2;
  static const int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = 3;
  static const int RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4;
}

/// ROS MiddleWare quality of service profile.
class rmw_qos_profile_t extends ffi.Struct {
  @ffi.Int32()
  external int history;

  /// Size of the message queue.
  @ffi.Uint64()
  external int depth;

  /// Reliabiilty QoS policy setting
  @ffi.Int32()
  external int reliability;

  /// Durability QoS policy setting
  @ffi.Int32()
  external int durability;

  /// The period at which messages are expected to be sent/received
  external rmw_time_t deadline;

  /// The age at which messages are considered expired and no longer valid
  external rmw_time_t lifespan;

  /// Liveliness QoS policy setting
  @ffi.Int32()
  external int liveliness;

  /// The time within which the RMW node or publisher must show that it is alive
  external rmw_time_t liveliness_lease_duration;

  /// If true, any ROS specific namespacing conventions will be circumvented.
  ///   /**
  ///    * In the case of DDS and topics, for example, this means the typical
  ///    * ROS specific prefix of `rt` would not be applied as described here:
  ///    *
  ///    *   http://design.ros2.org/articles/topic_and_service_names.html#ros-specific-namespace-prefix
  ///    *
  ///    * This might be useful when trying to directly connect a native DDS topic
  ///    * with a ROS 2 topic.
  ///    */
  @ffi.Uint8()
  external int avoid_ros_namespace_conventions;
}

class rmw_gid_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  @ffi.Array.multi([24])
  external ffi.Array<ffi.Uint8> data;
}

class rmw_message_info_t extends ffi.Struct {
  /// const rmw_time_t received_timestamp;
  external rmw_gid_t publisher_gid;

  @ffi.Uint8()
  external int from_intra_process;
}

class rmw_message_info_sequence_t extends ffi.Struct {
  external ffi.Pointer<rmw_message_info_t> message_info_sequence;

  @ffi.Uint64()
  external int size;

  @ffi.Uint64()
  external int capacity;
}

/// Type mapping of rcutils log severity types to rmw specific types.
abstract class rmw_log_severity_t {
  static const int RMW_LOG_SEVERITY_DEBUG = 10;
  static const int RMW_LOG_SEVERITY_INFO = 20;
  static const int RMW_LOG_SEVERITY_WARN = 30;
  static const int RMW_LOG_SEVERITY_ERROR = 40;
  static const int RMW_LOG_SEVERITY_FATAL = 50;
}

/// QoS Liveliness Changed information provided by a subscription.
class rmw_liveliness_changed_status_t extends ffi.Struct {
  /// The total number of currently active Publishers which publish to the topic associated with
  /// the Subscription.
  /// This count increases when a newly matched Publisher asserts its liveliness for the first time
  /// or when a Publisher previously considered to be not alive reasserts its liveliness.
  /// The count decreases when a Publisher considered alive fails to assert its liveliness and
  /// becomes not alive, whether because it was deleted normally or for some other reason.
  @ffi.Int32()
  external int alive_count;

  /// The total count of current Publishers which publish to the topic associated with the
  /// Subscription that are no longer asserting their liveliness.
  /// This count increases when a Publisher considered alive fails to assert its liveliness and
  /// becomes not alive for some reason other than the normal deletion of that Publisher.
  /// It decreases when a previously not alive Publisher either reasserts its liveliness or is
  /// deleted normally.
  @ffi.Int32()
  external int not_alive_count;

  /// The change in the alive_count since the status was last read.
  @ffi.Int32()
  external int alive_count_change;

  /// The change in the not_alive_count since the status was last read.
  @ffi.Int32()
  external int not_alive_count_change;
}

/// QoS Requested Deadline Missed information provided by a subscription.
class rmw_requested_deadline_missed_status_t extends ffi.Struct {
  /// Lifetime cumulative number of missed deadlines detected for any instance read by the
  /// subscription.
  /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
  /// by one for each instance for which data was not received.
  @ffi.Int32()
  external int total_count;

  /// The incremental number of deadlines detected since the status was read.
  @ffi.Int32()
  external int total_count_change;
}

/// QoS Liveliness Lost information provided by a publisher.
class rmw_liveliness_lost_status_t extends ffi.Struct {
  /// Lifetime cumulative number of times that a previously-alive Publisher became not alive due to
  /// a failure to actively signal its liveliness within its offered liveliness period.
  /// This count does not change when an already not alive Publisher simply remains not alive for
  /// another liveliness period.
  @ffi.Int32()
  external int total_count;

  /// The change in total_count since the last time the status was last read.
  @ffi.Int32()
  external int total_count_change;
}

/// QoS Deadline Missed information provided by a publisher.
class rmw_offered_deadline_missed_status_t extends ffi.Struct {
  /// Lifetime cumulative number of offered deadline periods elapsed during which a Publisher failed
  /// to provide data.
  /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
  /// by one.
  @ffi.Int32()
  external int total_count;

  /// The change in total_count since the last time the status was last read.
  @ffi.Int32()
  external int total_count_change;
}

/// \typedef rcl_bool_array_t
/// \brief Array of bool values
class rcl_bool_array_t extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> values;

  @ffi.Uint64()
  external int size;
}

/// \typedef rcl_int64_array_t
/// \brief Array of int64_t values
class rcl_int64_array_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int64> values;

  @ffi.Uint64()
  external int size;
}

/// \typedef rcl_double_array_t
/// \brief Array of double values
class rcl_double_array_t extends ffi.Struct {
  external ffi.Pointer<ffi.Double> values;

  @ffi.Uint64()
  external int size;
}

/// \typedef rcl_byte_array_t
/// \brief Array of byte values
class rcl_byte_array_t extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> values;

  @ffi.Uint64()
  external int size;
}

/// \typedef rcl_variant_t
/// \brief variant_t stores the value of a parameter
/// Only one pointer in this struct will store the value
class rcl_variant_t extends ffi.Struct {
  /// < If bool, gets stored here
  external ffi.Pointer<ffi.Uint8> bool_value;

  /// < If integer, gets stored here
  external ffi.Pointer<ffi.Int64> integer_value;

  /// < If double, gets stored here
  external ffi.Pointer<ffi.Double> double_value;

  /// < If string, gets stored here
  external ffi.Pointer<ffi.Int8> string_value;

  /// < If array of bytes
  external ffi.Pointer<rcl_byte_array_t> byte_array_value;

  /// < If array of bool's
  external ffi.Pointer<rcl_bool_array_t> bool_array_value;

  /// < If array of integers
  external ffi.Pointer<rcl_int64_array_t> integer_array_value;

  /// < If array of doubles
  external ffi.Pointer<rcl_double_array_t> double_array_value;

  /// < If array of strings
  external ffi.Pointer<rcutils_string_array_t> string_array_value;
}

/// \typedef rcl_node_params_t
/// \brief node_params_t stores all the parameters(key:value) of a single node
class rcl_node_params_t extends ffi.Struct {
  /// < Array of parameter names (keys)
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> parameter_names;

  /// < Array of coressponding parameter values
  external ffi.Pointer<rcl_variant_t> parameter_values;

  /// < Number of parameters in the node
  @ffi.Uint64()
  external int num_params;
}

/// \typedef rcl_params_t
/// \brief params_t stores all the parameters of all nodes of a process
class rcl_params_t extends ffi.Struct {
  /// < List of names of the node
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> node_names;

  /// <  Array of parameters
  external ffi.Pointer<rcl_node_params_t> params;

  /// < Number of nodes
  @ffi.Uint64()
  external int num_nodes;

  /// < Allocator used
  external rcutils_allocator_t allocator;
}

class rcl_arguments_impl_t extends ffi.Opaque {}

/// Hold output of parsing command line arguments.
class rcl_arguments_t extends ffi.Struct {
  /// Private implementation pointer.
  external ffi.Pointer<rcl_arguments_impl_t> impl;
}

class rcl_init_options_impl_t extends ffi.Opaque {}

/// Encapsulation of init options and implementation defined init options.
class rcl_init_options_t extends ffi.Struct {
  /// Implementation specific pointer.
  external ffi.Pointer<rcl_init_options_impl_t> impl;
}

class rcl_context_impl_t extends ffi.Opaque {}

/// Encapsulates the non-global state of an init/shutdown cycle.
/// /**
///  * The context is used in the creation of top level entities like nodes and
///  * guard conditions, as well as to shutdown a specific instance of init.
///  *
///  * Here is a diagram of a typical context's lifecycle:
///  *
///  * ```
///  *    +---------------+
///  *    |               |
///  * +--> uninitialized +---> rcl_get_zero_initialized_context() +
///  * |  |               |                                        |
///  * |  +---------------+                                        |
///  * |                                                           |
///  * |           +-----------------------------------------------+
///  * |           |
///  * |  +--------v---------+                +-----------------------+
///  * |  |                  |                |                       |
///  * |  | zero-initialized +-> rcl_init() +-> initialized and valid +-> rcl_shutdown() +
///  * |  |                  |                |                       |                  |
///  * |  +------------------+                +-----------------------+                  |
///  * |                                                                                 |
///  * |               +-----------------------------------------------------------------+
///  * |               |
///  * |  +------------v------------+
///  * |  |                         |
///  * |  | initialized but invalid +---> finalize all entities, then rcl_context_fini() +
///  * |  |                         |                                                    |
///  * |  +-------------------------+                                                    |
///  * |                                                                                 |
///  * +---------------------------------------------------------------------------------+
///  * ```
///  *
///  * A declared but not defined `rcl_context_t` instance is considered to be
///  * "uninitialized", and passing an uninitialized context to any functions will
///  * result in undefined behavior.
///  * Some functions, like `rcl_init()` require the context instance to be
///  * zero initialized (all members set to "zero" state) before use.
///  *
///  * Zero initialization of an `rcl_context_t` should be done with
///  * `rcl_get_zero_initialized_context()`, which ensures the context is in a safe
///  * state for initialization with `rcl_init()`.
///  *
///  * Initialization of an `rcl_context_t` should be done with `rcl_init()`, after
///  * which the context is considered both initialized and valid.
///  * After initialization it can be used in the creation of other entities like
///  * nodes and guard conditions.
///  *
///  * At any time the context can be invalidated by calling `rcl_shutdown()` on
///  * the `rcl_context_t`, after which the context is still initialized but now
///  * invalid.
///  *
///  * Invalidation indicates to other entities that the context was shutdown, but
///  * is still accessible for use during cleanup of themselves.
///  *
///  * After being invalidated, and after all of the entities which used it have
///  * been finalized, the context should be finalized with `rcl_context_fini()`.
///  *
///  * Finalizing the context while entities which have copies of it have not yet
///  * been finalized is undefined behavior.
///  * Therefore, the context's lifetime (between calls to `rcl_init()` and
///  * `rcl_context_fini()`) should exceed the lifetime of all entities which use
///  * it directly (e.g. nodes and guard conditions) or indirectly (e.g.
///  * subscriptions and topics).
///  */
class rcl_context_t extends ffi.Struct {
  /// Global arguments for all nodes which share this context.
  ///   /** Typically generated by the parsing of argc/argv in `rcl_init()`. */
  external rcl_arguments_t global_arguments;

  /// Implementation specific pointer.
  external ffi.Pointer<rcl_context_impl_t> impl;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint8> instance_id_storage;
}

/// Structure which encapsulates the options for creating a rcl_node_t.
class rcl_node_options_t extends ffi.Struct {
  /// If set, then this value overrides the ROS_DOMAIN_ID environment variable.
  ///   /**
  ///    * It defaults to RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID, which will cause the
  ///    * node to use the ROS domain ID set in the ROS_DOMAIN_ID environment
  ///    * variable, or on some systems 0 if the environment variable is not set.
  ///    *
  ///    * \todo TODO(wjwwood):
  ///    *   Should we put a limit on the ROS_DOMAIN_ID value, that way we can have
  ///    *   a safe value for the default RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID?
  ///    *   (currently max size_t)
  ///    */
  @ffi.Uint64()
  external int domain_id;

  /// Custom allocator used for internal allocations.
  external rcutils_allocator_t allocator;

  /// If false then only use arguments in this struct, otherwise use global arguments also.
  @ffi.Uint8()
  external int use_global_arguments;

  /// Command line arguments that apply only to this node.
  external rcl_arguments_t arguments;
}

class rcl_guard_condition_t extends ffi.Opaque {}

class rcl_node_impl_t extends ffi.Opaque {}

/// Structure which encapsulates a ROS Node.
class rcl_node_t extends ffi.Struct {
  /// Context associated with this node.
  external ffi.Pointer<rcl_context_t> context;

  /// Private implementation pointer.
  external ffi.Pointer<rcl_node_impl_t> impl;
}

/// Internal rcl client implementation struct.
class rcl_client_impl_t extends ffi.Opaque {}

/// Structure which encapsulates a ROS Client.
class rcl_client_t extends ffi.Struct {
  external ffi.Pointer<rcl_client_impl_t> impl;
}

/// Options available for a rcl_client_t.
class rcl_client_options_t extends ffi.Struct {
  /// Middleware quality of service settings for the client.
  external rmw_qos_profile_t qos;

  /// Custom allocator for the client, used for incidental allocations.
  ///   /** For default behavior (malloc/free), use: rcl_get_default_allocator() */
  external rcutils_allocator_t allocator;
}

/// Internal rcl guard condition implementation struct.
class rcl_guard_condition_impl_t extends ffi.Opaque {}

/// Options available for a rcl guard condition.
class rcl_guard_condition_options_t extends ffi.Struct {
  /// Custom allocator for the guard condition, used for internal allocations.
  external rcutils_allocator_t allocator;
}

/// Internal rcl implementation struct.
class rcl_service_impl_t extends ffi.Opaque {}

/// Structure which encapsulates a ROS Service.
class rcl_service_t extends ffi.Struct {
  external ffi.Pointer<rcl_service_impl_t> impl;
}

/// Options available for a rcl service.
class rcl_service_options_t extends ffi.Struct {
  /// Middleware quality of service settings for the service.
  external rmw_qos_profile_t qos;

  /// Custom allocator for the service, used for incidental allocations.
  ///   /** For default behavior (malloc/free), see: rcl_get_default_allocator() */
  external rcutils_allocator_t allocator;
}

class rosidl_message_type_support_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> typesupport_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi.Pointer<
      ffi.NativeFunction<rosidl_message_typesupport_handle_function>> func;
}

/// Internal rcl implementation struct.
class rcl_subscription_impl_t extends ffi.Opaque {}

/// Structure which encapsulates a ROS Subscription.
class rcl_subscription_t extends ffi.Struct {
  external ffi.Pointer<rcl_subscription_impl_t> impl;
}

/// Options available for a rcl subscription.
class rcl_subscription_options_t extends ffi.Struct {
  /// Middleware quality of service settings for the subscription.
  external rmw_qos_profile_t qos;

  /// Custom allocator for the subscription, used for incidental allocations.
  ///   /** For default behavior (malloc/free), see: rcl_get_default_allocator() */
  external rcutils_allocator_t allocator;

  /// rmw specific subscription options, e.g. the rmw implementation specific payload.
  external rmw_subscription_options_t rmw_subscription_options;
}

/// Time source type, used to indicate the source of a time measurement.
abstract class rcl_clock_type_t {
  static const int RCL_CLOCK_UNINITIALIZED = 0;
  static const int RCL_ROS_TIME = 1;
  static const int RCL_SYSTEM_TIME = 2;
  static const int RCL_STEADY_TIME = 3;
}

/// A duration of time, measured in nanoseconds and its source.
class rcl_duration_t extends ffi.Struct {
  @ffi.Int64()
  external int nanoseconds;
}

/// Enumeration to describe the type of time jump.
abstract class rcl_clock_change_t {
  /// The source before and after the jump is ROS_TIME.
  static const int RCL_ROS_TIME_NO_CHANGE = 1;

  /// The source switched to ROS_TIME from SYSTEM_TIME.
  static const int RCL_ROS_TIME_ACTIVATED = 2;

  /// The source switched to SYSTEM_TIME from ROS_TIME.
  static const int RCL_ROS_TIME_DEACTIVATED = 3;

  /// The source before and after the jump is SYSTEM_TIME.
  static const int RCL_SYSTEM_TIME_NO_CHANGE = 4;
}

/// Struct to describe a jump in time.
class rcl_time_jump_t extends ffi.Struct {
  /// Indicate whether or not the source of time changed.
  @ffi.Int32()
  external int clock_change;

  /// The new time minus the last time before the jump.
  external rcl_duration_t delta;
}

/// Describe the prerequisites for calling a time jump callback.
class rcl_jump_threshold_t extends ffi.Struct {
  /// True to call callback when the clock type changes.
  @ffi.Uint8()
  external int on_clock_change;

  /// A positive duration indicating the minimum jump forwards to be considered exceeded, or zero
  /// to disable.
  external rcl_duration_t min_forward;

  /// A negative duration indicating the minimum jump backwards to be considered exceeded, or zero
  /// to disable.
  external rcl_duration_t min_backward;
}

/// Struct to describe an added callback.
class rcl_jump_callback_info_t extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback;

  external rcl_jump_threshold_t threshold;

  external ffi.Pointer<ffi.Void> user_data;
}

/// Encapsulation of a time source.
class rcl_clock_t extends ffi.Struct {
  @ffi.Int32()
  external int type;

  /// An array of added jump callbacks.
  external ffi.Pointer<rcl_jump_callback_info_t> jump_callbacks;

  /// Number of callbacks in jump_callbacks.
  @ffi.Uint64()
  external int num_jump_callbacks;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_5>> get_now;

  /// void (*set_now) (rcl_time_point_value_t);
  external ffi.Pointer<ffi.Void> data;

  external rcutils_allocator_t allocator;
}

/// A single point in time, measured in nanoseconds, the reference point is based on the source.
class rcl_time_point_t extends ffi.Struct {
  @ffi.Int64()
  external int nanoseconds;

  @ffi.Int32()
  external int clock_type;
}

class rosidl_message_bounds_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> typesupport_identifier;

  external ffi.Pointer<ffi.Void> data;

  external ffi
      .Pointer<ffi.NativeFunction<rosidl_message_bounds_handle_function>> func;
}

class rcl_timer_impl_t extends ffi.Opaque {}

/// Structure which encapsulates a ROS Timer.
class rcl_timer_t extends ffi.Struct {
  /// Private implementation pointer.
  external ffi.Pointer<rcl_timer_impl_t> impl;
}

/// Internal rcl publisher implementation struct.
class rcl_publisher_impl_t extends ffi.Opaque {}

/// Structure which encapsulates a ROS Publisher.
class rcl_publisher_t extends ffi.Struct {
  external ffi.Pointer<rcl_publisher_impl_t> impl;
}

/// Options available for a rcl publisher.
class rcl_publisher_options_t extends ffi.Struct {
  /// Middleware quality of service settings for the publisher.
  external rmw_qos_profile_t qos;

  /// Custom allocator for the publisher, used for incidental allocations.
  ///   /** For default behavior (malloc/free), use: rcl_get_default_allocator() */
  external rcutils_allocator_t allocator;

  /// rmw specific publisher options, e.g. the rmw implementation specific payload.
  external rmw_publisher_options_t rmw_publisher_options;
}

abstract class rcl_publisher_event_type_t {
  static const int RCL_PUBLISHER_OFFERED_DEADLINE_MISSED = 0;
  static const int RCL_PUBLISHER_LIVELINESS_LOST = 1;
}

abstract class rcl_subscription_event_type_t {
  static const int RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED = 0;
  static const int RCL_SUBSCRIPTION_LIVELINESS_CHANGED = 1;
}

class rmw_event_t extends ffi.Opaque {}

/// Internal rcl implementation struct.
class rcl_event_impl_t extends ffi.Opaque {}

/// Structure which encapsulates a ROS QoS event handle.
class rcl_event_t extends ffi.Struct {
  external ffi.Pointer<rcl_event_impl_t> impl;
}

/// Associative array of topic or service names and types.
class rmw_names_and_types_t extends ffi.Struct {
  external rcutils_string_array_t names;

  /// The length of this array is the same as names.size
  external ffi.Pointer<rcutils_string_array_t> types;
}

/// Type of lexeme found by lexical analysis.
abstract class rcl_lexeme_t {
  /// Indicates no valid lexeme was found (end of input not reached)
  static const int RCL_LEXEME_NONE = 0;

  /// Indicates end of input has been reached
  static const int RCL_LEXEME_EOF = 1;

  /// ~/
  static const int RCL_LEXEME_TILDE_SLASH = 2;

  /// rosservice://
  static const int RCL_LEXEME_URL_SERVICE = 3;

  /// rostopic://
  static const int RCL_LEXEME_URL_TOPIC = 4;

  /// :
  static const int RCL_LEXEME_COLON = 5;

  /// __node
  static const int RCL_LEXEME_NODE = 6;

  /// __ns
  static const int RCL_LEXEME_NS = 7;

  /// :=
  static const int RCL_LEXEME_SEPARATOR = 8;

  /// \1
  static const int RCL_LEXEME_BR1 = 9;

  /// \2
  static const int RCL_LEXEME_BR2 = 10;

  /// \3
  static const int RCL_LEXEME_BR3 = 11;

  /// \4
  static const int RCL_LEXEME_BR4 = 12;

  /// \5
  static const int RCL_LEXEME_BR5 = 13;

  /// \6
  static const int RCL_LEXEME_BR6 = 14;

  /// \7
  static const int RCL_LEXEME_BR7 = 15;

  /// \8
  static const int RCL_LEXEME_BR8 = 16;

  /// \9
  static const int RCL_LEXEME_BR9 = 17;

  /// a name between slashes, must match (([a-zA-Z](_)?)|_)([0-9a-zA-Z](_)?)*
  static const int RCL_LEXEME_TOKEN = 18;

  /// /
  static const int RCL_LEXEME_FORWARD_SLASH = 19;

  /// *
  static const int RCL_LEXEME_WILD_ONE = 20;

  /// **
  static const int RCL_LEXEME_WILD_MULTI = 21;

  /// TODO(hidmic): remove when parameter names are standardized to
  /// use slashes in lieu of dots
  /// .
  static const int RCL_LEXEME_DOT = 22;
}

class rcl_wait_set_impl_t extends ffi.Opaque {}

/// Container for subscription's, guard condition's, etc to be waited on.
class rcl_wait_set_t extends ffi.Struct {
  /// Storage for subscription pointers.
  external ffi.Pointer<ffi.Pointer<rcl_subscription_t>> subscriptions;

  @ffi.Uint64()
  external int size_of_subscriptions;

  /// Storage for guard condition pointers.
  external ffi.Pointer<ffi.Pointer<rcl_guard_condition_t>> guard_conditions;

  @ffi.Uint64()
  external int size_of_guard_conditions;

  /// Storage for timer pointers.
  external ffi.Pointer<ffi.Pointer<rcl_timer_t>> timers;

  @ffi.Uint64()
  external int size_of_timers;

  /// Storage for client pointers.
  external ffi.Pointer<ffi.Pointer<rcl_client_t>> clients;

  @ffi.Uint64()
  external int size_of_clients;

  /// Storage for service pointers.
  external ffi.Pointer<ffi.Pointer<rcl_service_t>> services;

  @ffi.Uint64()
  external int size_of_services;

  /// Storage for event pointers.
  external ffi.Pointer<ffi.Pointer<rcl_event_t>> events;

  @ffi.Uint64()
  external int size_of_events;

  /// Implementation specific storage.
  external ffi.Pointer<rcl_wait_set_impl_t> impl;
}

const int RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT = 0;

const int RCUTILS_RET_OK = 0;

const int RCUTILS_RET_WARN = 1;

const int RCUTILS_RET_ERROR = 2;

const int RCUTILS_RET_BAD_ALLOC = 10;

const int RCUTILS_RET_INVALID_ARGUMENT = 11;

const int RCUTILS_RET_NOT_ENOUGH_SPACE = 12;

const int RCUTILS_RET_NOT_INITIALIZED = 13;

const int RCUTILS_RET_NOT_FOUND = 14;

const int RCUTILS_RET_STRING_MAP_ALREADY_INIT = 30;

const int RCUTILS_RET_STRING_MAP_INVALID = 31;

const int RCUTILS_RET_STRING_KEY_NOT_FOUND = 32;

const int RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID = 40;

const int RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID = 41;

const int RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES = 50;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH = 20;

const int RCUTILS_ERROR_FORMATTING_CHARACTERS = 6;

const int RCUTILS_ERROR_MESSAGE_MAX_LENGTH = 1024;

const int RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH = 768;

const int RCUTILS_ERROR_STATE_FILE_MAX_LENGTH = 229;

const int RCUTILS_LOGGING_SEPARATOR_CHAR = 46;

const String RCUTILS_LOGGING_SEPARATOR_STRING = '.';

const int RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL = 20;

const int RMW_RET_OK = 0;

const int RMW_RET_ERROR = 1;

const int RMW_RET_TIMEOUT = 2;

const int RMW_RET_UNSUPPORTED = 3;

const int RMW_RET_BAD_ALLOC = 10;

const int RMW_RET_INVALID_ARGUMENT = 11;

const int RMW_RET_INCORRECT_RMW_IMPLEMENTATION = 12;

const int RMW_RET_NODE_NAME_NON_EXISTENT = 203;

const int RMW_GID_STORAGE_SIZE = 24;

const int RCL_RET_OK = 0;

const int RCL_RET_ERROR = 1;

const int RCL_RET_TIMEOUT = 2;

const int RCL_RET_BAD_ALLOC = 10;

const int RCL_RET_INVALID_ARGUMENT = 11;

const int RCL_RET_UNSUPPORTED = 3;

const int RCL_RET_ALREADY_INIT = 100;

const int RCL_RET_NOT_INIT = 101;

const int RCL_RET_MISMATCHED_RMW_ID = 102;

const int RCL_RET_TOPIC_NAME_INVALID = 103;

const int RCL_RET_SERVICE_NAME_INVALID = 104;

const int RCL_RET_UNKNOWN_SUBSTITUTION = 105;

const int RCL_RET_ALREADY_SHUTDOWN = 106;

const int RCL_RET_NODE_INVALID = 200;

const int RCL_RET_NODE_INVALID_NAME = 201;

const int RCL_RET_NODE_INVALID_NAMESPACE = 202;

const int RCL_RET_NODE_NAME_NON_EXISTENT = 203;

const int RCL_RET_PUBLISHER_INVALID = 300;

const int RCL_RET_SUBSCRIPTION_INVALID = 400;

const int RCL_RET_SUBSCRIPTION_TAKE_FAILED = 401;

const int RCL_RET_CLIENT_INVALID = 500;

const int RCL_RET_CLIENT_TAKE_FAILED = 501;

const int RCL_RET_SERVICE_INVALID = 600;

const int RCL_RET_SERVICE_TAKE_FAILED = 601;

const int RCL_RET_TIMER_INVALID = 800;

const int RCL_RET_TIMER_CANCELED = 801;

const int RCL_RET_WAIT_SET_INVALID = 900;

const int RCL_RET_WAIT_SET_EMPTY = 901;

const int RCL_RET_WAIT_SET_FULL = 902;

const int RCL_RET_INVALID_REMAP_RULE = 1001;

const int RCL_RET_WRONG_LEXEME = 1002;

const int RCL_RET_INVALID_ROS_ARGS = 1003;

const int RCL_RET_INVALID_PARAM_RULE = 1010;

const int RCL_RET_INVALID_LOG_LEVEL_RULE = 1020;

const int RCL_RET_EVENT_INVALID = 2000;

const int RCL_RET_EVENT_TAKE_FAILED = 2001;

const String RCL_ROS_ARGS_FLAG = '--ros-args';

const String RCL_ROS_ARGS_EXPLICIT_END_TOKEN = '--';

const String RCL_PARAM_FLAG = '--param';

const String RCL_SHORT_PARAM_FLAG = '-p';

const String RCL_PARAM_FILE_FLAG = '--params-file';

const String RCL_REMAP_FLAG = '--remap';

const String RCL_SHORT_REMAP_FLAG = '-r';

const String RCL_LOG_LEVEL_FLAG = '--log-level';

const String RCL_EXTERNAL_LOG_CONFIG_FLAG = '--log-config-file';

const String RCL_LOG_STDOUT_FLAG_SUFFIX = 'stdout-logs';

const String RCL_LOG_ROSOUT_FLAG_SUFFIX = 'rosout-logs';

const String RCL_LOG_EXT_LIB_FLAG_SUFFIX = 'external-lib-logs';

const String RCL_LOG_LEVEL_ARG_RULE = '__log_level:=';

const String RCL_EXTERNAL_LOG_CONFIG_ARG_RULE = '__log_config_file:=';

const String RCL_LOG_DISABLE_STDOUT_ARG_RULE = '__log_disable_stdout:=';

const String RCL_LOG_DISABLE_ROSOUT_ARG_RULE = '__log_disable_rosout:=';

const String RCL_LOG_DISABLE_EXT_LIB_ARG_RULE = '__log_disable_external_lib:=';

const String RCL_PARAM_FILE_ARG_RULE = '__params:=';

const int RCL_CONTEXT_ATOMIC_INSTANCE_ID_STORAGE_SIZE = 8;

const int RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID = -1;

typedef _c_get_service_typesupport_handle
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_service_typesupport_handle
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_get_service_typesupport_handle_function
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_service_typesupport_handle_function
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_rcutils_get_zero_initialized_allocator = rcutils_allocator_t
    Function();

typedef _dart_rcutils_get_zero_initialized_allocator = rcutils_allocator_t
    Function();

typedef _c_rcutils_get_default_allocator = rcutils_allocator_t Function();

typedef _dart_rcutils_get_default_allocator = rcutils_allocator_t Function();

typedef _c_rcutils_allocator_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_allocator_is_valid = int Function(
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_reallocf = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> pointer,
  ffi.Uint64 size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_reallocf = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> pointer,
  int size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_snprintf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Uint64 buffer_size,
  ffi.Pointer<ffi.Int8> format,
);

typedef _dart_rcutils_snprintf = int Function(
  ffi.Pointer<ffi.Int8> buffer,
  int buffer_size,
  ffi.Pointer<ffi.Int8> format,
);

typedef _c_rcutils_vsnprintf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Uint64 buffer_size,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<__va_list_tag> args,
);

typedef _dart_rcutils_vsnprintf = int Function(
  ffi.Pointer<ffi.Int8> buffer,
  int buffer_size,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<__va_list_tag> args,
);

typedef _c_rcutils_initialize_error_handling_thread_local_storage = ffi.Int32
    Function(
  rcutils_allocator_t allocator,
);

typedef _dart_rcutils_initialize_error_handling_thread_local_storage = int
    Function(
  rcutils_allocator_t allocator,
);

typedef _c_rcutils_set_error_state = ffi.Void Function(
  ffi.Pointer<ffi.Int8> error_string,
  ffi.Pointer<ffi.Int8> file,
  ffi.Uint64 line_number,
);

typedef _dart_rcutils_set_error_state = void Function(
  ffi.Pointer<ffi.Int8> error_string,
  ffi.Pointer<ffi.Int8> file,
  int line_number,
);

typedef _c_rcutils_error_is_set = ffi.Uint8 Function();

typedef _dart_rcutils_error_is_set = int Function();

typedef _c_rcutils_get_error_state = ffi.Pointer<rcutils_error_state_t>
    Function();

typedef _dart_rcutils_get_error_state = ffi.Pointer<rcutils_error_state_t>
    Function();

typedef _c_rcutils_get_error_string = rcutils_error_string_t Function();

typedef _dart_rcutils_get_error_string = rcutils_error_string_t Function();

typedef _c_rcutils_reset_error = ffi.Void Function();

typedef _dart_rcutils_reset_error = void Function();

typedef _c_rcutils_get_zero_initialized_array_list = rcutils_array_list_t
    Function();

typedef _dart_rcutils_get_zero_initialized_array_list = rcutils_array_list_t
    Function();

typedef _c_rcutils_array_list_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Uint64 initial_capacity,
  ffi.Uint64 data_size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_array_list_init = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  int initial_capacity,
  int data_size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_array_list_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
);

typedef _dart_rcutils_array_list_fini = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
);

typedef _c_rcutils_array_list_add = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_array_list_add = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_array_list_set = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Uint64 index,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_array_list_set = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  int index,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_array_list_remove = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Uint64 index,
);

typedef _dart_rcutils_array_list_remove = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  int index,
);

typedef _c_rcutils_array_list_get = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Uint64 index,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_array_list_get = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  int index,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_array_list_get_size = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_rcutils_array_list_get_size = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_rcutils_get_zero_initialized_char_array = rcutils_char_array_t
    Function();

typedef _dart_rcutils_get_zero_initialized_char_array = rcutils_char_array_t
    Function();

typedef _c_rcutils_char_array_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Uint64 buffer_capacity,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_char_array_init = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  int buffer_capacity,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_char_array_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
);

typedef _dart_rcutils_char_array_fini = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
);

typedef _c_rcutils_char_array_resize = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Uint64 new_size,
);

typedef _dart_rcutils_char_array_resize = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  int new_size,
);

typedef _c_rcutils_char_array_expand_as_needed = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Uint64 new_size,
);

typedef _dart_rcutils_char_array_expand_as_needed = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  int new_size,
);

typedef _c_rcutils_char_array_vsprintf = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<__va_list_tag> args,
);

typedef _dart_rcutils_char_array_vsprintf = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<__va_list_tag> args,
);

typedef _c_rcutils_char_array_strncat = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 n,
);

typedef _dart_rcutils_char_array_strncat = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
  int n,
);

typedef _c_rcutils_char_array_strcat = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
);

typedef _dart_rcutils_char_array_strcat = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
);

typedef _c_rcutils_char_array_memcpy = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 n,
);

typedef _dart_rcutils_char_array_memcpy = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
  int n,
);

typedef _c_rcutils_char_array_strcpy = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
);

typedef _dart_rcutils_char_array_strcpy = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
);

typedef _c_rcutils_hash_map_string_hash_func = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> key_str,
);

typedef _dart_rcutils_hash_map_string_hash_func = int Function(
  ffi.Pointer<ffi.Void> key_str,
);

typedef _c_rcutils_hash_map_string_cmp_func = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> val1,
  ffi.Pointer<ffi.Void> val2,
);

typedef _dart_rcutils_hash_map_string_cmp_func = int Function(
  ffi.Pointer<ffi.Void> val1,
  ffi.Pointer<ffi.Void> val2,
);

typedef _c_rcutils_get_zero_initialized_hash_map = rcutils_hash_map_t
    Function();

typedef _dart_rcutils_get_zero_initialized_hash_map = rcutils_hash_map_t
    Function();

typedef rcutils_hash_map_key_hasher_t = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void>,
);

typedef rcutils_hash_map_key_cmp_t = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_rcutils_hash_map_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Uint64 initial_capacity,
  ffi.Uint64 key_size,
  ffi.Uint64 data_size,
  ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_hasher_t>>
      key_hashing_func,
  ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_cmp_t>> key_cmp_func,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_hash_map_init = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  int initial_capacity,
  int key_size,
  int data_size,
  ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_hasher_t>>
      key_hashing_func,
  ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_cmp_t>> key_cmp_func,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_hash_map_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
);

typedef _dart_rcutils_hash_map_fini = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
);

typedef _c_rcutils_hash_map_get_capacity = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Uint64> capacity,
);

typedef _dart_rcutils_hash_map_get_capacity = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Uint64> capacity,
);

typedef _c_rcutils_hash_map_get_size = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_rcutils_hash_map_get_size = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_rcutils_hash_map_set = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> value,
);

typedef _dart_rcutils_hash_map_set = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> value,
);

typedef _c_rcutils_hash_map_unset = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
);

typedef _dart_rcutils_hash_map_unset = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
);

typedef _c_rcutils_hash_map_key_exists = ffi.Uint8 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
);

typedef _dart_rcutils_hash_map_key_exists = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
);

typedef _c_rcutils_hash_map_get = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_hash_map_get = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_hash_map_get_next_key_and_data = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> previous_key,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_hash_map_get_next_key_and_data = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> previous_key,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_get_zero_initialized_string_array = rcutils_string_array_t
    Function();

typedef _dart_rcutils_get_zero_initialized_string_array = rcutils_string_array_t
    Function();

typedef _c_rcutils_string_array_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
  ffi.Uint64 size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_string_array_init = int Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
  int size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_string_array_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
);

typedef _dart_rcutils_string_array_fini = int Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
);

typedef _c_rcutils_string_array_cmp = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_array_t> lhs,
  ffi.Pointer<rcutils_string_array_t> rhs,
  ffi.Pointer<ffi.Int32> res,
);

typedef _dart_rcutils_string_array_cmp = int Function(
  ffi.Pointer<rcutils_string_array_t> lhs,
  ffi.Pointer<rcutils_string_array_t> rhs,
  ffi.Pointer<ffi.Int32> res,
);

typedef _c_rcutils_get_zero_initialized_string_map = rcutils_string_map_t
    Function();

typedef _dart_rcutils_get_zero_initialized_string_map = rcutils_string_map_t
    Function();

typedef _c_rcutils_string_map_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Uint64 initial_capacity,
  rcutils_allocator_t allocator,
);

typedef _dart_rcutils_string_map_init = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  int initial_capacity,
  rcutils_allocator_t allocator,
);

typedef _c_rcutils_string_map_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
);

typedef _dart_rcutils_string_map_fini = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
);

typedef _c_rcutils_string_map_get_capacity = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Uint64> capacity,
);

typedef _dart_rcutils_string_map_get_capacity = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Uint64> capacity,
);

typedef _c_rcutils_string_map_get_size = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_rcutils_string_map_get_size = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_rcutils_string_map_reserve = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Uint64 capacity,
);

typedef _dart_rcutils_string_map_reserve = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  int capacity,
);

typedef _c_rcutils_string_map_clear = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
);

typedef _dart_rcutils_string_map_clear = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
);

typedef _c_rcutils_string_map_set = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_rcutils_string_map_set = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_rcutils_string_map_set_no_resize = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_rcutils_string_map_set_no_resize = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_rcutils_string_map_unset = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_rcutils_string_map_unset = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_rcutils_string_map_key_exists = ffi.Uint8 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_rcutils_string_map_key_exists = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_rcutils_string_map_key_existsn = ffi.Uint8 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Uint64 key_length,
);

typedef _dart_rcutils_string_map_key_existsn = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  int key_length,
);

typedef _c_rcutils_string_map_get = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_rcutils_string_map_get = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_rcutils_string_map_getn = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Uint64 key_length,
);

typedef _dart_rcutils_string_map_getn = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  int key_length,
);

typedef _c_rcutils_string_map_get_next_key = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_rcutils_string_map_get_next_key = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_rcutils_string_map_copy = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> src_string_map,
  ffi.Pointer<rcutils_string_map_t> dst_string_map,
);

typedef _dart_rcutils_string_map_copy = int Function(
  ffi.Pointer<rcutils_string_map_t> src_string_map,
  ffi.Pointer<rcutils_string_map_t> dst_string_map,
);

typedef _c_rcutils_get_zero_initialized_uint8_array = rcutils_uint8_array_t
    Function();

typedef _dart_rcutils_get_zero_initialized_uint8_array = rcutils_uint8_array_t
    Function();

typedef _c_rcutils_uint8_array_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  ffi.Uint64 buffer_capacity,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_uint8_array_init = int Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  int buffer_capacity,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_uint8_array_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
);

typedef _dart_rcutils_uint8_array_fini = int Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
);

typedef _c_rcutils_uint8_array_resize = ffi.Int32 Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  ffi.Uint64 new_size,
);

typedef _dart_rcutils_uint8_array_resize = int Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  int new_size,
);

typedef _c_rcutils_system_time_now = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> now,
);

typedef _dart_rcutils_system_time_now = int Function(
  ffi.Pointer<ffi.Int64> now,
);

typedef _c_rcutils_steady_time_now = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> now,
);

typedef _dart_rcutils_steady_time_now = int Function(
  ffi.Pointer<ffi.Int64> now,
);

typedef _c_rcutils_time_point_value_as_nanoseconds_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> time_point,
  ffi.Pointer<ffi.Int8> str,
  ffi.Uint64 str_size,
);

typedef _dart_rcutils_time_point_value_as_nanoseconds_string = int Function(
  ffi.Pointer<ffi.Int64> time_point,
  ffi.Pointer<ffi.Int8> str,
  int str_size,
);

typedef _c_rcutils_time_point_value_as_seconds_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> time_point,
  ffi.Pointer<ffi.Int8> str,
  ffi.Uint64 str_size,
);

typedef _dart_rcutils_time_point_value_as_seconds_string = int Function(
  ffi.Pointer<ffi.Int64> time_point,
  ffi.Pointer<ffi.Int8> str,
  int str_size,
);

typedef _c_rcutils_logging_initialize_with_allocator = ffi.Int32 Function(
  rcutils_allocator_t allocator,
);

typedef _dart_rcutils_logging_initialize_with_allocator = int Function(
  rcutils_allocator_t allocator,
);

typedef _c_rcutils_logging_initialize = ffi.Int32 Function();

typedef _dart_rcutils_logging_initialize = int Function();

typedef _c_rcutils_logging_shutdown = ffi.Int32 Function();

typedef _dart_rcutils_logging_shutdown = int Function();

typedef _c_rcutils_logging_severity_level_from_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> severity_string,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Int32> severity,
);

typedef _dart_rcutils_logging_severity_level_from_string = int Function(
  ffi.Pointer<ffi.Int8> severity_string,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Int32> severity,
);

typedef rcutils_logging_output_handler_t = ffi.Void Function(
  ffi.Pointer<rcutils_log_location_t>,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Int64,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Pointer<__va_list_tag>>,
);

typedef _c_rcutils_logging_get_output_handler
    = ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>
        Function();

typedef _dart_rcutils_logging_get_output_handler
    = ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>
        Function();

typedef _c_rcutils_logging_set_output_handler = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>> function,
);

typedef _dart_rcutils_logging_set_output_handler = void Function(
  ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>> function,
);

typedef _c_rcutils_logging_format_message = ffi.Int32 Function(
  ffi.Pointer<rcutils_log_location_t> location,
  ffi.Int32 severity,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int64 timestamp,
  ffi.Pointer<ffi.Int8> msg,
  ffi.Pointer<rcutils_char_array_t> logging_output,
);

typedef _dart_rcutils_logging_format_message = int Function(
  ffi.Pointer<rcutils_log_location_t> location,
  int severity,
  ffi.Pointer<ffi.Int8> name,
  int timestamp,
  ffi.Pointer<ffi.Int8> msg,
  ffi.Pointer<rcutils_char_array_t> logging_output,
);

typedef _c_rcutils_logging_get_default_logger_level = ffi.Int32 Function();

typedef _dart_rcutils_logging_get_default_logger_level = int Function();

typedef _c_rcutils_logging_set_default_logger_level = ffi.Void Function(
  ffi.Int32 level,
);

typedef _dart_rcutils_logging_set_default_logger_level = void Function(
  int level,
);

typedef _c_rcutils_logging_get_logger_level = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_rcutils_logging_get_logger_level = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_rcutils_logging_get_logger_leveln = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Uint64 name_length,
);

typedef _dart_rcutils_logging_get_logger_leveln = int Function(
  ffi.Pointer<ffi.Int8> name,
  int name_length,
);

typedef _c_rcutils_logging_set_logger_level = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 level,
);

typedef _dart_rcutils_logging_set_logger_level = int Function(
  ffi.Pointer<ffi.Int8> name,
  int level,
);

typedef _c_rcutils_logging_logger_is_enabled_for = ffi.Uint8 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 severity,
);

typedef _dart_rcutils_logging_logger_is_enabled_for = int Function(
  ffi.Pointer<ffi.Int8> name,
  int severity,
);

typedef _c_rcutils_logging_get_logger_effective_level = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_rcutils_logging_get_logger_effective_level = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_rcutils_log = ffi.Void Function(
  ffi.Pointer<rcutils_log_location_t> location,
  ffi.Int32 severity,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> format,
);

typedef _dart_rcutils_log = void Function(
  ffi.Pointer<rcutils_log_location_t> location,
  int severity,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> format,
);

typedef _c_rcutils_logging_console_output_handler = ffi.Void Function(
  ffi.Pointer<rcutils_log_location_t> location,
  ffi.Int32 severity,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int64 timestamp,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<ffi.Pointer<__va_list_tag>> args,
);

typedef _dart_rcutils_logging_console_output_handler = void Function(
  ffi.Pointer<rcutils_log_location_t> location,
  int severity,
  ffi.Pointer<ffi.Int8> name,
  int timestamp,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<ffi.Pointer<__va_list_tag>> args,
);

typedef _c_rmw_get_zero_initialized_init_options = rmw_init_options_t
    Function();

typedef _dart_rmw_get_zero_initialized_init_options = rmw_init_options_t
    Function();

typedef _c_rmw_init_options_init = ffi.Int32 Function(
  ffi.Pointer<rmw_init_options_t> init_options,
  rcutils_allocator_t allocator,
);

typedef _dart_rmw_init_options_init = int Function(
  ffi.Pointer<rmw_init_options_t> init_options,
  rcutils_allocator_t allocator,
);

typedef _c_rmw_init_options_copy = ffi.Int32 Function(
  ffi.Pointer<rmw_init_options_t> src,
  ffi.Pointer<rmw_init_options_t> dst,
);

typedef _dart_rmw_init_options_copy = int Function(
  ffi.Pointer<rmw_init_options_t> src,
  ffi.Pointer<rmw_init_options_t> dst,
);

typedef _c_rmw_init_options_fini = ffi.Int32 Function(
  ffi.Pointer<rmw_init_options_t> init_options,
);

typedef _dart_rmw_init_options_fini = int Function(
  ffi.Pointer<rmw_init_options_t> init_options,
);

typedef _c_rmw_get_zero_initialized_context = rmw_context_t Function();

typedef _dart_rmw_get_zero_initialized_context = rmw_context_t Function();

typedef _c_rmw_init = ffi.Int32 Function(
  ffi.Pointer<rmw_init_options_t> options,
  ffi.Pointer<rmw_context_t> context,
);

typedef _dart_rmw_init = int Function(
  ffi.Pointer<rmw_init_options_t> options,
  ffi.Pointer<rmw_context_t> context,
);

typedef _c_rmw_shutdown = ffi.Int32 Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _dart_rmw_shutdown = int Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _c_rmw_context_fini = ffi.Int32 Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _dart_rmw_context_fini = int Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _c_rmw_get_zero_initialized_loaned_message_sequence
    = rmw_loaned_message_sequence_t Function();

typedef _dart_rmw_get_zero_initialized_loaned_message_sequence
    = rmw_loaned_message_sequence_t Function();

typedef _c_rcl_get_zero_initialized_arguments = rcl_arguments_t Function();

typedef _dart_rcl_get_zero_initialized_arguments = rcl_arguments_t Function();

typedef _c_rcl_parse_arguments = ffi.Int32 Function(
  ffi.Int32 argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  rcutils_allocator_t allocator,
  ffi.Pointer<rcl_arguments_t> args_output,
);

typedef _dart_rcl_parse_arguments = int Function(
  int argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  rcutils_allocator_t allocator,
  ffi.Pointer<rcl_arguments_t> args_output,
);

typedef _c_rcl_arguments_get_count_unparsed = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _dart_rcl_arguments_get_count_unparsed = int Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _c_rcl_arguments_get_unparsed = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_indices,
);

typedef _dart_rcl_arguments_get_unparsed = int Function(
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_indices,
);

typedef _c_rcl_arguments_get_count_unparsed_ros = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _dart_rcl_arguments_get_count_unparsed_ros = int Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _c_rcl_arguments_get_unparsed_ros = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_ros_indices,
);

typedef _dart_rcl_arguments_get_unparsed_ros = int Function(
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_ros_indices,
);

typedef _c_rcl_arguments_get_param_files_count = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _dart_rcl_arguments_get_param_files_count = int Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _c_rcl_arguments_get_param_files = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> arguments,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> parameter_files,
);

typedef _dart_rcl_arguments_get_param_files = int Function(
  ffi.Pointer<rcl_arguments_t> arguments,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> parameter_files,
);

typedef _c_rcl_arguments_get_param_overrides = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> arguments,
  ffi.Pointer<ffi.Pointer<rcl_params_t>> parameter_overrides,
);

typedef _dart_rcl_arguments_get_param_overrides = int Function(
  ffi.Pointer<rcl_arguments_t> arguments,
  ffi.Pointer<ffi.Pointer<rcl_params_t>> parameter_overrides,
);

typedef _c_rcl_remove_ros_arguments = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Int32> nonros_argc,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> nonros_argv,
);

typedef _dart_rcl_remove_ros_arguments = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Int32> nonros_argc,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> nonros_argv,
);

typedef _c_rcl_arguments_copy = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
  ffi.Pointer<rcl_arguments_t> args_out,
);

typedef _dart_rcl_arguments_copy = int Function(
  ffi.Pointer<rcl_arguments_t> args,
  ffi.Pointer<rcl_arguments_t> args_out,
);

typedef _c_rcl_arguments_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _dart_rcl_arguments_fini = int Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _c_rcl_get_zero_initialized_init_options = rcl_init_options_t
    Function();

typedef _dart_rcl_get_zero_initialized_init_options = rcl_init_options_t
    Function();

typedef _c_rcl_init_options_init = ffi.Int32 Function(
  ffi.Pointer<rcl_init_options_t> init_options,
  rcutils_allocator_t allocator,
);

typedef _dart_rcl_init_options_init = int Function(
  ffi.Pointer<rcl_init_options_t> init_options,
  rcutils_allocator_t allocator,
);

typedef _c_rcl_init_options_copy = ffi.Int32 Function(
  ffi.Pointer<rcl_init_options_t> src,
  ffi.Pointer<rcl_init_options_t> dst,
);

typedef _dart_rcl_init_options_copy = int Function(
  ffi.Pointer<rcl_init_options_t> src,
  ffi.Pointer<rcl_init_options_t> dst,
);

typedef _c_rcl_init_options_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _dart_rcl_init_options_fini = int Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _c_rcl_init_options_get_rmw_init_options
    = ffi.Pointer<rmw_init_options_t> Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _dart_rcl_init_options_get_rmw_init_options
    = ffi.Pointer<rmw_init_options_t> Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _c_rcl_get_zero_initialized_context = rcl_context_t Function();

typedef _dart_rcl_get_zero_initialized_context = rcl_context_t Function();

typedef _c_rcl_context_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_fini = int Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_context_get_init_options = ffi.Pointer<rcl_init_options_t>
    Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_get_init_options = ffi.Pointer<rcl_init_options_t>
    Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_context_get_instance_id = ffi.Uint64 Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_get_instance_id = int Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_context_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_is_valid = int Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_context_get_rmw_context = ffi.Pointer<rmw_context_t> Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_get_rmw_context = ffi.Pointer<rmw_context_t> Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_node_get_default_options = rcl_node_options_t Function();

typedef _dart_rcl_node_get_default_options = rcl_node_options_t Function();

typedef _c_rcl_node_options_copy = ffi.Int32 Function(
  ffi.Pointer<rcl_node_options_t> options,
  ffi.Pointer<rcl_node_options_t> options_out,
);

typedef _dart_rcl_node_options_copy = int Function(
  ffi.Pointer<rcl_node_options_t> options,
  ffi.Pointer<rcl_node_options_t> options_out,
);

typedef _c_rcl_node_options_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_node_options_t> options,
);

typedef _dart_rcl_node_options_fini = int Function(
  ffi.Pointer<rcl_node_options_t> options,
);

typedef _c_rcl_get_zero_initialized_node = rcl_node_t Function();

typedef _dart_rcl_get_zero_initialized_node = rcl_node_t Function();

typedef _c_rcl_node_init = ffi.Int32 Function(
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> namespace_,
  ffi.Pointer<rcl_context_t> context,
  ffi.Pointer<rcl_node_options_t> options,
);

typedef _dart_rcl_node_init = int Function(
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> namespace_,
  ffi.Pointer<rcl_context_t> context,
  ffi.Pointer<rcl_node_options_t> options,
);

typedef _c_rcl_node_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_fini = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_is_valid = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_is_valid_except_context = ffi.Uint8 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_is_valid_except_context = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_namespace = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_namespace = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_fully_qualified_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_fully_qualified_name = ffi.Pointer<ffi.Int8>
    Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_options = ffi.Pointer<rcl_node_options_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_options = ffi.Pointer<rcl_node_options_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_domain_id = ffi.Int32 Function(
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<ffi.Uint64> domain_id,
);

typedef _dart_rcl_node_get_domain_id = int Function(
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<ffi.Uint64> domain_id,
);

typedef _c_rcl_node_assert_liveliness = ffi.Int32 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_assert_liveliness = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_rmw_handle = ffi.Pointer<rmw_node_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_rmw_handle = ffi.Pointer<rmw_node_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_rcl_instance_id = ffi.Uint64 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_rcl_instance_id = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_graph_guard_condition
    = ffi.Pointer<rcl_guard_condition_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_graph_guard_condition
    = ffi.Pointer<rcl_guard_condition_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_logger_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_logger_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_get_zero_initialized_client = rcl_client_t Function();

typedef _dart_rcl_get_zero_initialized_client = rcl_client_t Function();

typedef _c_rcl_client_init = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rcl_client_options_t> options,
);

typedef _dart_rcl_client_init = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rcl_client_options_t> options,
);

typedef _c_rcl_client_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_client_fini = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_client_get_default_options = rcl_client_options_t Function();

typedef _dart_rcl_client_get_default_options = rcl_client_options_t Function();

typedef _c_rcl_send_request = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Int64> sequence_number,
);

typedef _dart_rcl_send_request = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Int64> sequence_number,
);

typedef _c_rcl_take_response = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _dart_rcl_take_response = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _c_rcl_client_get_service_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _dart_rcl_client_get_service_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _c_rcl_client_get_options = ffi.Pointer<rcl_client_options_t> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _dart_rcl_client_get_options = ffi.Pointer<rcl_client_options_t>
    Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _c_rcl_client_get_rmw_handle = ffi.Pointer<rmw_client_t> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _dart_rcl_client_get_rmw_handle = ffi.Pointer<rmw_client_t> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _c_rcl_client_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _dart_rcl_client_is_valid = int Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _c_rcl_guard_condition_init = ffi.Int32 Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<rcl_context_t> context,
  rcl_guard_condition_options_t options,
);

typedef _dart_rcl_guard_condition_init = int Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<rcl_context_t> context,
  rcl_guard_condition_options_t options,
);

typedef _c_rcl_guard_condition_init_from_rmw = ffi.Int32 Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<rmw_guard_condition_t> rmw_guard_condition,
  ffi.Pointer<rcl_context_t> context,
  rcl_guard_condition_options_t options,
);

typedef _dart_rcl_guard_condition_init_from_rmw = int Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<rmw_guard_condition_t> rmw_guard_condition,
  ffi.Pointer<rcl_context_t> context,
  rcl_guard_condition_options_t options,
);

typedef _c_rcl_guard_condition_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _dart_rcl_guard_condition_fini = int Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _c_rcl_guard_condition_get_default_options
    = rcl_guard_condition_options_t Function();

typedef _dart_rcl_guard_condition_get_default_options
    = rcl_guard_condition_options_t Function();

typedef _c_rcl_trigger_guard_condition = ffi.Int32 Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _dart_rcl_trigger_guard_condition = int Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _c_rcl_guard_condition_get_options
    = ffi.Pointer<rcl_guard_condition_options_t> Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _dart_rcl_guard_condition_get_options
    = ffi.Pointer<rcl_guard_condition_options_t> Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _c_rcl_guard_condition_get_rmw_handle
    = ffi.Pointer<rmw_guard_condition_t> Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _dart_rcl_guard_condition_get_rmw_handle
    = ffi.Pointer<rmw_guard_condition_t> Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _c_rcl_get_zero_initialized_service = rcl_service_t Function();

typedef _dart_rcl_get_zero_initialized_service = rcl_service_t Function();

typedef _c_rcl_service_init = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rcl_service_options_t> options,
);

typedef _dart_rcl_service_init = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rcl_service_options_t> options,
);

typedef _c_rcl_service_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_service_fini = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_service_get_default_options = rcl_service_options_t Function();

typedef _dart_rcl_service_get_default_options = rcl_service_options_t
    Function();

typedef _c_rcl_take_request = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
);

typedef _dart_rcl_take_request = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
);

typedef _c_rcl_send_response = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_request_id_t> response_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _dart_rcl_send_response = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_request_id_t> response_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _c_rcl_service_get_service_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _dart_rcl_service_get_service_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _c_rcl_service_get_options = ffi.Pointer<rcl_service_options_t>
    Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _dart_rcl_service_get_options = ffi.Pointer<rcl_service_options_t>
    Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _c_rcl_service_get_rmw_handle = ffi.Pointer<rmw_service_t> Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _dart_rcl_service_get_rmw_handle = ffi.Pointer<rmw_service_t> Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _c_rcl_service_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _dart_rcl_service_is_valid = int Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _c_get_message_typesupport_handle
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_message_typesupport_handle
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_get_message_typesupport_handle_function
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_message_typesupport_handle_function
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_rcl_get_zero_initialized_subscription = rcl_subscription_t
    Function();

typedef _dart_rcl_get_zero_initialized_subscription = rcl_subscription_t
    Function();

typedef _c_rcl_subscription_init = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rcl_subscription_options_t> options,
);

typedef _dart_rcl_subscription_init = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rcl_subscription_options_t> options,
);

typedef _c_rcl_subscription_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_subscription_fini = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_subscription_get_default_options = rcl_subscription_options_t
    Function();

typedef _dart_rcl_subscription_get_default_options = rcl_subscription_options_t
    Function();

typedef _c_rcl_take = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rcl_take = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rcl_take_serialized_message = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rcl_take_serialized_message = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rcl_take_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rcl_take_loaned_message = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rcl_return_loaned_message_from_subscription = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _dart_rcl_return_loaned_message_from_subscription = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _c_rcl_subscription_get_topic_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_get_topic_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_get_options
    = ffi.Pointer<rcl_subscription_options_t> Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_get_options
    = ffi.Pointer<rcl_subscription_options_t> Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_get_rmw_handle = ffi.Pointer<rmw_subscription_t>
    Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_get_rmw_handle = ffi.Pointer<rmw_subscription_t>
    Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_is_valid = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_get_publisher_count = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> publisher_count,
);

typedef _dart_rcl_subscription_get_publisher_count = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> publisher_count,
);

typedef _c_rcl_subscription_get_actual_qos = ffi.Pointer<rmw_qos_profile_t>
    Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_get_actual_qos = ffi.Pointer<rmw_qos_profile_t>
    Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_can_loan_messages = ffi.Uint8 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_can_loan_messages = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_clock_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_clock_valid = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_clock_init = ffi.Int32 Function(
  ffi.Int32 clock_type,
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_clock_init = int Function(
  int clock_type,
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_clock_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_clock_fini = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_ros_clock_init = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_ros_clock_init = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_ros_clock_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_ros_clock_fini = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_steady_clock_init = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_steady_clock_init = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_steady_clock_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_steady_clock_fini = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_system_clock_init = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_system_clock_init = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_system_clock_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_system_clock_fini = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_difference_times = ffi.Int32 Function(
  ffi.Pointer<rcl_time_point_t> start,
  ffi.Pointer<rcl_time_point_t> finish,
  ffi.Pointer<rcl_duration_t> delta,
);

typedef _dart_rcl_difference_times = int Function(
  ffi.Pointer<rcl_time_point_t> start,
  ffi.Pointer<rcl_time_point_t> finish,
  ffi.Pointer<rcl_duration_t> delta,
);

typedef _c_rcl_clock_get_now = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.Int64> time_point_value,
);

typedef _dart_rcl_clock_get_now = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.Int64> time_point_value,
);

typedef _c_rcl_enable_ros_time_override = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_enable_ros_time_override = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_disable_ros_time_override = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_disable_ros_time_override = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_is_enabled_ros_time_override = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.Uint8> is_enabled,
);

typedef _dart_rcl_is_enabled_ros_time_override = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.Uint8> is_enabled,
);

typedef _c_rcl_set_ros_time_override = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Int64 time_value,
);

typedef _dart_rcl_set_ros_time_override = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  int time_value,
);

typedef rcl_jump_callback_t = ffi.Void Function(
  ffi.Pointer<rcl_time_jump_t>,
  ffi.Uint8,
  ffi.Pointer<ffi.Void>,
);

typedef _c_rcl_clock_add_jump_callback = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  rcl_jump_threshold_t threshold,
  ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _dart_rcl_clock_add_jump_callback = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  rcl_jump_threshold_t threshold,
  ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _c_rcl_clock_remove_jump_callback = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _dart_rcl_clock_remove_jump_callback = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _c_get_message_bounds_handle = ffi.Pointer<rosidl_message_bounds_t>
    Function(
  ffi.Pointer<rosidl_message_bounds_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_message_bounds_handle = ffi.Pointer<rosidl_message_bounds_t>
    Function(
  ffi.Pointer<rosidl_message_bounds_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_get_message_bounds_handle_function
    = ffi.Pointer<rosidl_message_bounds_t> Function(
  ffi.Pointer<rosidl_message_bounds_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_message_bounds_handle_function
    = ffi.Pointer<rosidl_message_bounds_t> Function(
  ffi.Pointer<rosidl_message_bounds_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_rmw_get_default_subscription_options = rmw_subscription_options_t
    Function();

typedef _dart_rmw_get_default_subscription_options = rmw_subscription_options_t
    Function();

typedef _c_rmw_get_implementation_identifier = ffi.Pointer<ffi.Int8> Function();

typedef _dart_rmw_get_implementation_identifier = ffi.Pointer<ffi.Int8>
    Function();

typedef _c_rmw_get_serialization_format = ffi.Pointer<ffi.Int8> Function();

typedef _dart_rmw_get_serialization_format = ffi.Pointer<ffi.Int8> Function();

typedef _c_rmw_create_node = ffi.Pointer<rmw_node_t> Function(
  ffi.Pointer<rmw_context_t> context,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> namespace_,
  ffi.Uint64 domain_id,
  ffi.Pointer<rmw_node_security_options_t> security_options,
  ffi.Uint8 localhost_only,
);

typedef _dart_rmw_create_node = ffi.Pointer<rmw_node_t> Function(
  ffi.Pointer<rmw_context_t> context,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> namespace_,
  int domain_id,
  ffi.Pointer<rmw_node_security_options_t> security_options,
  int localhost_only,
);

typedef _c_rmw_destroy_node = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _dart_rmw_destroy_node = int Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _c_rmw_node_assert_liveliness = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _dart_rmw_node_assert_liveliness = int Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _c_rmw_node_get_graph_guard_condition
    = ffi.Pointer<rmw_guard_condition_t> Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _dart_rmw_node_get_graph_guard_condition
    = ffi.Pointer<rmw_guard_condition_t> Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _c_rmw_init_publisher_allocation = ffi.Int32 Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_message_bounds_t> message_bounds,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_init_publisher_allocation = int Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_message_bounds_t> message_bounds,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_fini_publisher_allocation = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_fini_publisher_allocation = int Function(
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_get_default_publisher_options = rmw_publisher_options_t
    Function();

typedef _dart_rmw_get_default_publisher_options = rmw_publisher_options_t
    Function();

typedef _c_rmw_create_publisher = ffi.Pointer<rmw_publisher_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ffi.Pointer<rmw_publisher_options_t> publisher_options,
);

typedef _dart_rmw_create_publisher = ffi.Pointer<rmw_publisher_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ffi.Pointer<rmw_publisher_options_t> publisher_options,
);

typedef _c_rmw_destroy_publisher = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_publisher_t> publisher,
);

typedef _dart_rmw_destroy_publisher = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_publisher_t> publisher,
);

typedef _c_rmw_borrow_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
);

typedef _dart_rmw_borrow_loaned_message = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
);

typedef _c_rmw_return_loaned_message_from_publisher = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _dart_rmw_return_loaned_message_from_publisher = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _c_rmw_publish = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_publish = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_publish_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_publish_loaned_message = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_publisher_count_matched_subscriptions = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Uint64> subscription_count,
);

typedef _dart_rmw_publisher_count_matched_subscriptions = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Uint64> subscription_count,
);

typedef _c_rmw_publisher_get_actual_qos = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rmw_qos_profile_t> qos,
);

typedef _dart_rmw_publisher_get_actual_qos = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rmw_qos_profile_t> qos,
);

typedef _c_rmw_publish_serialized_message = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_publish_serialized_message = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_get_serialized_message_size = ffi.Int32 Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_message_bounds_t> message_bounds,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_rmw_get_serialized_message_size = int Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_message_bounds_t> message_bounds,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_rmw_publisher_assert_liveliness = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
);

typedef _dart_rmw_publisher_assert_liveliness = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
);

typedef _c_rmw_serialize = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
);

typedef _dart_rmw_serialize = int Function(
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
);

typedef _c_rmw_deserialize = ffi.Int32 Function(
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Void> ros_message,
);

typedef _dart_rmw_deserialize = int Function(
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Void> ros_message,
);

typedef _c_rmw_init_subscription_allocation = ffi.Int32 Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_message_bounds_t> message_bounds,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_init_subscription_allocation = int Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_message_bounds_t> message_bounds,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_fini_subscription_allocation = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_fini_subscription_allocation = int Function(
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_create_subscription = ffi.Pointer<rmw_subscription_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ffi.Pointer<rmw_subscription_options_t> subscription_options,
);

typedef _dart_rmw_create_subscription = ffi.Pointer<rmw_subscription_t>
    Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ffi.Pointer<rmw_subscription_options_t> subscription_options,
);

typedef _c_rmw_destroy_subscription = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_subscription_t> subscription,
);

typedef _dart_rmw_destroy_subscription = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_subscription_t> subscription,
);

typedef _c_rmw_subscription_count_matched_publishers = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> publisher_count,
);

typedef _dart_rmw_subscription_count_matched_publishers = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> publisher_count,
);

typedef _c_rmw_subscription_get_actual_qos = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rmw_qos_profile_t> qos,
);

typedef _dart_rmw_subscription_get_actual_qos = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rmw_qos_profile_t> qos,
);

typedef _c_rmw_take = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_with_info = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_with_info = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_serialized_message = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_serialized_message = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_serialized_message_with_info = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_serialized_message_with_info = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_loaned_message = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_loaned_message_with_info = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_loaned_message_with_info = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_return_loaned_message_from_subscription = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _dart_rmw_return_loaned_message_from_subscription = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _c_rmw_create_client = ffi.Pointer<rmw_client_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
);

typedef _dart_rmw_create_client = ffi.Pointer<rmw_client_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
);

typedef _c_rmw_destroy_client = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_client_t> client,
);

typedef _dart_rmw_destroy_client = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_client_t> client,
);

typedef _c_rmw_send_request = ffi.Int32 Function(
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Int64> sequence_id,
);

typedef _dart_rmw_send_request = int Function(
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Int64> sequence_id,
);

typedef _c_rmw_take_response = ffi.Int32 Function(
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
  ffi.Pointer<ffi.Uint8> taken,
);

typedef _dart_rmw_take_response = int Function(
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
  ffi.Pointer<ffi.Uint8> taken,
);

typedef _c_rmw_create_service = ffi.Pointer<rmw_service_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
);

typedef _dart_rmw_create_service = ffi.Pointer<rmw_service_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
);

typedef _c_rmw_destroy_service = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_service_t> service,
);

typedef _dart_rmw_destroy_service = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_service_t> service,
);

typedef _c_rmw_take_request = ffi.Int32 Function(
  ffi.Pointer<rmw_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Uint8> taken,
);

typedef _dart_rmw_take_request = int Function(
  ffi.Pointer<rmw_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Uint8> taken,
);

typedef _c_rmw_send_response = ffi.Int32 Function(
  ffi.Pointer<rmw_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _dart_rmw_send_response = int Function(
  ffi.Pointer<rmw_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _c_rmw_create_guard_condition = ffi.Pointer<rmw_guard_condition_t>
    Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _dart_rmw_create_guard_condition = ffi.Pointer<rmw_guard_condition_t>
    Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _c_rmw_destroy_guard_condition = ffi.Int32 Function(
  ffi.Pointer<rmw_guard_condition_t> guard_condition,
);

typedef _dart_rmw_destroy_guard_condition = int Function(
  ffi.Pointer<rmw_guard_condition_t> guard_condition,
);

typedef _c_rmw_trigger_guard_condition = ffi.Int32 Function(
  ffi.Pointer<rmw_guard_condition_t> guard_condition,
);

typedef _dart_rmw_trigger_guard_condition = int Function(
  ffi.Pointer<rmw_guard_condition_t> guard_condition,
);

typedef _c_rmw_create_wait_set = ffi.Pointer<rmw_wait_set_t> Function(
  ffi.Pointer<rmw_context_t> context,
  ffi.Uint64 max_conditions,
);

typedef _dart_rmw_create_wait_set = ffi.Pointer<rmw_wait_set_t> Function(
  ffi.Pointer<rmw_context_t> context,
  int max_conditions,
);

typedef _c_rmw_destroy_wait_set = ffi.Int32 Function(
  ffi.Pointer<rmw_wait_set_t> wait_set,
);

typedef _dart_rmw_destroy_wait_set = int Function(
  ffi.Pointer<rmw_wait_set_t> wait_set,
);

typedef _c_rmw_wait = ffi.Int32 Function(
  ffi.Pointer<rmw_subscriptions_t> subscriptions,
  ffi.Pointer<rmw_guard_conditions_t> guard_conditions,
  ffi.Pointer<rmw_services_t> services,
  ffi.Pointer<rmw_clients_t> clients,
  ffi.Pointer<rmw_events_t> events,
  ffi.Pointer<rmw_wait_set_t> wait_set,
  ffi.Pointer<rmw_time_t> wait_timeout,
);

typedef _dart_rmw_wait = int Function(
  ffi.Pointer<rmw_subscriptions_t> subscriptions,
  ffi.Pointer<rmw_guard_conditions_t> guard_conditions,
  ffi.Pointer<rmw_services_t> services,
  ffi.Pointer<rmw_clients_t> clients,
  ffi.Pointer<rmw_events_t> events,
  ffi.Pointer<rmw_wait_set_t> wait_set,
  ffi.Pointer<rmw_time_t> wait_timeout,
);

typedef _c_rmw_get_node_names = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rcutils_string_array_t> node_names,
  ffi.Pointer<rcutils_string_array_t> node_namespaces,
);

typedef _dart_rmw_get_node_names = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rcutils_string_array_t> node_names,
  ffi.Pointer<rcutils_string_array_t> node_namespaces,
);

typedef _c_rmw_count_publishers = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<ffi.Uint64> count,
);

typedef _dart_rmw_count_publishers = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<ffi.Uint64> count,
);

typedef _c_rmw_count_subscribers = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<ffi.Uint64> count,
);

typedef _dart_rmw_count_subscribers = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<ffi.Uint64> count,
);

typedef _c_rmw_get_gid_for_publisher = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rmw_gid_t> gid,
);

typedef _dart_rmw_get_gid_for_publisher = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rmw_gid_t> gid,
);

typedef _c_rmw_compare_gids_equal = ffi.Int32 Function(
  ffi.Pointer<rmw_gid_t> gid1,
  ffi.Pointer<rmw_gid_t> gid2,
  ffi.Pointer<ffi.Uint8> result,
);

typedef _dart_rmw_compare_gids_equal = int Function(
  ffi.Pointer<rmw_gid_t> gid1,
  ffi.Pointer<rmw_gid_t> gid2,
  ffi.Pointer<ffi.Uint8> result,
);

typedef _c_rmw_service_server_is_available = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<ffi.Uint8> is_available,
);

typedef _dart_rmw_service_server_is_available = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<ffi.Uint8> is_available,
);

typedef _c_rmw_set_log_severity = ffi.Int32 Function(
  ffi.Int32 severity,
);

typedef _dart_rmw_set_log_severity = int Function(
  int severity,
);

typedef _c_rcl_get_zero_initialized_timer = rcl_timer_t Function();

typedef _dart_rcl_get_zero_initialized_timer = rcl_timer_t Function();

typedef rcl_timer_callback_t = ffi.Void Function(
  ffi.Pointer<rcl_timer_t>,
  ffi.Int64,
);

typedef _c_rcl_timer_init = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcl_context_t> context,
  ffi.Int64 period,
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> callback,
  rcutils_allocator_t allocator,
);

typedef _dart_rcl_timer_init = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcl_context_t> context,
  int period,
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> callback,
  rcutils_allocator_t allocator,
);

typedef _c_rcl_timer_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_fini = int Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_call = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_call = int Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_clock = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Pointer<rcl_clock_t>> clock,
);

typedef _dart_rcl_timer_clock = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Pointer<rcl_clock_t>> clock,
);

typedef _c_rcl_timer_is_ready = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint8> is_ready,
);

typedef _dart_rcl_timer_is_ready = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint8> is_ready,
);

typedef _c_rcl_timer_get_time_until_next_call = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> time_until_next_call,
);

typedef _dart_rcl_timer_get_time_until_next_call = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> time_until_next_call,
);

typedef _c_rcl_timer_get_time_since_last_call = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> time_since_last_call,
);

typedef _dart_rcl_timer_get_time_since_last_call = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> time_since_last_call,
);

typedef _c_rcl_timer_get_period = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> period,
);

typedef _dart_rcl_timer_get_period = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> period,
);

typedef _c_rcl_timer_exchange_period = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Int64 new_period,
  ffi.Pointer<ffi.Int64> old_period,
);

typedef _dart_rcl_timer_exchange_period = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  int new_period,
  ffi.Pointer<ffi.Int64> old_period,
);

typedef _c_rcl_timer_get_callback
    = ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_get_callback
    = ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_exchange_callback
    = ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> new_callback,
);

typedef _dart_rcl_timer_exchange_callback
    = ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> new_callback,
);

typedef _c_rcl_timer_cancel = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_cancel = int Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_is_canceled = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint8> is_canceled,
);

typedef _dart_rcl_timer_is_canceled = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint8> is_canceled,
);

typedef _c_rcl_timer_reset = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_reset = int Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_get_allocator = ffi.Pointer<rcutils_allocator_t> Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_get_allocator = ffi.Pointer<rcutils_allocator_t>
    Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_get_guard_condition = ffi.Pointer<rcl_guard_condition_t>
    Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_get_guard_condition = ffi.Pointer<rcl_guard_condition_t>
    Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_get_zero_initialized_publisher = rcl_publisher_t Function();

typedef _dart_rcl_get_zero_initialized_publisher = rcl_publisher_t Function();

typedef _c_rcl_publisher_init = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rcl_publisher_options_t> options,
);

typedef _dart_rcl_publisher_init = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rcl_publisher_options_t> options,
);

typedef _c_rcl_publisher_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_publisher_fini = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_publisher_get_default_options = rcl_publisher_options_t
    Function();

typedef _dart_rcl_publisher_get_default_options = rcl_publisher_options_t
    Function();

typedef _c_rcl_borrow_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
);

typedef _dart_rcl_borrow_loaned_message = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
);

typedef _c_rcl_return_loaned_message_from_publisher = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _dart_rcl_return_loaned_message_from_publisher = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _c_rcl_publish = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rcl_publish = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rcl_publish_serialized_message = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rcl_publish_serialized_message = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rcl_publish_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rcl_publish_loaned_message = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rcl_publisher_assert_liveliness = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_assert_liveliness = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_topic_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_topic_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_options = ffi.Pointer<rcl_publisher_options_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_options = ffi.Pointer<rcl_publisher_options_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_rmw_handle = ffi.Pointer<rmw_publisher_t> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_rmw_handle = ffi.Pointer<rmw_publisher_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_context = ffi.Pointer<rcl_context_t> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_context = ffi.Pointer<rcl_context_t> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_is_valid = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_is_valid_except_context = ffi.Uint8 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_is_valid_except_context = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_subscription_count = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Uint64> subscription_count,
);

typedef _dart_rcl_publisher_get_subscription_count = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Uint64> subscription_count,
);

typedef _c_rcl_publisher_get_actual_qos = ffi.Pointer<rmw_qos_profile_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_actual_qos = ffi.Pointer<rmw_qos_profile_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_can_loan_messages = ffi.Uint8 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_can_loan_messages = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_get_zero_initialized_event = rcl_event_t Function();

typedef _dart_rcl_get_zero_initialized_event = rcl_event_t Function();

typedef _c_rcl_publisher_event_init = ffi.Int32 Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Int32 event_type,
);

typedef _dart_rcl_publisher_event_init = int Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<rcl_publisher_t> publisher,
  int event_type,
);

typedef _c_rcl_subscription_event_init = ffi.Int32 Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Int32 event_type,
);

typedef _dart_rcl_subscription_event_init = int Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<rcl_subscription_t> subscription,
  int event_type,
);

typedef _c_rcl_take_event = ffi.Int32 Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<ffi.Void> event_info,
);

typedef _dart_rcl_take_event = int Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<ffi.Void> event_info,
);

typedef _c_rcl_event_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_event_t> event,
);

typedef _dart_rcl_event_fini = int Function(
  ffi.Pointer<rcl_event_t> event,
);

typedef _c_rcl_event_get_rmw_handle = ffi.Pointer<rmw_event_t> Function(
  ffi.Pointer<rcl_event_t> event,
);

typedef _dart_rcl_event_get_rmw_handle = ffi.Pointer<rmw_event_t> Function(
  ffi.Pointer<rcl_event_t> event,
);

typedef _c_rmw_get_zero_initialized_names_and_types = rmw_names_and_types_t
    Function();

typedef _dart_rmw_get_zero_initialized_names_and_types = rmw_names_and_types_t
    Function();

typedef _c_rmw_names_and_types_check_zero = ffi.Int32 Function(
  ffi.Pointer<rmw_names_and_types_t> names_and_types,
);

typedef _dart_rmw_names_and_types_check_zero = int Function(
  ffi.Pointer<rmw_names_and_types_t> names_and_types,
);

typedef _c_rmw_names_and_types_init = ffi.Int32 Function(
  ffi.Pointer<rmw_names_and_types_t> names_and_types,
  ffi.Uint64 size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rmw_names_and_types_init = int Function(
  ffi.Pointer<rmw_names_and_types_t> names_and_types,
  int size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rmw_names_and_types_fini = ffi.Int32 Function(
  ffi.Pointer<rmw_names_and_types_t> names_and_types,
);

typedef _dart_rmw_names_and_types_fini = int Function(
  ffi.Pointer<rmw_names_and_types_t> names_and_types,
);

typedef _c_rmw_get_topic_names_and_types = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rcutils_allocator_t> allocator,
  ffi.Uint8 no_demangle,
  ffi.Pointer<rmw_names_and_types_t> topic_names_and_types,
);

typedef _dart_rmw_get_topic_names_and_types = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rcutils_allocator_t> allocator,
  int no_demangle,
  ffi.Pointer<rmw_names_and_types_t> topic_names_and_types,
);

typedef _c_rcl_lexer_analyze = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> text,
  ffi.Pointer<ffi.Int32> lexeme,
  ffi.Pointer<ffi.Uint64> length,
);

typedef _dart_rcl_lexer_analyze = int Function(
  ffi.Pointer<ffi.Int8> text,
  ffi.Pointer<ffi.Int32> lexeme,
  ffi.Pointer<ffi.Uint64> length,
);

typedef _c_rcl_init = ffi.Int32 Function(
  ffi.Int32 argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<rcl_init_options_t> options,
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_init = int Function(
  int argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<rcl_init_options_t> options,
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_shutdown = ffi.Int32 Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_shutdown = int Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_get_zero_initialized_wait_set = rcl_wait_set_t Function();

typedef _dart_rcl_get_zero_initialized_wait_set = rcl_wait_set_t Function();

typedef _c_rcl_wait_set_init = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Uint64 number_of_subscriptions,
  ffi.Uint64 number_of_guard_conditions,
  ffi.Uint64 number_of_timers,
  ffi.Uint64 number_of_clients,
  ffi.Uint64 number_of_services,
  ffi.Uint64 number_of_events,
  ffi.Pointer<rcl_context_t> context,
  rcutils_allocator_t allocator,
);

typedef _dart_rcl_wait_set_init = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  int number_of_subscriptions,
  int number_of_guard_conditions,
  int number_of_timers,
  int number_of_clients,
  int number_of_services,
  int number_of_events,
  ffi.Pointer<rcl_context_t> context,
  rcutils_allocator_t allocator,
);

typedef _c_rcl_wait_set_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _dart_rcl_wait_set_fini = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _c_rcl_wait_set_get_allocator = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_wait_set_get_allocator = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_wait_set_add_subscription = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_subscription = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_clear = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _dart_rcl_wait_set_clear = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _c_rcl_wait_set_resize = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Uint64 subscriptions_size,
  ffi.Uint64 guard_conditions_size,
  ffi.Uint64 timers_size,
  ffi.Uint64 clients_size,
  ffi.Uint64 services_size,
  ffi.Uint64 events_size,
);

typedef _dart_rcl_wait_set_resize = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  int subscriptions_size,
  int guard_conditions_size,
  int timers_size,
  int clients_size,
  int services_size,
  int events_size,
);

typedef _c_rcl_wait_set_add_guard_condition = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_guard_condition = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_add_timer = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_timer = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_add_client = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_client = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_add_service = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_service = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_add_event = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_event = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Int64 timeout,
);

typedef _dart_rcl_wait = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  int timeout,
);

typedef rosidl_service_typesupport_handle_function
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t>,
  ffi.Pointer<ffi.Int8>,
);

typedef _typedefC_1 = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_2 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_3 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Uint64,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_4 = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64,
  ffi.Uint64,
  ffi.Pointer<ffi.Void>,
);

typedef rosidl_message_typesupport_handle_function
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t>,
  ffi.Pointer<ffi.Int8>,
);

typedef _typedefC_5 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Int64>,
);

typedef rosidl_message_bounds_handle_function
    = ffi.Pointer<rosidl_message_bounds_t> Function(
  ffi.Pointer<rosidl_message_bounds_t>,
  ffi.Pointer<ffi.Int8>,
);
