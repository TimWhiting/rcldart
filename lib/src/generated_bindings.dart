// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to the ros client library dynamic libraries
class RCL {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  RCL(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  /// /// Return a zero initialized allocator.
  ///
  /// Note that this is an invalid allocator and should only be used as a placeholder.
  rcutils_allocator_t rcutils_get_zero_initialized_allocator() {
    return (_rcutils_get_zero_initialized_allocator ??= _dylib.lookupFunction<
            _c_rcutils_get_zero_initialized_allocator,
            _dart_rcutils_get_zero_initialized_allocator>(
        'rcutils_get_zero_initialized_allocator'))();
  }

  _dart_rcutils_get_zero_initialized_allocator?
      _rcutils_get_zero_initialized_allocator;

  /// /// Return a properly initialized rcutils_allocator_t with default values.
  ///
  /// This defaults to:
  ///
  /// - allocate = wraps malloc()
  /// - deallocate = wraps free()
  /// - reallocate = wraps realloc()
  /// - zero_allocate = wraps calloc()
  /// - state = `NULL`
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  rcutils_allocator_t rcutils_get_default_allocator() {
    return (_rcutils_get_default_allocator ??= _dylib.lookupFunction<
            _c_rcutils_get_default_allocator,
            _dart_rcutils_get_default_allocator>(
        'rcutils_get_default_allocator'))();
  }

  _dart_rcutils_get_default_allocator? _rcutils_get_default_allocator;

  /// /// Return true if the given allocator has non-null function pointers.
  ///
  /// Will also return false if the allocator pointer is null.
  ///
  /// \param[in] allocator to be checked by the function
  bool rcutils_allocator_is_valid(
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcutils_allocator_is_valid ??= _dylib.lookupFunction<
            _c_rcutils_allocator_is_valid,
            _dart_rcutils_allocator_is_valid>('rcutils_allocator_is_valid'))(
          allocator,
        ) !=
        0;
  }

  _dart_rcutils_allocator_is_valid? _rcutils_allocator_is_valid;

  /// /// Emulate the behavior of [reallocf](https://linux.die.net/man/3/reallocf).
  ///
  /// This function will return `NULL` if the allocator is `NULL` or has `NULL` for
  /// function pointer fields.
  /// \param[inout] pointer to the memory which will be reallocated
  /// \param[in] size in bytes
  /// \param[in] allocator to be used to allocate and deallocate memory
  ffi.Pointer<ffi.Void> rcutils_reallocf(
    ffi.Pointer<ffi.Void> pointer,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcutils_reallocf ??=
        _dylib.lookupFunction<_c_rcutils_reallocf, _dart_rcutils_reallocf>(
            'rcutils_reallocf'))(
      pointer,
      size,
      allocator,
    );
  }

  _dart_rcutils_reallocf? _rcutils_reallocf;

  /// /// Get zero initialized security options.
  rmw_security_options_t rmw_get_zero_initialized_security_options() {
    return (_rmw_get_zero_initialized_security_options ??=
        _dylib.lookupFunction<_c_rmw_get_zero_initialized_security_options,
                _dart_rmw_get_zero_initialized_security_options>(
            'rmw_get_zero_initialized_security_options'))();
  }

  _dart_rmw_get_zero_initialized_security_options?
      _rmw_get_zero_initialized_security_options;

  /// /// Get default initialized security options.
  rmw_security_options_t rmw_get_default_security_options() {
    return (_rmw_get_default_security_options ??= _dylib.lookupFunction<
            _c_rmw_get_default_security_options,
            _dart_rmw_get_default_security_options>(
        'rmw_get_default_security_options'))();
  }

  _dart_rmw_get_default_security_options? _rmw_get_default_security_options;

  /// /// Copy the given security options.
  ///
  /// \param[in] src security options to be copied.
  /// \param[in] allocator allocator used when copying data to the new security options.
  /// \param[out] dst security options to be set.
  /// \returns RMW_RET_BAD_ALLOC, or
  /// \returns RMW_RET_OK
  int rmw_security_options_copy(
    ffi.Pointer<rmw_security_options_t> src,
    ffi.Pointer<rcutils_allocator_t> allocator,
    ffi.Pointer<rmw_security_options_t> dst,
  ) {
    return (_rmw_security_options_copy ??= _dylib.lookupFunction<
        _c_rmw_security_options_copy,
        _dart_rmw_security_options_copy>('rmw_security_options_copy'))(
      src,
      allocator,
      dst,
    );
  }

  _dart_rmw_security_options_copy? _rmw_security_options_copy;

  /// /// Set the security root path for the given security options.
  ///
  /// The provided `security_root_path` will be copied into allocated memory.
  ///
  /// \param[in] security_root_path path to be set.
  /// \param[in] allocator allocator used to allocate the new path.
  /// \param[in|out] security_options security options to be set.
  /// \returns RMW_RET_BAD_ALLOC, or
  /// \returns RMW_RET_OK
  int rmw_security_options_set_root_path(
    ffi.Pointer<ffi.Int8> security_root_path,
    ffi.Pointer<rcutils_allocator_t> allocator,
    ffi.Pointer<rmw_security_options_t> security_options,
  ) {
    return (_rmw_security_options_set_root_path ??= _dylib.lookupFunction<
            _c_rmw_security_options_set_root_path,
            _dart_rmw_security_options_set_root_path>(
        'rmw_security_options_set_root_path'))(
      security_root_path,
      allocator,
      security_options,
    );
  }

  _dart_rmw_security_options_set_root_path? _rmw_security_options_set_root_path;

  /// /// Finalize the given security_options.
  ///
  /// \param[in] security_options security options to be finalized.
  /// \param[in] allocator allocator used to deallocate the root path.
  /// \returns RMW_RET_ERROR, or
  /// \returns RMW_RET_OK
  int rmw_security_options_fini(
    ffi.Pointer<rmw_security_options_t> security_options,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rmw_security_options_fini ??= _dylib.lookupFunction<
        _c_rmw_security_options_fini,
        _dart_rmw_security_options_fini>('rmw_security_options_fini'))(
      security_options,
      allocator,
    );
  }

  _dart_rmw_security_options_fini? _rmw_security_options_fini;

  /// /// Return a zero initialized init options structure.
  rmw_init_options_t rmw_get_zero_initialized_init_options() {
    return (_rmw_get_zero_initialized_init_options ??= _dylib.lookupFunction<
            _c_rmw_get_zero_initialized_init_options,
            _dart_rmw_get_zero_initialized_init_options>(
        'rmw_get_zero_initialized_init_options'))();
  }

  _dart_rmw_get_zero_initialized_init_options?
      _rmw_get_zero_initialized_init_options;

  /// /// Initialize given init options with the default values and implementation specific values.
  ///
  /// The given allocator is used, if required, during setup of the init options,
  /// but is also used during initialization.
  ///
  /// In either case the given allocator is stored in the returned init options.
  ///
  /// The `impl` pointer should not be changed manually.
  ///
  /// \pre The given init options must be zero initialized.
  ///
  /// \post If initialization fails, init options will remain zero initialized.
  ///
  /// \remark Giving an already initialized init options will result
  /// in a failure with return code `RMW_RET_INVALID_ARGUMENT`.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// This should be defined by the rmw implementation.
  ///
  /// \param[inout] init_options object to be setup
  /// \param[in] allocator to be used during setup and during initialization
  /// \return `RMW_RET_OK` if setup is successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RMW_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_init_options_init(
    ffi.Pointer<rmw_init_options_t> init_options,
    rcutils_allocator_t allocator,
  ) {
    return (_rmw_init_options_init ??= _dylib.lookupFunction<
        _c_rmw_init_options_init,
        _dart_rmw_init_options_init>('rmw_init_options_init'))(
      init_options,
      allocator,
    );
  }

  _dart_rmw_init_options_init? _rmw_init_options_init;

  /// /// Copy the given source init options to the destination init options.
  ///
  /// The allocator from the source is used for any allocations and stored in the
  /// destination.
  ///
  /// \pre The source init options must have been initialized
  /// i.e. had `rmw_init_options_init()` called on.
  /// \pre The destination init options must be zero initialized.
  ///
  /// \post If copy fails, destination init options will remain zero initialized.
  ///
  /// \remark Giving an zero initialized init options as a source will result
  /// in a failure with return code `RMW_RET_INVALID_ARGUMENT`.
  /// \remark Giving an already initialized init options for the destination will result
  /// in a failure with return code `RMW_RET_INVALID_ARGUMENT`.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// This should be defined by the rmw implementation.
  ///
  /// \param[in] src rcl_init_options_t object to be copied from
  /// \param[out] dst rcl_init_options_t object to be copied into
  /// \return `RMW_RET_OK` if the copy is successful, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  /// identifier for src does not match the implementation of this function, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RMW_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_init_options_copy(
    ffi.Pointer<rmw_init_options_t> src,
    ffi.Pointer<rmw_init_options_t> dst,
  ) {
    return (_rmw_init_options_copy ??= _dylib.lookupFunction<
        _c_rmw_init_options_copy,
        _dart_rmw_init_options_copy>('rmw_init_options_copy'))(
      src,
      dst,
    );
  }

  _dart_rmw_init_options_copy? _rmw_init_options_copy;

  /// /// Finalize the given init options.
  ///
  /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given init options
  /// unchanged.
  /// Otherwise, it will proceed despite errors, freeing as much resources as it can and zero
  /// initializing the given init options.
  ///
  /// \pre The given init options must have been initialized
  /// i.e. had `rmw_init_options_init()` called on.
  ///
  /// \remarks If init options are zero initialized,
  /// then `RMW_RET_INVALID_ARGUMENT` is returned.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// This should be defined by the rmw implementation.
  ///
  /// \param[inout] init_options object to finalized
  /// \return `RMW_RET_OK` if finalization is successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  /// identifier does not match the implementation of this function, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_init_options_fini(
    ffi.Pointer<rmw_init_options_t> init_options,
  ) {
    return (_rmw_init_options_fini ??= _dylib.lookupFunction<
        _c_rmw_init_options_fini,
        _dart_rmw_init_options_fini>('rmw_init_options_fini'))(
      init_options,
    );
  }

  _dart_rmw_init_options_fini? _rmw_init_options_fini;

  /// /// Return a zero initialized context structure.
  rmw_context_t rmw_get_zero_initialized_context() {
    return (_rmw_get_zero_initialized_context ??= _dylib.lookupFunction<
            _c_rmw_get_zero_initialized_context,
            _dart_rmw_get_zero_initialized_context>(
        'rmw_get_zero_initialized_context'))();
  }

  _dart_rmw_get_zero_initialized_context? _rmw_get_zero_initialized_context;

  /// /// Initialize the middleware with the given options, and yielding an context.
  ///
  /// Context is filled with middleware specific data upon success of this function.
  /// The context is used when initializing some entities like nodes and
  /// guard conditions, and is also required to properly call `rmw_shutdown()`.
  ///
  /// \pre The given options must have been initialized
  /// i.e. `rmw_init_options_init()` called on it and
  /// an enclave set.
  /// \pre The given context must be zero initialized.
  ///
  /// \post If initialization fails, context will remain zero initialized.
  ///
  /// \remarks If options are zero-initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
  /// If options are initialized but no enclave is provided, then `RMW_RET_INVALID_ARGUMENT`
  /// is returned.
  /// If context has been already initialized (`rmw_init()` was called on it), then
  /// `RMW_RET_INVALID_ARGUMENT` is returned.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// This should be defined by the rmw implementation.
  ///
  /// \param[in] options initialization options to be used during initialization
  /// \param[out] context resulting context struct
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  /// identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_init(
    ffi.Pointer<rmw_init_options_t> options,
    ffi.Pointer<rmw_context_t> context,
  ) {
    return (_rmw_init ??=
        _dylib.lookupFunction<_c_rmw_init, _dart_rmw_init>('rmw_init'))(
      options,
      context,
    );
  }

  _dart_rmw_init? _rmw_init;

  /// /// Shutdown the middleware for a given context.
  ///
  /// \pre The given context must be a valid context which has been initialized with `rmw_init()`.
  ///
  /// \remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
  /// If context has been already invalidated (`rmw_shutdown()` was called on it), then
  /// this function is a no-op and `RMW_RET_OK` is returned.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// This should be defined by the rmw implementation.
  ///
  /// \param[in] context resulting context struct
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if any argument are invalid, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  /// identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_shutdown(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return (_rmw_shutdown ??= _dylib
        .lookupFunction<_c_rmw_shutdown, _dart_rmw_shutdown>('rmw_shutdown'))(
      context,
    );
  }

  _dart_rmw_shutdown? _rmw_shutdown;

  /// /// Finalize a context.
  ///
  /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given context unchanged.
  /// Otherwise, it will proceed despite errors, freeing as much resources as it can and zero
  /// initializing the given context.
  ///
  /// \pre The context to be finalized must have been previously initialized with
  /// `rmw_init()`, and then later invalidated with `rmw_shutdown()`.
  ///
  /// \remarks If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
  /// If context is initialized and valid (`rmw_shutdown()` was not called on it), then
  /// `RMW_RET_INVALID_ARGUMENT` is returned.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// This should be defined by the rmw implementation.
  ///
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  /// identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unspecified error occur.
  int rmw_context_fini(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return (_rmw_context_fini ??=
        _dylib.lookupFunction<_c_rmw_context_fini, _dart_rmw_context_fini>(
            'rmw_context_fini'))(
      context,
    );
  }

  _dart_rmw_context_fini? _rmw_context_fini;

  /// /// Format a string.
  ///
  /// This function just wraps snprintf() as defined in C11 in a portable way.
  ///
  /// On Windows this defaults to the _TRUNCATE behavior of _snprintf_s(), but
  /// only returns -1 if errno is not 0.
  /// Unlike _snprintf_s() which returns -1 when truncation occurs, this function
  /// behaves like snprintf() (http://en.cppreference.com/w/cpp/io/c/fprintf):
  ///
  /// > Number of characters written if successful or negative value if an error
  /// > occurred.
  /// > If the resulting string gets truncated due to buf_size limit, function
  /// > returns the total number of characters (not including the terminating
  /// > null-byte) which would have been written, if the limit was not imposed.
  ///
  /// If `NULL` and `0` are given for buffer and buffer_size respectively, the
  /// size of the string that would be generated is returned.
  /// Either snprintf() or _vscprintf() is used to calculate this value.
  ///
  /// \see snprintf()
  /// \see _snprintf_s()
  /// \returns the number of bytes that would have been written given enough space,
  /// or a negative number if there is an error, but unlike _snprintf_s(),
  /// -1 is not returned if there is truncation.
  int rcutils_snprintf(
    ffi.Pointer<ffi.Int8> buffer,
    int buffer_size,
    ffi.Pointer<ffi.Int8> format,
  ) {
    return (_rcutils_snprintf ??=
        _dylib.lookupFunction<_c_rcutils_snprintf, _dart_rcutils_snprintf>(
            'rcutils_snprintf'))(
      buffer,
      buffer_size,
      format,
    );
  }

  _dart_rcutils_snprintf? _rcutils_snprintf;

  /// /// Format a string with va_list for arguments, see rcutils_snprintf().
  int rcutils_vsnprintf(
    ffi.Pointer<ffi.Int8> buffer,
    int buffer_size,
    ffi.Pointer<ffi.Int8> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return (_rcutils_vsnprintf ??=
        _dylib.lookupFunction<_c_rcutils_vsnprintf, _dart_rcutils_vsnprintf>(
            'rcutils_vsnprintf'))(
      buffer,
      buffer_size,
      format,
      args,
    );
  }

  _dart_rcutils_vsnprintf? _rcutils_vsnprintf;

  bool rcutils_fault_injection_is_test_complete() {
    return (_rcutils_fault_injection_is_test_complete ??= _dylib.lookupFunction<
                _c_rcutils_fault_injection_is_test_complete,
                _dart_rcutils_fault_injection_is_test_complete>(
            'rcutils_fault_injection_is_test_complete'))() !=
        0;
  }

  _dart_rcutils_fault_injection_is_test_complete?
      _rcutils_fault_injection_is_test_complete;

  /// \brief Atomically set the fault injection counter.
  ///
  /// This is typically not the preferred method of interacting directly with the fault injection
  /// logic, instead use `RCUTILS_FAULT_INJECTION_TEST` instead.
  ///
  /// This function may also be used for pausing code inside of a `RCUTILS_FAULT_INJECTION_TEST` with
  /// something like the following:
  ///
  /// RCUTILS_FAULT_INJECTION_TEST({
  /// ...  // code to run with fault injection
  /// int64_t count = rcutils_fault_injection_get_count();
  /// rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);
  /// ...  // code to run without fault injection
  /// rcutils_fault_injection_set_count(count);
  /// ...  // code to run with fault injection
  /// });
  ///
  /// \param count The count to set the fault injection counter to. If count is negative, then fault
  /// injection errors will be disabled. The counter is globally initialized to
  /// RCUTILS_FAULT_INJECTION_NEVER_FAIL.
  void rcutils_fault_injection_set_count(
    int count,
  ) {
    return (_rcutils_fault_injection_set_count ??= _dylib.lookupFunction<
            _c_rcutils_fault_injection_set_count,
            _dart_rcutils_fault_injection_set_count>(
        'rcutils_fault_injection_set_count'))(
      count,
    );
  }

  _dart_rcutils_fault_injection_set_count? _rcutils_fault_injection_set_count;

  /// \brief Atomically get the fault injection counter value
  ///
  /// This function is typically not used directly but instead indirectly inside an
  /// `RCUTILS_FAULT_INJECTION_TEST`
  int rcutils_fault_injection_get_count() {
    return (_rcutils_fault_injection_get_count ??= _dylib.lookupFunction<
            _c_rcutils_fault_injection_get_count,
            _dart_rcutils_fault_injection_get_count>(
        'rcutils_fault_injection_get_count'))();
  }

  _dart_rcutils_fault_injection_get_count? _rcutils_fault_injection_get_count;

  /// \brief Implementation of fault injection decrementer
  ///
  /// This is included inside of macros, so it needs to be exported as a public function, but it
  /// should not be used directly.
  int _rcutils_fault_injection_maybe_fail() {
    return (__rcutils_fault_injection_maybe_fail ??= _dylib.lookupFunction<
            _c__rcutils_fault_injection_maybe_fail,
            _dart__rcutils_fault_injection_maybe_fail>(
        '_rcutils_fault_injection_maybe_fail'))();
  }

  _dart__rcutils_fault_injection_maybe_fail?
      __rcutils_fault_injection_maybe_fail;

  /// /// Forces initialization of thread-local storage if called in a newly created thread.
  ///
  /// If this function is not called beforehand, then the first time the error
  /// state is set or the first time the error message is retrieved, the default
  /// allocator will be used to allocate thread-local storage.
  ///
  /// This function may or may not allocate memory.
  /// The system's thread-local storage implementation may need to allocate
  /// memory, since it usually has no way of knowing how much storage is needed
  /// without knowing how many threads will be created.
  /// Most implementations (e.g. C11, C++11, and pthread) do not have ways to
  /// specify how this memory is allocated, but if the implementation allows, the
  /// given allocator to this function will be used, but is otherwise unused.
  /// This only occurs when creating and destroying threads, which can be avoided
  /// in the "steady" state by reusing pools of threads.
  ///
  /// It is worth considering that repeated thread creation and destruction will
  /// result in repeated memory allocations and could result in memory
  /// fragmentation.
  /// This is typically avoided anyways by using pools of threads.
  ///
  /// In case an error is indicated by the return code, no error message will have
  /// been set.
  ///
  /// If called more than once in a thread, or after implicitly initialized by
  /// setting the error state, it will still return `RCUTILS_RET_OK`, even
  /// if the given allocator is invalid.
  /// Essentially this function does nothing if thread-local storage has already
  /// been called.
  /// If already initialized, the given allocator is ignored, even if it does not
  /// match the allocator used originally to initialize the thread-local storage.
  ///
  /// \param[in] allocator to be used to allocate and deallocate memory
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if the allocator is invalid, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if allocating memory fails, or
  /// \return `RCUTILS_RET_ERROR` if an unspecified error occurs.
  int rcutils_initialize_error_handling_thread_local_storage(
    rcutils_allocator_t allocator,
  ) {
    return (_rcutils_initialize_error_handling_thread_local_storage ??=
        _dylib.lookupFunction<
                _c_rcutils_initialize_error_handling_thread_local_storage,
                _dart_rcutils_initialize_error_handling_thread_local_storage>(
            'rcutils_initialize_error_handling_thread_local_storage'))(
      allocator,
    );
  }

  _dart_rcutils_initialize_error_handling_thread_local_storage?
      _rcutils_initialize_error_handling_thread_local_storage;

  /// /// Set the error message, as well as the file and line on which it occurred.
  ///
  /// This is not meant to be used directly, but instead via the
  /// RCUTILS_SET_ERROR_MSG(msg) macro.
  ///
  /// The error_msg parameter is copied into the internal error storage and must
  /// be null terminated.
  /// The file parameter is copied into the internal error storage and must
  /// be null terminated.
  ///
  /// \param[in] error_string The error message to set.
  /// \param[in] file The path to the file in which the error occurred.
  /// \param[in] line_number The line number on which the error occurred.
  void rcutils_set_error_state(
    ffi.Pointer<ffi.Int8> error_string,
    ffi.Pointer<ffi.Int8> file,
    int line_number,
  ) {
    return (_rcutils_set_error_state ??= _dylib.lookupFunction<
        _c_rcutils_set_error_state,
        _dart_rcutils_set_error_state>('rcutils_set_error_state'))(
      error_string,
      file,
      line_number,
    );
  }

  _dart_rcutils_set_error_state? _rcutils_set_error_state;

  /// /// Return `true` if the error is set, otherwise `false`.
  bool rcutils_error_is_set() {
    return (_rcutils_error_is_set ??= _dylib.lookupFunction<
            _c_rcutils_error_is_set,
            _dart_rcutils_error_is_set>('rcutils_error_is_set'))() !=
        0;
  }

  _dart_rcutils_error_is_set? _rcutils_error_is_set;

  /// /// Return an rcutils_error_state_t which was set with rcutils_set_error_state().
  ///
  /// The returned pointer will be NULL if no error has been set in this thread.
  ///
  /// The returned pointer is valid until RCUTILS_SET_ERROR_MSG, rcutils_set_error_state,
  /// or rcutils_reset_error are called in the same thread.
  ///
  /// \return A pointer to the current error state struct.
  ffi.Pointer<rcutils_error_state_t> rcutils_get_error_state() {
    return (_rcutils_get_error_state ??= _dylib.lookupFunction<
        _c_rcutils_get_error_state,
        _dart_rcutils_get_error_state>('rcutils_get_error_state'))();
  }

  _dart_rcutils_get_error_state? _rcutils_get_error_state;

  /// /// Return the error message followed by `, at <file>:<line>` if set, else "error not set".
  ///
  /// This function is "safe" because it returns a copy of the current error
  /// string or one containing the string "error not set" if no error was set.
  /// This ensures that the copy is owned by the calling thread and is therefore
  /// never invalidated by other error handling calls, and that the C string
  /// inside is always valid and null terminated.
  ///
  /// \return The current error string, with file and line number, or "error not set" if not set.
  rcutils_error_string_t rcutils_get_error_string() {
    return (_rcutils_get_error_string ??= _dylib.lookupFunction<
        _c_rcutils_get_error_string,
        _dart_rcutils_get_error_string>('rcutils_get_error_string'))();
  }

  _dart_rcutils_get_error_string? _rcutils_get_error_string;

  /// /// Reset the error state by clearing any previously set error state.
  void rcutils_reset_error() {
    return (_rcutils_reset_error ??= _dylib.lookupFunction<
        _c_rcutils_reset_error,
        _dart_rcutils_reset_error>('rcutils_reset_error'))();
  }

  _dart_rcutils_reset_error? _rcutils_reset_error;

  /// /// Return an empty array_list struct.
  ///
  /// This function returns an empty and zero initialized array_list struct.
  /// Calling rcutils_array_list_fini() on any non-initialized instance leads
  /// to undefined behavior.
  /// Every instance of array_list_t has to either be zero_initialized with this
  /// function or manually allocated.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// Example:
  ///
  /// ```c
  /// rcutils_array_list_t foo;
  /// rcutils_array_list_fini(&foo); // undefined behavior!
  ///
  /// rcutils_array_list_t bar = rcutils_get_zero_initialized_array_list();
  /// rcutils_array_list_fini(&bar); // ok
  /// ```
  rcutils_array_list_t rcutils_get_zero_initialized_array_list() {
    return (_rcutils_get_zero_initialized_array_list ??= _dylib.lookupFunction<
            _c_rcutils_get_zero_initialized_array_list,
            _dart_rcutils_get_zero_initialized_array_list>(
        'rcutils_get_zero_initialized_array_list'))();
  }

  _dart_rcutils_get_zero_initialized_array_list?
      _rcutils_get_zero_initialized_array_list;

  /// /// Initialize an array list with a given initial capacity.
  ///
  /// This function will initialize a given, zero initialized, array_list to
  /// a given size.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// Example:
  ///
  /// ```c
  /// rcutils_allocator_t allocator = rcutils_get_default_allocator();
  /// rcutils_array_list_t array_list = rcutils_get_zero_initialized_array_list();
  /// rcutils_ret_t ret = rcutils_array_list_init(&array_list, 2, sizeof(int), &allocator);
  /// if (ret != RCUTILS_RET_OK) {
  /// // ... error handling
  /// }
  /// int data = 42;
  /// int out_data = 0;
  /// ret = rcutils_array_list_add(&array_list, &data);
  /// data++;
  /// ret = rcutils_array_list_get(&array_list, 0, &out_data);
  /// assert(42 == out_data);
  /// ret = rcutils_array_list_fini(&array_list);
  /// ```
  ///
  /// \param[inout] array_list object to be initialized
  /// \param[in] initial_capacity the initial capacity to allocate in the list
  /// \param[in] data_size the size (in bytes) of the data object being stored in the list
  /// \param[in] allocator to be used to allocate and deallocate memory
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_array_list_init(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int initial_capacity,
    int data_size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcutils_array_list_init ??= _dylib.lookupFunction<
        _c_rcutils_array_list_init,
        _dart_rcutils_array_list_init>('rcutils_array_list_init'))(
      array_list,
      initial_capacity,
      data_size,
      allocator,
    );
  }

  _dart_rcutils_array_list_init? _rcutils_array_list_init;

  /// /// Finalize an array list, reclaiming all resources.
  ///
  /// This function reclaims any memory owned by the array list.
  ///
  /// The allocator used to initialize the array list is used to deallocate each
  /// entry in the list and the list itself.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] array_list object to be finalized
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_array_list_fini(
    ffi.Pointer<rcutils_array_list_t> array_list,
  ) {
    return (_rcutils_array_list_fini ??= _dylib.lookupFunction<
        _c_rcutils_array_list_fini,
        _dart_rcutils_array_list_fini>('rcutils_array_list_fini'))(
      array_list,
    );
  }

  _dart_rcutils_array_list_fini? _rcutils_array_list_fini;

  /// /// Adds an entry to the list
  ///
  /// This function adds the provided data to the end of the list. A shallow copy of
  /// the provided data is made to store in the list instead of just storing
  /// the pointer to the provided data.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] array_list to add the data to
  /// \param[in] data a pointer to the data to add to the list
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_array_list_add(
    ffi.Pointer<rcutils_array_list_t> array_list,
    ffi.Pointer<ffi.Void> data,
  ) {
    return (_rcutils_array_list_add ??= _dylib.lookupFunction<
        _c_rcutils_array_list_add,
        _dart_rcutils_array_list_add>('rcutils_array_list_add'))(
      array_list,
      data,
    );
  }

  _dart_rcutils_array_list_add? _rcutils_array_list_add;

  /// /// Sets an entry in the list to the provided data
  ///
  /// This function sets the provided data at the specified index in the list.
  /// A shallow copy of the provided data is made to store in the list instead
  /// of just storing the pointer to the provided data.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] array_list to add the data to
  /// \param[in] index the position in the list to set the data
  /// \param[in] data a pointer to the data that will be set in the list
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if index out of bounds, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_array_list_set(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
    ffi.Pointer<ffi.Void> data,
  ) {
    return (_rcutils_array_list_set ??= _dylib.lookupFunction<
        _c_rcutils_array_list_set,
        _dart_rcutils_array_list_set>('rcutils_array_list_set'))(
      array_list,
      index,
      data,
    );
  }

  _dart_rcutils_array_list_set? _rcutils_array_list_set;

  /// /// Removes an entry in the list at the provided index
  ///
  /// This function removes data from the list at the specified index. The capacity
  /// of the list will never decrease when entries are removed.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] array_list to add the data to
  /// \param[in] index the index of the item to remove from the list
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if index out of bounds, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_array_list_remove(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
  ) {
    return (_rcutils_array_list_remove ??= _dylib.lookupFunction<
        _c_rcutils_array_list_remove,
        _dart_rcutils_array_list_remove>('rcutils_array_list_remove'))(
      array_list,
      index,
    );
  }

  _dart_rcutils_array_list_remove? _rcutils_array_list_remove;

  /// /// Retrieves an entry in the list at the provided index
  ///
  /// This function retrieves a copy of the data stored in the list at the provided index.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  ///
  /// \param[in] array_list to add the data to
  /// \param[in] index the index at which to get the data
  /// \param[out] data a copy of the data stored in the list
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_array_list_get(
    ffi.Pointer<rcutils_array_list_t> array_list,
    int index,
    ffi.Pointer<ffi.Void> data,
  ) {
    return (_rcutils_array_list_get ??= _dylib.lookupFunction<
        _c_rcutils_array_list_get,
        _dart_rcutils_array_list_get>('rcutils_array_list_get'))(
      array_list,
      index,
      data,
    );
  }

  _dart_rcutils_array_list_get? _rcutils_array_list_get;

  /// /// Retrieves the size of the provided array_list
  ///
  /// This function retrieves the number of items in the provided array list
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  ///
  /// \param[in] array_list list to get the size of
  /// \param[out] size The number of items currently stored in the list
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_array_list_get_size(
    ffi.Pointer<rcutils_array_list_t> array_list,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return (_rcutils_array_list_get_size ??= _dylib.lookupFunction<
        _c_rcutils_array_list_get_size,
        _dart_rcutils_array_list_get_size>('rcutils_array_list_get_size'))(
      array_list,
      size,
    );
  }

  _dart_rcutils_array_list_get_size? _rcutils_array_list_get_size;

  /// /// Return a zero initialized char array struct.
  ///
  /// \return rcutils_char_array_t a zero initialized char array struct
  rcutils_char_array_t rcutils_get_zero_initialized_char_array() {
    return (_rcutils_get_zero_initialized_char_array ??= _dylib.lookupFunction<
            _c_rcutils_get_zero_initialized_char_array,
            _dart_rcutils_get_zero_initialized_char_array>(
        'rcutils_get_zero_initialized_char_array'))();
  }

  _dart_rcutils_get_zero_initialized_char_array?
      _rcutils_get_zero_initialized_char_array;

  /// /// Initialize a zero initialized char array struct.
  ///
  /// This function may leak if the char array struct is already
  /// pre-initialized.
  /// If the capacity is set to 0, no memory is allocated and the internal buffer
  /// is still NULL.
  ///
  /// \param[in] char_array a pointer to the to be initialized char array struct
  /// \param[in] buffer_capacity the size of the memory to allocate for the byte stream
  /// \param[in] allocator the allocator to use for the memory allocation
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENTS` if any arguments are invalid, or
  /// \return 'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_init(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int buffer_capacity,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcutils_char_array_init ??= _dylib.lookupFunction<
        _c_rcutils_char_array_init,
        _dart_rcutils_char_array_init>('rcutils_char_array_init'))(
      char_array,
      buffer_capacity,
      allocator,
    );
  }

  _dart_rcutils_char_array_init? _rcutils_char_array_init;

  /// /// Finalize a char array struct.
  ///
  /// Cleans up and deallocates any resources owned by rcutils_char_array_t.
  /// The array passed to this function needs to have been initialized by
  /// rcutils_char_array_init().
  /// If .owns_buffer is false, this function has no effect because that
  /// implies that the char_array does not own the internal buffer.
  /// Passing an uninitialized instance to this function leads to undefined
  /// behavior.
  ///
  /// \param[in] char_array pointer to the rcutils_char_array_t to be cleaned up
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENTS` if the char_array argument is invalid
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_fini(
    ffi.Pointer<rcutils_char_array_t> char_array,
  ) {
    return (_rcutils_char_array_fini ??= _dylib.lookupFunction<
        _c_rcutils_char_array_fini,
        _dart_rcutils_char_array_fini>('rcutils_char_array_fini'))(
      char_array,
    );
  }

  _dart_rcutils_char_array_fini? _rcutils_char_array_fini;

  /// /// Resize the internal buffer of the char array.
  ///
  /// The internal buffer of the char array can be resized dynamically if needed.
  /// If the new size is smaller than the current capacity, then the memory is
  /// truncated.
  /// Be aware, that this will deallocate the memory and therefore invalidates any
  /// pointers to this storage.
  /// If the new size is larger, new memory is getting allocated and the existing
  /// content is copied over.
  /// Note that if the array doesn't own the current buffer the function just
  /// allocates a new block of memory and copies the contents of the old buffer
  /// instead of resizing the existing buffer.
  ///
  /// \param[in] char_array pointer to the instance of rcutils_char_array_t which is being resized
  /// \param[in] new_size the new size of the internal buffer
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if new_size is set to zero
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_resize(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int new_size,
  ) {
    return (_rcutils_char_array_resize ??= _dylib.lookupFunction<
        _c_rcutils_char_array_resize,
        _dart_rcutils_char_array_resize>('rcutils_char_array_resize'))(
      char_array,
      new_size,
    );
  }

  _dart_rcutils_char_array_resize? _rcutils_char_array_resize;

  /// /// Expand the internal buffer of the char array.
  ///
  /// This function is equivalent to `rcutils_char_array_resize` except that it resizes
  /// the internal buffer only when it is not big enough.
  /// If the buffer is already big enough for `new_size`, it returns `RCUTILS_RET_OK` without
  /// doing anything.
  ///
  /// \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized
  /// \param[in] new_size the new size of the internal buffer
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_expand_as_needed(
    ffi.Pointer<rcutils_char_array_t> char_array,
    int new_size,
  ) {
    return (_rcutils_char_array_expand_as_needed ??= _dylib.lookupFunction<
            _c_rcutils_char_array_expand_as_needed,
            _dart_rcutils_char_array_expand_as_needed>(
        'rcutils_char_array_expand_as_needed'))(
      char_array,
      new_size,
    );
  }

  _dart_rcutils_char_array_expand_as_needed?
      _rcutils_char_array_expand_as_needed;

  /// /// Produce output according to format and args.
  ///
  /// This function is equivalent to `vsprintf(char_array->buffer, format, args)`
  /// except that the buffer grows as needed so a user doesn't have to deal with
  /// memory management.
  /// The `va_list args` will be cloned before being used, so a user can safely
  /// use it again after calling this function.
  ///
  /// \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being
  /// written to
  /// \param[in] format the format string used by the underlying `vsnprintf`
  /// \param[in] args the `va_list` used by the underlying `vsnprintf`
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_vsprintf(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> format,
    ffi.Pointer<__va_list_tag> args,
  ) {
    return (_rcutils_char_array_vsprintf ??= _dylib.lookupFunction<
        _c_rcutils_char_array_vsprintf,
        _dart_rcutils_char_array_vsprintf>('rcutils_char_array_vsprintf'))(
      char_array,
      format,
      args,
    );
  }

  _dart_rcutils_char_array_vsprintf? _rcutils_char_array_vsprintf;

  /// /// Append a string (or part of it) to the string in buffer.
  ///
  /// This function treats the internal buffer as a string and appends the src string to it.
  /// If src is longer than n, n bytes will be used and an extra null byte will be appended.
  /// It is virtually equivalent to `strncat(char_array->buffer, src, n)` except that the buffer
  /// grows as needed so a user doesn't have to deal with memory management.
  ///
  /// \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being appended to
  /// \param[in] src the string to be appended to the end of the string in buffer
  /// \param[in] n it uses at most n bytes from the src string
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_strncat(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> src,
    int n,
  ) {
    return (_rcutils_char_array_strncat ??= _dylib.lookupFunction<
        _c_rcutils_char_array_strncat,
        _dart_rcutils_char_array_strncat>('rcutils_char_array_strncat'))(
      char_array,
      src,
      n,
    );
  }

  _dart_rcutils_char_array_strncat? _rcutils_char_array_strncat;

  /// /// Append a string to the string in buffer.
  ///
  /// This function treats the internal buffer as a string and appends the src string to it.
  /// It is virtually equivalent to `strcat(char_array->buffer, src)` except that the buffer
  /// grows as needed. That is to say, a user can safely use it without doing calculation or
  /// checks on the sizes of the src and buffer.
  ///
  /// \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being
  /// appended to
  /// \param[in] src the string to be appended to the end of the string in buffer
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_strcat(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> src,
  ) {
    return (_rcutils_char_array_strcat ??= _dylib.lookupFunction<
        _c_rcutils_char_array_strcat,
        _dart_rcutils_char_array_strcat>('rcutils_char_array_strcat'))(
      char_array,
      src,
    );
  }

  _dart_rcutils_char_array_strcat? _rcutils_char_array_strcat;

  /// /// Copy memory to buffer.
  ///
  /// This function is equivalent to `memcpy(char_array->buffer, src, n)` except that the buffer
  /// grows as needed so a user doesn't have to worry about overflow.
  ///
  /// \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being resized
  /// \param[in] src the memory to be copied from
  /// \param[in] n a total of n bytes will be copied
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_memcpy(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> src,
    int n,
  ) {
    return (_rcutils_char_array_memcpy ??= _dylib.lookupFunction<
        _c_rcutils_char_array_memcpy,
        _dart_rcutils_char_array_memcpy>('rcutils_char_array_memcpy'))(
      char_array,
      src,
      n,
    );
  }

  _dart_rcutils_char_array_memcpy? _rcutils_char_array_memcpy;

  /// /// Copy a string to buffer.
  ///
  /// This function is equivalent to `strcpy(char_array->buffer, src)` except that the buffer
  /// grows as needed so that `src` will fit without overflow.
  ///
  /// \param[inout] char_array pointer to the instance of rcutils_char_array_t which is being
  /// copied to
  /// \param[in] src the string to be copied from
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_char_array_strcpy(
    ffi.Pointer<rcutils_char_array_t> char_array,
    ffi.Pointer<ffi.Int8> src,
  ) {
    return (_rcutils_char_array_strcpy ??= _dylib.lookupFunction<
        _c_rcutils_char_array_strcpy,
        _dart_rcutils_char_array_strcpy>('rcutils_char_array_strcpy'))(
      char_array,
      src,
    );
  }

  _dart_rcutils_char_array_strcpy? _rcutils_char_array_strcpy;

  /// /// A hashing function for a null terminated c string.
  ///
  /// A hashing function for a null terminated c string.
  /// Should be used when your key is just a pointer to a c-string
  int rcutils_hash_map_string_hash_func(
    ffi.Pointer<ffi.Void> key_str,
  ) {
    return (_rcutils_hash_map_string_hash_func ??= _dylib.lookupFunction<
            _c_rcutils_hash_map_string_hash_func,
            _dart_rcutils_hash_map_string_hash_func>(
        'rcutils_hash_map_string_hash_func'))(
      key_str,
    );
  }

  _dart_rcutils_hash_map_string_hash_func? _rcutils_hash_map_string_hash_func;

  /// /// A comparison function for a null terminated c string.
  ///
  /// A comparison function for a null terminated c string.
  /// Should be used when your key is just a pointer to a c-string
  int rcutils_hash_map_string_cmp_func(
    ffi.Pointer<ffi.Void> val1,
    ffi.Pointer<ffi.Void> val2,
  ) {
    return (_rcutils_hash_map_string_cmp_func ??= _dylib.lookupFunction<
            _c_rcutils_hash_map_string_cmp_func,
            _dart_rcutils_hash_map_string_cmp_func>(
        'rcutils_hash_map_string_cmp_func'))(
      val1,
      val2,
    );
  }

  _dart_rcutils_hash_map_string_cmp_func? _rcutils_hash_map_string_cmp_func;

  rcutils_hash_map_t rcutils_get_zero_initialized_hash_map() {
    return (_rcutils_get_zero_initialized_hash_map ??= _dylib.lookupFunction<
            _c_rcutils_get_zero_initialized_hash_map,
            _dart_rcutils_get_zero_initialized_hash_map>(
        'rcutils_get_zero_initialized_hash_map'))();
  }

  _dart_rcutils_get_zero_initialized_hash_map?
      _rcutils_get_zero_initialized_hash_map;

  /// /// Initialize a rcutils_hash_map_t, allocating space for given capacity.
  ///
  /// This function initializes the rcutils_hash_map_t with a given initial
  /// capacity for entries.
  /// Note this does not allocate space for keys or values in the hash_map, just the
  /// arrays of pointers to the keys and values.
  /// rcutils_hash_map_set() should still be used when assigning values.
  ///
  /// The hash_map argument should point to allocated memory and should have
  /// been zero initialized with rcutils_get_zero_initialized_hash_map().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// Example:
  /// ```c
  /// rcutils_hash_map_t hash_map = rcutils_get_zero_initialized_hash_map();
  /// rcutils_ret_t ret =
  /// rcutils_hash_map_init(&hash_map, 10, rcutils_get_default_allocator());
  /// if (ret != RCUTILS_RET_OK) {
  /// // ... do error handling
  /// }
  /// // ... use the hash_map and when done:
  /// ret = rcutils_hash_map_fini(&hash_map);
  /// if (ret != RCUTILS_RET_OK) {
  /// // ... do error handling
  /// }
  /// ```
  ///
  /// \param[inout] hash_map rcutils_hash_map_t to be initialized
  /// \param[in] initial_capacity the amount of initial capacity for the hash_map
  /// \param[in] key_size the size (in bytes) of the key used to index the data
  /// \param[in] data_size the size (in bytes) of the data being stored
  /// \param[in] key_hashing_func a function that returns a hashed value for a key
  /// \param[in] key_cmp_func a function used to compare keys
  /// \param[in] allocator the allocator to use through out the lifetime of the hash_map
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_STRING_MAP_ALREADY_INIT` if already initialized, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_hash_map_init(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    int initial_capacity,
    int key_size,
    int data_size,
    ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_hasher_t>>
        key_hashing_func,
    ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_cmp_t>> key_cmp_func,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcutils_hash_map_init ??= _dylib.lookupFunction<
        _c_rcutils_hash_map_init,
        _dart_rcutils_hash_map_init>('rcutils_hash_map_init'))(
      hash_map,
      initial_capacity,
      key_size,
      data_size,
      key_hashing_func,
      key_cmp_func,
      allocator,
    );
  }

  _dart_rcutils_hash_map_init? _rcutils_hash_map_init;

  /// /// Finalize the previously initialized hash_map struct.
  ///
  /// This function will free any resources which were created when initializing
  /// or when calling rcutils_hash_map_set().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] hash_map rcutils_hash_map_t to be finalized
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_hash_map_fini(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
  ) {
    return (_rcutils_hash_map_fini ??= _dylib.lookupFunction<
        _c_rcutils_hash_map_fini,
        _dart_rcutils_hash_map_fini>('rcutils_hash_map_fini'))(
      hash_map,
    );
  }

  _dart_rcutils_hash_map_fini? _rcutils_hash_map_fini;

  /// /// Get the current capacity of the hash_map.
  ///
  /// This function will return the internal capacity of the hash_map, which is the
  /// number of buckets the hash_map uses to sort the keys.
  /// The capacity does not indicate how many key value pairs are stored in the
  /// hash_map, the rcutils_hash_map_get_size() function can provide that, nor the
  /// maximum number that can be stored without increasing the capacity.
  /// The capacity can be set initially with rcutils_hash_map_init().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] hash_map rcutils_hash_map_t to be queried
  /// \param[out] capacity capacity of the hash_map
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_hash_map_get_capacity(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Uint64> capacity,
  ) {
    return (_rcutils_hash_map_get_capacity ??= _dylib.lookupFunction<
        _c_rcutils_hash_map_get_capacity,
        _dart_rcutils_hash_map_get_capacity>('rcutils_hash_map_get_capacity'))(
      hash_map,
      capacity,
    );
  }

  _dart_rcutils_hash_map_get_capacity? _rcutils_hash_map_get_capacity;

  /// /// Get the current size of the hash_map.
  ///
  /// This function will return the internal size of the hash_map, which is the
  /// current number of key value pairs in the hash_map.
  /// The size is changed when calling rcutils_hash_map_set() or rcutils_hash_map_unset().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] hash_map rcutils_hash_map_t to be queried
  /// \param[out] size size of the hash_map
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_hash_map_get_size(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return (_rcutils_hash_map_get_size ??= _dylib.lookupFunction<
        _c_rcutils_hash_map_get_size,
        _dart_rcutils_hash_map_get_size>('rcutils_hash_map_get_size'))(
      hash_map,
      size,
    );
  }

  _dart_rcutils_hash_map_get_size? _rcutils_hash_map_get_size;

  /// /// Set a key value pair in the hash_map, increasing capacity if necessary.
  ///
  /// If the key already exists in the map then the value is updated to the new value
  /// provided. If it does not already exist then a new entry is added for the new key
  /// and value. The capacity will be increased if needed.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] hash_map rcutils_hash_map_t to be updated
  /// \param[in] key hash_map key
  /// \param[in] value value for given hash_map key
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_hash_map_set(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> value,
  ) {
    return (_rcutils_hash_map_set ??= _dylib.lookupFunction<
        _c_rcutils_hash_map_set,
        _dart_rcutils_hash_map_set>('rcutils_hash_map_set'))(
      hash_map,
      key,
      value,
    );
  }

  _dart_rcutils_hash_map_set? _rcutils_hash_map_set;

  /// /// Unset a key value pair in the hash_map.
  ///
  /// Unsets the key value pair in the hash_map and frees any internal resources allocated
  /// for the entry. This function will never decrease the capacity when removing keys.
  /// If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] hash_map rcutils_hash_map_t to be updated
  /// \param[in] key hash_map key, must be null terminated c string
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  /// \return `RCUTILS_RET_STRING_KEY_NOT_FOUND` if the key is not found in the map, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_hash_map_unset(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
  ) {
    return (_rcutils_hash_map_unset ??= _dylib.lookupFunction<
        _c_rcutils_hash_map_unset,
        _dart_rcutils_hash_map_unset>('rcutils_hash_map_unset'))(
      hash_map,
      key,
    );
  }

  _dart_rcutils_hash_map_unset? _rcutils_hash_map_unset;

  /// /// Get whether or not a key exists.
  ///
  /// Returns true if the provided key exists in the hash_map or false if it does not or
  /// if the hash_map or key are invalid.
  /// In all cases no error message is set.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] hash_map rcutils_hash_map_t to be searched
  /// \param[in] key hash_map key, must be null terminated c string
  /// \return `true` if key is in the hash_map, or
  /// \return `false` if key is not in the hash_map, or
  /// \return `false` for invalid arguments, or
  /// \return `false` if the hash_map is invalid
  bool rcutils_hash_map_key_exists(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
  ) {
    return (_rcutils_hash_map_key_exists ??= _dylib.lookupFunction<
            _c_rcutils_hash_map_key_exists,
            _dart_rcutils_hash_map_key_exists>('rcutils_hash_map_key_exists'))(
          hash_map,
          key,
        ) !=
        0;
  }

  _dart_rcutils_hash_map_key_exists? _rcutils_hash_map_key_exists;

  /// /// Get value given a key.
  ///
  /// This function can be used to retrieve a shallow copy of the stored data. The data
  /// pointer must point to a section of memory large enough to copy the full size of
  /// the data being stored, which is specified when the hash_map in initialized.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] hash_map rcutils_hash_map_t to be searched
  /// \param[in] key hash_map key to look up the data for
  /// \param[out] data A copy of the data stored in the map
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  /// \return `RCUTILS_RET_NOT_FOUND` if the key doesn't exist in the map, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_hash_map_get(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> data,
  ) {
    return (_rcutils_hash_map_get ??= _dylib.lookupFunction<
        _c_rcutils_hash_map_get,
        _dart_rcutils_hash_map_get>('rcutils_hash_map_get'))(
      hash_map,
      key,
      data,
    );
  }

  _dart_rcutils_hash_map_get? _rcutils_hash_map_get;

  /// /// Get the next key in the hash_map, unless NULL is given, then get the first key.
  ///
  /// This function allows you to iteratively get each key/value pair in the hash_map.
  ///
  /// If NULL is given for the previous_key, then the first key in the hash_map is returned.
  /// If that returned key is given as the previous_key for the next call to this function,
  /// then the next key in the hash_map is returned.
  /// If there are no more keys in the hash_map or if the given key is not in the hash_map,
  /// an error will be returned.
  ///
  /// The order of the keys in the hash_map is arbitrary and if the hash_map is modified
  /// between calls to this function the behavior is undefined.
  /// If the hash_map is modified then iteration should begin again by passing NULL to
  /// get the first key again.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// Example:
  /// ```c
  /// printf("entries in the hash_map:\n");
  /// int key = 0, data = 0;
  /// rcutils_ret_t status = rcutils_hash_map_get_next_key(&hash_map, NULL, &key, &data);
  /// while (RCUTILS_RET_OK == status) {
  /// printf("%i: %i\n", key, data);
  /// status = rcutils_hash_map_get_next_key(&hash_map, &key, &key, &data);
  /// }
  /// ```
  ///
  /// \param[in] hash_map rcutils_hash_map_t to be queried
  /// \param[in] previous_key NULL to get the first key or the previous key to get the next for
  /// \param[out] key A copy of the next key in the sequence
  /// \param[out] data A copy of the next data in the sequence
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or
  /// \return `RCUTILS_RET_NOT_FOUND` if the previous_key doesn't exist in the map, or
  /// \return `RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES` if there is no more data beyound the previous_key, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_hash_map_get_next_key_and_data(
    ffi.Pointer<rcutils_hash_map_t> hash_map,
    ffi.Pointer<ffi.Void> previous_key,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.Void> data,
  ) {
    return (_rcutils_hash_map_get_next_key_and_data ??= _dylib.lookupFunction<
            _c_rcutils_hash_map_get_next_key_and_data,
            _dart_rcutils_hash_map_get_next_key_and_data>(
        'rcutils_hash_map_get_next_key_and_data'))(
      hash_map,
      previous_key,
      key,
      data,
    );
  }

  _dart_rcutils_hash_map_get_next_key_and_data?
      _rcutils_hash_map_get_next_key_and_data;

  /// /// Interface to qsort with rcutils-style argument validation.
  ///
  /// This function changes the order of the elements in the array so that they
  /// are in ascending order according to the given comparison function.
  ///
  /// This function is thread-safe.
  ///
  /// \param[inout] ptr object whose elements should be sorted.
  /// \param[in] count number of elements present in the object.
  /// \param[in] size size of each element, in bytes.
  /// \param[in] comp function used to compare two elements.
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs.
  int rcutils_qsort(
    ffi.Pointer<ffi.Void> ptr,
    int count,
    int size,
    ffi.Pointer<ffi.NativeFunction<_typedefC_5>> comp,
  ) {
    return (_rcutils_qsort ??=
        _dylib.lookupFunction<_c_rcutils_qsort, _dart_rcutils_qsort>(
            'rcutils_qsort'))(
      ptr,
      count,
      size,
      comp,
    );
  }

  _dart_rcutils_qsort? _rcutils_qsort;

  /// /// Return an empty string array struct.
  ///
  /// This function returns an empty and zero initialized string array struct.
  /// Calling rcutils_string_array_fini() on any non-initialized instance leads
  /// to undefined behavior.
  /// Every instance of string_array_t has to either be zero_initialized with this
  /// function or manually allocated.
  ///
  /// Example:
  ///
  /// ```c
  /// rcutils_string_array_t foo;
  /// rcutils_string_array_fini(&foo); // undefined behavior!
  ///
  /// rcutils_string_array_t bar = rcutils_get_zero_initialized_string_array();
  /// rcutils_string_array_fini(&bar); // ok
  /// ```
  rcutils_string_array_t rcutils_get_zero_initialized_string_array() {
    return (_rcutils_get_zero_initialized_string_array ??=
        _dylib.lookupFunction<_c_rcutils_get_zero_initialized_string_array,
                _dart_rcutils_get_zero_initialized_string_array>(
            'rcutils_get_zero_initialized_string_array'))();
  }

  _dart_rcutils_get_zero_initialized_string_array?
      _rcutils_get_zero_initialized_string_array;

  /// /// Initialize a string array with a given size.
  ///
  /// This function will initialize a given, zero initialized, string array to
  /// a given size.
  ///
  /// Note that putting a string into the array gives owenship to the array.
  ///
  /// Example:
  ///
  /// ```c
  /// rcutils_allocator_t allocator = rcutils_get_default_allocator();
  /// rcutils_string_array_t string_array = rcutils_get_zero_initialized_string_array();
  /// rcutils_ret_t ret = rcutils_string_array_init(&string_array, 2, &allocator);
  /// if (ret != RCUTILS_RET_OK) {
  /// // ... error handling
  /// }
  /// string_array.data[0] = rcutils_strdup("Hello", &allocator);
  /// string_array.data[1] = rcutils_strdup("World", &allocator);
  /// ret = rcutils_string_array_fini(&string_array);
  ///
  /// \param[inout] string_array object to be initialized
  /// \param[in] size the size the array should be
  /// \param[in] allocator to be used to allocate and deallocate memory
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  /// ```
  int rcutils_string_array_init(
    ffi.Pointer<rcutils_string_array_t> string_array,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcutils_string_array_init ??= _dylib.lookupFunction<
        _c_rcutils_string_array_init,
        _dart_rcutils_string_array_init>('rcutils_string_array_init'))(
      string_array,
      size,
      allocator,
    );
  }

  _dart_rcutils_string_array_init? _rcutils_string_array_init;

  /// /// Finalize a string array, reclaiming all resources.
  ///
  /// This function reclaims any memory owned by the string array, including the
  /// strings it references.
  ///
  /// The allocator used to initialize the string array is used to deallocate each
  /// string in the array and the array of strings itself.
  ///
  /// \param[inout] string_array object to be finalized
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_array_fini(
    ffi.Pointer<rcutils_string_array_t> string_array,
  ) {
    return (_rcutils_string_array_fini ??= _dylib.lookupFunction<
        _c_rcutils_string_array_fini,
        _dart_rcutils_string_array_fini>('rcutils_string_array_fini'))(
      string_array,
    );
  }

  _dart_rcutils_string_array_fini? _rcutils_string_array_fini;

  /// /// Compare two string arrays.
  ///
  /// The two string arrays are compared according to lexicographical order.
  ///
  /// \param[in] lhs The first string array.
  /// \param[in] rhs The second string array.
  /// \param[out] res Negative value if `lhs` appears before `rhs` in lexicographical order.
  /// Zero if `lhs` and `rhs` are equal.
  /// Positive value if `lhs` appears after `rhs in lexographical order.
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if any argument is `NULL`, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if `lhs->data` or `rhs->data` is `NULL`, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs.
  int rcutils_string_array_cmp(
    ffi.Pointer<rcutils_string_array_t> lhs,
    ffi.Pointer<rcutils_string_array_t> rhs,
    ffi.Pointer<ffi.Int32> res,
  ) {
    return (_rcutils_string_array_cmp ??= _dylib.lookupFunction<
        _c_rcutils_string_array_cmp,
        _dart_rcutils_string_array_cmp>('rcutils_string_array_cmp'))(
      lhs,
      rhs,
      res,
    );
  }

  _dart_rcutils_string_array_cmp? _rcutils_string_array_cmp;

  /// /// Resize a string array, reclaiming removed resources.
  ///
  /// This function changes the size of an existing string array.
  /// If the new size is larger, new entries are added to the end of the array and
  /// are zero- initialized.
  /// If the new size is smaller, entries are removed from the end of the array
  /// and their resources reclaimed.
  ///
  /// \par Note:
  /// Resizing to 0 is not a substitute for calling ::rcutils_string_array_fini.
  ///
  /// \par Note:
  /// If this function fails, \p string_array remains unchanged and should still
  /// be reclaimed with ::rcutils_string_array_fini.
  ///
  /// \param[inout] string_array object to be resized.
  /// \param[in] new_size the size the array should be changed to.
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs.
  int rcutils_string_array_resize(
    ffi.Pointer<rcutils_string_array_t> string_array,
    int new_size,
  ) {
    return (_rcutils_string_array_resize ??= _dylib.lookupFunction<
        _c_rcutils_string_array_resize,
        _dart_rcutils_string_array_resize>('rcutils_string_array_resize'))(
      string_array,
      new_size,
    );
  }

  _dart_rcutils_string_array_resize? _rcutils_string_array_resize;

  /// /// Lexicographic comparer for pointers to string pointers.
  ///
  /// This functions compares pointers to string pointers lexicographically
  /// ascending.
  ///
  /// \param[in] lhs pointer to the first string pointer.
  /// \param[in] rhs pointer to the second string pointer.
  /// \return <0 if lhs is lexicographically lower, or
  /// \return 0 if the strings are the same, or
  /// \return >0 if lhs is lexicographically higher.
  int rcutils_string_array_sort_compare(
    ffi.Pointer<ffi.Void> lhs,
    ffi.Pointer<ffi.Void> rhs,
  ) {
    return (_rcutils_string_array_sort_compare ??= _dylib.lookupFunction<
            _c_rcutils_string_array_sort_compare,
            _dart_rcutils_string_array_sort_compare>(
        'rcutils_string_array_sort_compare'))(
      lhs,
      rhs,
    );
  }

  _dart_rcutils_string_array_sort_compare? _rcutils_string_array_sort_compare;

  /// /// Sort a string array according to lexicographical order.
  ///
  /// This function changes the order of the entries in a string array so that
  /// they are in lexicographically ascending order.
  /// Empty entries are placed at the end of the array.
  ///
  /// \param[inout] string_array object whose elements should be sorted.
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs.
  int rcutils_string_array_sort(
    ffi.Pointer<rcutils_string_array_t> string_array,
  ) {
    return (_rcutils_string_array_sort ??= _dylib.lookupFunction<
        _c_rcutils_string_array_sort,
        _dart_rcutils_string_array_sort>('rcutils_string_array_sort'))(
      string_array,
    );
  }

  _dart_rcutils_string_array_sort? _rcutils_string_array_sort;

  rcutils_string_map_t rcutils_get_zero_initialized_string_map() {
    return (_rcutils_get_zero_initialized_string_map ??= _dylib.lookupFunction<
            _c_rcutils_get_zero_initialized_string_map,
            _dart_rcutils_get_zero_initialized_string_map>(
        'rcutils_get_zero_initialized_string_map'))();
  }

  _dart_rcutils_get_zero_initialized_string_map?
      _rcutils_get_zero_initialized_string_map;

  /// /// Initialize a rcutils_string_map_t, allocating space for given capacity.
  ///
  /// This function initializes the rcutils_string_map_t with a given initial
  /// capacity for entries.
  /// Note this does not allocate space for keys or values in the map, just the
  /// arrays of pointers to the keys and values.
  /// rcutils_string_map_set() should still be used when assigning values.
  ///
  /// The string_map argument should point to allocated memory and should have
  /// been zero initialized with rcutils_get_zero_initialized_string_map().
  /// For example:
  ///
  /// ```c
  /// rcutils_string_map_t string_map = rcutils_get_zero_initialized_string_map();
  /// rcutils_ret_t ret =
  /// rcutils_string_map_init(&string_map, 10, rcutils_get_default_allocator());
  /// if (ret != RCUTILS_RET_OK) {
  /// // ... do error handling
  /// }
  /// // ... use the string map and when done:
  /// ret = rcutils_string_map_fini(&string_map);
  /// if (ret != RCUTILS_RET_OK) {
  /// // ... do error handling
  /// }
  /// ```
  ///
  /// \param[inout] string_map rcutils_string_map_t to be initialized
  /// \param[in] initial_capacity the amount of initial capacity for the string map
  /// \param[in] allocator the allocator to use through out the lifetime of the map
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_STRING_MAP_ALREADY_INIT` if already initialized, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_init(
    ffi.Pointer<rcutils_string_map_t> string_map,
    int initial_capacity,
    rcutils_allocator_t allocator,
  ) {
    return (_rcutils_string_map_init ??= _dylib.lookupFunction<
        _c_rcutils_string_map_init,
        _dart_rcutils_string_map_init>('rcutils_string_map_init'))(
      string_map,
      initial_capacity,
      allocator,
    );
  }

  _dart_rcutils_string_map_init? _rcutils_string_map_init;

  /// /// Finalize the previously initialized string map struct.
  ///
  /// This function will free any resources which were created when initializing
  /// or when calling rcutils_string_map_set().
  ///
  /// \param[inout] string_map rcutils_string_map_t to be finalized
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_fini(
    ffi.Pointer<rcutils_string_map_t> string_map,
  ) {
    return (_rcutils_string_map_fini ??= _dylib.lookupFunction<
        _c_rcutils_string_map_fini,
        _dart_rcutils_string_map_fini>('rcutils_string_map_fini'))(
      string_map,
    );
  }

  _dart_rcutils_string_map_fini? _rcutils_string_map_fini;

  /// /// Get the current capacity of the string map.
  ///
  /// This function will return the internal capacity of the map, which is the
  /// maximum number of key value pairs the map could hold.
  /// The capacity can be set initially with rcutils_string_map_init() or
  /// with rcutils_string_map_reserve().
  /// The capacity does not indicate how many key value paris are stored in the
  /// map, the rcutils_string_map_get_size() function can provide that.
  ///
  /// \param[in] string_map rcutils_string_map_t to be queried
  /// \param[out] capacity capacity of the string map
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_get_capacity(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Uint64> capacity,
  ) {
    return (_rcutils_string_map_get_capacity ??= _dylib.lookupFunction<
            _c_rcutils_string_map_get_capacity,
            _dart_rcutils_string_map_get_capacity>(
        'rcutils_string_map_get_capacity'))(
      string_map,
      capacity,
    );
  }

  _dart_rcutils_string_map_get_capacity? _rcutils_string_map_get_capacity;

  /// /// Get the current size of the string map.
  ///
  /// This function will return the internal size of the map, which is the
  /// current number of key value pairs in the map.
  /// The size is changed when calling rcutils_string_map_set_no_resize(),
  /// rcutils_string_map_set(), or rcutils_string_map_unset().
  ///
  /// \param[in] string_map rcutils_string_map_t to be queried
  /// \param[out] size size of the string map
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_get_size(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return (_rcutils_string_map_get_size ??= _dylib.lookupFunction<
        _c_rcutils_string_map_get_size,
        _dart_rcutils_string_map_get_size>('rcutils_string_map_get_size'))(
      string_map,
      size,
    );
  }

  _dart_rcutils_string_map_get_size? _rcutils_string_map_get_size;

  /// /// Reserve a given amount of capacity in the map.
  ///
  /// Increases the capacity of the map to at least the given size.
  ///
  /// If the current capacity is less than requested capacity then the capacity
  /// is increased using the allocator given during initialization of the map in
  /// rcutils_string_map_init().
  /// If the requested capacity is less than the current capacity, the capacity
  /// may be reduced, but no existing key value pairs will be truncated to do so.
  /// In effect, the capacity will be shrunk to fit the number of items in map or
  /// the requested capacity, which ever is larger.
  ///
  /// If recovering all resources is desired first call rcutils_string_map_clear()
  /// and then this function with a capacity of 0.
  ///
  /// \param[inout] string_map rcutils_string_map_t to have space reserved in
  /// \param[in] capacity requested size to reserve in the map
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_reserve(
    ffi.Pointer<rcutils_string_map_t> string_map,
    int capacity,
  ) {
    return (_rcutils_string_map_reserve ??= _dylib.lookupFunction<
        _c_rcutils_string_map_reserve,
        _dart_rcutils_string_map_reserve>('rcutils_string_map_reserve'))(
      string_map,
      capacity,
    );
  }

  _dart_rcutils_string_map_reserve? _rcutils_string_map_reserve;

  /// /// Remove all key value pairs from the map.
  ///
  /// This function will remove all key value pairs from the map, and it will
  /// reclaim all resources allocated as a result of setting key value pairs.
  /// rcutils_string_map_fini() should still be called after this.
  ///
  /// \param[inout] string_map rcutils_string_map_t to be cleared
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_clear(
    ffi.Pointer<rcutils_string_map_t> string_map,
  ) {
    return (_rcutils_string_map_clear ??= _dylib.lookupFunction<
        _c_rcutils_string_map_clear,
        _dart_rcutils_string_map_clear>('rcutils_string_map_clear'))(
      string_map,
    );
  }

  _dart_rcutils_string_map_clear? _rcutils_string_map_clear;

  /// /// Set a key value pair in the map, increasing capacity if necessary.
  ///
  /// The capacity will be increased if needed using rcutils_string_map_reserve().
  /// Otherwise it is the same as rcutils_string_map_set_no_resize().
  ///
  /// \see rcutils_string_map_set_no_resize()
  ///
  /// \param[inout] string_map rcutils_string_map_t to be updated
  /// \param[in] key map key, must be null terminated c string
  /// \param[in] value value for given map key, must be null terminated c string
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_set(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return (_rcutils_string_map_set ??= _dylib.lookupFunction<
        _c_rcutils_string_map_set,
        _dart_rcutils_string_map_set>('rcutils_string_map_set'))(
      string_map,
      key,
      value,
    );
  }

  _dart_rcutils_string_map_set? _rcutils_string_map_set;

  /// /// Set a key value pair in the map but only if the map has enough capacity.
  ///
  /// If the map already contains the given key, the existing value will be
  /// replaced with the given value.
  /// If the map does not contain the given key, and the map has additional
  /// unused capacity, then it will store the given key and value in the map.
  /// If there is no unused capacity in the map, then RCUTILS_RET_NOT_ENOUGH_SPACE
  /// is returned.
  ///
  /// The given key and value c strings are copied into the map, and so storage is
  /// allocated for them in the map when this function is called if necessary.
  /// The storage allocated for this purpose is reclaimed either when
  /// rcutils_string_map_fini() is called on this map or when using this function
  /// or rcutils_string_map_unset().
  ///
  /// Any allocation that occurs in this functions uses the allocator of the map,
  /// which is given when the map is initialized in rcutils_string_map_init().
  ///
  /// \param[inout] string_map rcutils_string_map_t to be updated
  /// \param[in] key map key, must be null terminated c string
  /// \param[in] value value for given map key, must be null terminated c string
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  /// \return `RCUTILS_RET_NOT_ENOUGH_SPACE` if map is full, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_set_no_resize(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return (_rcutils_string_map_set_no_resize ??= _dylib.lookupFunction<
            _c_rcutils_string_map_set_no_resize,
            _dart_rcutils_string_map_set_no_resize>(
        'rcutils_string_map_set_no_resize'))(
      string_map,
      key,
      value,
    );
  }

  _dart_rcutils_string_map_set_no_resize? _rcutils_string_map_set_no_resize;

  /// /// Unset a key value pair in the map.
  ///
  /// The key needs to be a null terminated c string.
  /// If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.
  ///
  /// \param[inout] string_map rcutils_string_map_t to be updated
  /// \param[in] key map key, must be null terminated c string
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  /// \return `RCUTILS_RET_STRING_KEY_NOT_FOUND` if key not found, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_unset(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return (_rcutils_string_map_unset ??= _dylib.lookupFunction<
        _c_rcutils_string_map_unset,
        _dart_rcutils_string_map_unset>('rcutils_string_map_unset'))(
      string_map,
      key,
    );
  }

  _dart_rcutils_string_map_unset? _rcutils_string_map_unset;

  /// /// Get whether or not a key exists.
  ///
  /// The key needs to be a null terminated c string.
  ///
  /// This function can fail and return false if the key is not found,
  /// or the string_map is NULL or invalid, or if the key is NULL.
  /// In all cases no error message is set.
  ///
  /// \param[in] string_map rcutils_string_map_t to be searched
  /// \param[in] key map key, must be null terminated c string
  /// \return `true` if key is in the map, or
  /// \return `false` if key is not in the map, or
  /// \return `false` for invalid arguments, or
  /// \return `false` if the string map is invalid
  bool rcutils_string_map_key_exists(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return (_rcutils_string_map_key_exists ??= _dylib.lookupFunction<
                _c_rcutils_string_map_key_exists,
                _dart_rcutils_string_map_key_exists>(
            'rcutils_string_map_key_exists'))(
          string_map,
          key,
        ) !=
        0;
  }

  _dart_rcutils_string_map_key_exists? _rcutils_string_map_key_exists;

  /// /// Get whether or not a key of known length exists.
  ///
  /// Identical to rcutils_string_map_key_exists() but without relying on key to be
  /// a null terminated c string.
  ///
  /// \param[in] string_map rcutils_string_map_t to be searched
  /// \param[in] key map key
  /// \param[in] key_length map key length
  /// \return `true` if key is in the map, or
  /// \return `false` if key is not in the map, or
  /// \return `false` for invalid arguments, or
  /// \return `false` if the string map is invalid
  bool rcutils_string_map_key_existsn(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
    int key_length,
  ) {
    return (_rcutils_string_map_key_existsn ??= _dylib.lookupFunction<
                _c_rcutils_string_map_key_existsn,
                _dart_rcutils_string_map_key_existsn>(
            'rcutils_string_map_key_existsn'))(
          string_map,
          key,
          key_length,
        ) !=
        0;
  }

  _dart_rcutils_string_map_key_existsn? _rcutils_string_map_key_existsn;

  /// /// Get value given a key.
  ///
  /// The key needs to be a null terminated c string.
  ///
  /// This function can fail, and therefore return NULL, if the key is not found,
  /// or the string_map is NULL or invalid, or if the key is NULL.
  /// In all cases no error message is set.
  ///
  /// The returned value string is still owned by the map, and it should not be
  /// modified or free'd.
  /// This also means that the value pointer becomes invalid if either
  /// rcutils_string_map_clear() or rcutils_string_map_fini() are called or if
  /// the key value pair is updated or removed with one of rcutils_string_map_set()
  /// or rcutils_string_map_set_no_resize() or rcutils_string_map_unset().
  ///
  /// \param[in] string_map rcutils_string_map_t to be searched
  /// \param[in] key map key, must be null terminated c string
  /// \return value for the given key if successful, or
  /// \return `NULL` for invalid arguments, or
  /// \return `NULL` if the string map is invalid, or
  /// \return `NULL` if key not found, or
  /// \return `NULL` if an unknown error occurs
  ffi.Pointer<ffi.Int8> rcutils_string_map_get(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return (_rcutils_string_map_get ??= _dylib.lookupFunction<
        _c_rcutils_string_map_get,
        _dart_rcutils_string_map_get>('rcutils_string_map_get'))(
      string_map,
      key,
    );
  }

  _dart_rcutils_string_map_get? _rcutils_string_map_get;

  /// /// Get value given a key and key length.
  ///
  /// Identical to rcutils_string_map_get() but without relying on key to be a
  /// null terminated c string.
  ///
  /// \param[in] string_map rcutils_string_map_t to be searched
  /// \param[in] key map key
  /// \param[in] key_length map key length
  /// \return value for the given key if successful, or
  /// \return `NULL` for invalid arguments, or
  /// \return `NULL` if the string map is invalid, or
  /// \return `NULL` if key not found, or
  /// \return `NULL` if an unknown error occurs
  ffi.Pointer<ffi.Int8> rcutils_string_map_getn(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
    int key_length,
  ) {
    return (_rcutils_string_map_getn ??= _dylib.lookupFunction<
        _c_rcutils_string_map_getn,
        _dart_rcutils_string_map_getn>('rcutils_string_map_getn'))(
      string_map,
      key,
      key_length,
    );
  }

  _dart_rcutils_string_map_getn? _rcutils_string_map_getn;

  /// /// Get the next key in the map, unless NULL is given, then get the first key.
  ///
  /// This function allows you iteratively get each key in the map.
  ///
  /// If NULL is given for the key, then the first key in the map is returned.
  /// If that returned key if given to the this function, then the next key in the
  /// map is returned.
  /// If there are no more keys in the map or if the given key is not in the map,
  /// NULL is returned.
  ///
  /// The order of the keys in the map is arbitrary and if the map is modified
  /// between calls to this function the behavior is undefined.
  /// If the map is modifeid then iteration should begin again by passing NULL to
  /// get the first key again.
  ///
  /// This function operates based on the address of the pointer, you cannot pass
  /// a copy of a key to get the next key.
  ///
  /// Example:
  ///
  /// ```c
  /// printf("keys in the map:\n");
  /// const char * current_key = rcutils_string_map_get_next_key(&map, NULL);
  /// while (current_key) {
  /// printf("  - %s\n", current_key);
  /// current_key = rcutils_string_map_get_next_key(&map, current_key);
  /// }
  /// ```
  ///
  /// NULL can also be returned if NULL is given for the string_map or if the
  /// string_map is invalid.
  ///
  /// \param[in] string_map rcutils_string_map_t to be queried
  /// \param[in] key NULL to get the first key or the previous key to get the next
  /// \return value for the given key if successful, or
  /// \return `NULL` for invalid arguments, or
  /// \return `NULL` if the string map is invalid, or
  /// \return `NULL` if key not found, or
  /// \return `NULL` if there are no more keys in the map, or
  /// \return `NULL` if an unknown error occurs
  ffi.Pointer<ffi.Int8> rcutils_string_map_get_next_key(
    ffi.Pointer<rcutils_string_map_t> string_map,
    ffi.Pointer<ffi.Int8> key,
  ) {
    return (_rcutils_string_map_get_next_key ??= _dylib.lookupFunction<
            _c_rcutils_string_map_get_next_key,
            _dart_rcutils_string_map_get_next_key>(
        'rcutils_string_map_get_next_key'))(
      string_map,
      key,
    );
  }

  _dart_rcutils_string_map_get_next_key? _rcutils_string_map_get_next_key;

  /// /// Copy all the key value pairs from one map into another, overwritting and resizing if needed.
  ///
  /// If the destination string map does not have enough storage, then it is will
  /// be resized.
  /// If a key value pair exists in the destination map, its value will be
  /// replaced with the source map's value.
  ///
  /// It is possible for only some of the values to be copied if an error happens
  /// during the copying process, e.g. if memory allocation fails.
  ///
  /// \param[in] src_string_map rcutils_string_map_t to be copied from
  /// \param[inout] dst_string_map rcutils_string_map_t to be copied to
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unknown error occurs
  int rcutils_string_map_copy(
    ffi.Pointer<rcutils_string_map_t> src_string_map,
    ffi.Pointer<rcutils_string_map_t> dst_string_map,
  ) {
    return (_rcutils_string_map_copy ??= _dylib.lookupFunction<
        _c_rcutils_string_map_copy,
        _dart_rcutils_string_map_copy>('rcutils_string_map_copy'))(
      src_string_map,
      dst_string_map,
    );
  }

  _dart_rcutils_string_map_copy? _rcutils_string_map_copy;

  /// /// Return a zero initialized uint8 array struct.
  ///
  /// \return rcutils_uint8_array_t a zero initialized uint8 array struct
  rcutils_uint8_array_t rcutils_get_zero_initialized_uint8_array() {
    return (_rcutils_get_zero_initialized_uint8_array ??= _dylib.lookupFunction<
            _c_rcutils_get_zero_initialized_uint8_array,
            _dart_rcutils_get_zero_initialized_uint8_array>(
        'rcutils_get_zero_initialized_uint8_array'))();
  }

  _dart_rcutils_get_zero_initialized_uint8_array?
      _rcutils_get_zero_initialized_uint8_array;

  /// /// Initialize a zero initialized uint8 array struct.
  ///
  /// This function may leak if the uint8 array struct is already initialized.
  /// If the capacity is set to 0, no memory is allocated and the internal buffer
  /// is still NULL.
  ///
  /// \param[inout] uint8_array a pointer to the to be initialized uint8 array struct
  /// \param[in] buffer_capacity the size of the memory to allocate for the byte stream
  /// \param[in] allocator the allocator to use for the memory allocation
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENTS` if any arguments are invalid, or
  /// \return 'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_uint8_array_init(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
    int buffer_capacity,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcutils_uint8_array_init ??= _dylib.lookupFunction<
        _c_rcutils_uint8_array_init,
        _dart_rcutils_uint8_array_init>('rcutils_uint8_array_init'))(
      uint8_array,
      buffer_capacity,
      allocator,
    );
  }

  _dart_rcutils_uint8_array_init? _rcutils_uint8_array_init;

  /// /// Finalize a uint8 array struct.
  ///
  /// Cleans up and deallocates any resources used in a rcutils_uint8_array_t.
  /// The array passed to this function needs to have been initialized by
  /// rcutils_uint8_array_init().
  /// Passing an uninitialized instance to this function leads to undefined
  /// behavior.
  ///
  /// \param[in] uint8_array pointer to the rcutils_uint8_array_t to be cleaned up
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENTS` if the uint8_array argument is invalid
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_uint8_array_fini(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  ) {
    return (_rcutils_uint8_array_fini ??= _dylib.lookupFunction<
        _c_rcutils_uint8_array_fini,
        _dart_rcutils_uint8_array_fini>('rcutils_uint8_array_fini'))(
      uint8_array,
    );
  }

  _dart_rcutils_uint8_array_fini? _rcutils_uint8_array_fini;

  /// /// Resize the internal buffer of the uint8 array.
  ///
  /// The internal buffer of the uint8 array can be resized dynamically if needed.
  /// If the new size is smaller than the current capacity, then the memory is
  /// truncated.
  /// Be aware, that this might deallocate the memory and therefore invalidates any
  /// pointers to this storage.
  ///
  /// \param[inout] uint8_array pointer to the instance of rcutils_uint8_array_t which is
  /// being resized
  /// \param[in] new_size the new size of the internal buffer
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if new_size is set to zero
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCUTILS_RET_ERROR` if an unexpected error occurs
  int rcutils_uint8_array_resize(
    ffi.Pointer<rcutils_uint8_array_t> uint8_array,
    int new_size,
  ) {
    return (_rcutils_uint8_array_resize ??= _dylib.lookupFunction<
        _c_rcutils_uint8_array_resize,
        _dart_rcutils_uint8_array_resize>('rcutils_uint8_array_resize'))(
      uint8_array,
      new_size,
    );
  }

  _dart_rcutils_uint8_array_resize? _rcutils_uint8_array_resize;

  /// This function returns the time from a system clock.
  /// The closest equivalent would be to std::chrono::system_clock::now();
  ///
  /// The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.
  ///
  /// The now argument must point to an allocated rcutils_time_point_value_t object,
  /// as the result is copied into this variable.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[out] now a datafield in which the current time is stored
  /// \return `RCUTILS_RET_OK` if the current time was successfully obtained, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unspecified error occur.
  int rcutils_system_time_now(
    ffi.Pointer<ffi.Int64> now,
  ) {
    return (_rcutils_system_time_now ??= _dylib.lookupFunction<
        _c_rcutils_system_time_now,
        _dart_rcutils_system_time_now>('rcutils_system_time_now'))(
      now,
    );
  }

  _dart_rcutils_system_time_now? _rcutils_system_time_now;

  /// /// Retrieve the current time as a rcutils_time_point_value_t object.
  ///
  /// This function returns the time from a monotonically increasing clock.
  /// The closest equivalent would be to std::chrono::steady_clock::now();
  ///
  /// The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.
  ///
  /// The now argument must point to an allocated rcutils_time_point_value_t object,
  /// as the result is copied into this variable.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[out] now a struct in which the current time is stored
  /// \return `RCUTILS_RET_OK` if the current time was successfully obtained, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unspecified error occur.
  int rcutils_steady_time_now(
    ffi.Pointer<ffi.Int64> now,
  ) {
    return (_rcutils_steady_time_now ??= _dylib.lookupFunction<
        _c_rcutils_steady_time_now,
        _dart_rcutils_steady_time_now>('rcutils_steady_time_now'))(
      now,
    );
  }

  _dart_rcutils_steady_time_now? _rcutils_steady_time_now;

  /// /// Return a time point as nanoseconds in a string.
  ///
  /// The number is always fixed width, with left padding zeros up to the maximum
  /// number of digits the time point can represent.
  /// Right now that is 19 digits (so 19 characters) for a signed 64-bit integer.
  /// Negative values will have a leading `-`, so they will be one character
  /// longer than the positive values.
  ///
  /// The recommended minimum size of the input string is 32 characters, but
  /// 21 (` ` or `-` for sign, 19 digits, null terminator) should be sufficiently
  /// large for both positive and negative values.
  /// If the given string is not large enough, the result will be truncated.
  /// If you need a string with variable width, using `snprintf()` directly is
  /// recommended.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No [1]
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] if `snprintf()` does not allocate additional memory internally</i>
  ///
  /// \param[in] time_point the time to be made into a string
  /// \param[out] str the output string in which it is stored
  /// \param[in] str_size the size of the output string
  /// \return `RCUTILS_RET_OK` if successful (even if truncated), or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unspecified error occur.
  int rcutils_time_point_value_as_nanoseconds_string(
    ffi.Pointer<ffi.Int64> time_point,
    ffi.Pointer<ffi.Int8> str,
    int str_size,
  ) {
    return (_rcutils_time_point_value_as_nanoseconds_string ??=
        _dylib.lookupFunction<_c_rcutils_time_point_value_as_nanoseconds_string,
                _dart_rcutils_time_point_value_as_nanoseconds_string>(
            'rcutils_time_point_value_as_nanoseconds_string'))(
      time_point,
      str,
      str_size,
    );
  }

  _dart_rcutils_time_point_value_as_nanoseconds_string?
      _rcutils_time_point_value_as_nanoseconds_string;

  /// /// Return a time point as floating point seconds in a string.
  ///
  /// The number is always fixed width, with left padding zeros up to the maximum
  /// number of digits for the mantissa that the time point can represent and a
  /// characteristic (fractional-part) with a fixed width of 9 digits.
  /// Right now that means the mantissa is always 10 digits to add up to 19 total
  /// for the signed 64-bit time point type.
  /// Negative values will have a leading `-`, so they will be one character
  /// longer then positive values.
  ///
  /// The recommended minimum size of the input string is 32 characters, but
  /// 22 (` ` or `-` for sign, 19 digits, decimal point, null terminator) should
  /// be sufficient for now.
  /// If the given string is not large enough, the result will be truncated.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No [1]
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] if `snprintf()` does not allocate additional memory internally</i>
  ///
  /// \param[in] time_point the time to be made into a string
  /// \param[out] str the output string in which it is stored
  /// \param[in] str_size the size of the output string
  /// \return `RCUTILS_RET_OK` if successful (even if truncated), or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unspecified error occur.
  int rcutils_time_point_value_as_seconds_string(
    ffi.Pointer<ffi.Int64> time_point,
    ffi.Pointer<ffi.Int8> str,
    int str_size,
  ) {
    return (_rcutils_time_point_value_as_seconds_string ??=
        _dylib.lookupFunction<_c_rcutils_time_point_value_as_seconds_string,
                _dart_rcutils_time_point_value_as_seconds_string>(
            'rcutils_time_point_value_as_seconds_string'))(
      time_point,
      str,
      str_size,
    );
  }

  _dart_rcutils_time_point_value_as_seconds_string?
      _rcutils_time_point_value_as_seconds_string;

  /// /// Initialize the logging system using the specified allocator.
  ///
  /// Initialize the logging system only if it was not in an initialized state.
  ///
  /// If an invalid allocator is passed, the initialization will fail.
  /// Otherwise, this function will still set the internal state to initialized
  /// even if an error occurs, to avoid repeated failing initialization attempts
  /// since this function is called automatically from logging macros.
  /// To re-attempt initialization, call rcutils_logging_shutdown() before
  /// re-calling this function.
  ///
  /// If multiple errors occur, the error code of the last error will be returned.
  ///
  /// The `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable can be used to set
  /// the output format of messages logged to the console.
  /// Available tokens are:
  /// - `file_name`, the full file name of the caller including the path
  /// - `function_name`, the function name of the caller
  /// - `line_number`, the line number of the caller
  /// - `message`, the message string after it has been formatted
  /// - `name`, the full logger name
  /// - `severity`, the name of the severity level, e.g. `INFO`
  /// - `time`, the timestamp of log message in floating point seconds
  /// - `time_as_nanoseconds`, the timestamp of log message in integer nanoseconds
  ///
  /// The `RCUTILS_COLORIZED_OUTPUT` environment variable allows configuring if colours
  /// are used or not. Available values are:
  /// - `1`: Force using colours.
  /// - `0`: Don't use colours.
  /// If it is unset, colours are used depending if the target stream is a terminal or not.
  /// See `isatty` documentation.
  ///
  /// The format string can use these tokens by referencing them in curly brackets,
  /// e.g. `"[{severity}] [{name}]: {message} ({function_name}() at {file_name}:{line_number})"`.
  /// Any number of tokens can be used.
  /// The limit of the format string is 2048 characters.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] allocator rcutils_allocator_t to be used.
  /// \return `RCUTILS_RET_OK` if successful.
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if the allocator is invalid, in which
  /// case initialization will fail.
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if an error occurs reading the output
  /// format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in
  /// which case the default format will be used.
  /// \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if the internal logger
  /// severity level map cannot be initialized, in which case logger severity
  /// levels will not be configurable.
  int rcutils_logging_initialize_with_allocator(
    rcutils_allocator_t allocator,
  ) {
    return (_rcutils_logging_initialize_with_allocator ??=
        _dylib.lookupFunction<_c_rcutils_logging_initialize_with_allocator,
                _dart_rcutils_logging_initialize_with_allocator>(
            'rcutils_logging_initialize_with_allocator'))(
      allocator,
    );
  }

  _dart_rcutils_logging_initialize_with_allocator?
      _rcutils_logging_initialize_with_allocator;

  /// /// Initialize the logging system.
  ///
  /// Call rcutils_logging_initialize_with_allocator() using the default allocator.
  /// This function is called automatically when using the logging macros.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \return `RCUTILS_RET_OK` if successful.
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` if an error occurs reading the output
  /// format from the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable, in
  /// which case the default format will be used.
  /// \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if the internal logger
  /// severity level map cannot be initialized, in which case logger levels
  /// will not be configurable.
  int rcutils_logging_initialize() {
    return (_rcutils_logging_initialize ??= _dylib.lookupFunction<
        _c_rcutils_logging_initialize,
        _dart_rcutils_logging_initialize>('rcutils_logging_initialize'))();
  }

  _dart_rcutils_logging_initialize? _rcutils_logging_initialize;

  /// /// Shutdown the logging system.
  ///
  /// Free the resources allocated for the logging system.
  /// This puts the system into a state equivalent to being uninitialized.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \return `RCUTILS_RET_OK` if successful.
  /// \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if the internal logger
  /// severity level map cannot be finalized.
  int rcutils_logging_shutdown() {
    return (_rcutils_logging_shutdown ??= _dylib.lookupFunction<
        _c_rcutils_logging_shutdown,
        _dart_rcutils_logging_shutdown>('rcutils_logging_shutdown'))();
  }

  _dart_rcutils_logging_shutdown? _rcutils_logging_shutdown;

  /// /// Get a severity value from its string representation (e.g. DEBUG).
  ///
  /// String representation must match one of the values in
  /// `g_rcutils_log_severity_names`, but is not case-sensitive.
  /// Examples: UNSET, DEBUG, INFO, WARN, Error, fatal.
  ///
  /// \param[in] severity_string String representation of the severity, must be a
  /// null terminated c string
  /// \param[in] allocator rcutils_allocator_t to be used
  /// \param[in,out] severity The severity level as a represented by the
  /// `RCUTILS_LOG_SEVERITY` enum
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` on invalid arguments, or
  /// \return `RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID` if unable to match
  /// string, or
  /// \return `RCUTILS_RET_ERROR` if an unspecified error occured
  int rcutils_logging_severity_level_from_string(
    ffi.Pointer<ffi.Int8> severity_string,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Int32> severity,
  ) {
    return (_rcutils_logging_severity_level_from_string ??=
        _dylib.lookupFunction<_c_rcutils_logging_severity_level_from_string,
                _dart_rcutils_logging_severity_level_from_string>(
            'rcutils_logging_severity_level_from_string'))(
      severity_string,
      allocator,
      severity,
    );
  }

  _dart_rcutils_logging_severity_level_from_string?
      _rcutils_logging_severity_level_from_string;

  /// /// Get the current output handler.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, provided logging system is already initialized
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \return The function pointer of the current output handler.
  ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>
      rcutils_logging_get_output_handler() {
    return (_rcutils_logging_get_output_handler ??= _dylib.lookupFunction<
            _c_rcutils_logging_get_output_handler,
            _dart_rcutils_logging_get_output_handler>(
        'rcutils_logging_get_output_handler'))();
  }

  _dart_rcutils_logging_get_output_handler? _rcutils_logging_get_output_handler;

  /// /// Set the current output handler.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, provided logging system is already initialized
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] function The function pointer of the output handler to be used.
  void rcutils_logging_set_output_handler(
    ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>> function,
  ) {
    return (_rcutils_logging_set_output_handler ??= _dylib.lookupFunction<
            _c_rcutils_logging_set_output_handler,
            _dart_rcutils_logging_set_output_handler>(
        'rcutils_logging_set_output_handler'))(
      function,
    );
  }

  _dart_rcutils_logging_set_output_handler? _rcutils_logging_set_output_handler;

  /// /// Formats a log message according to RCUTILS_CONSOLE_OUTPUT_FORMAT
  ///
  /// A formatter that is meant to be used by an output handler to format a log message to the match
  /// the format specified in RCUTILS_CONSOLE_OUTPUT_FORMAT by performing token replacement.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \return `RCUTILS_RET_OK` if successful.
  /// \return `RCUTILS_RET_BAD_ALLOC` if memory allocation error occured
  /// \param[in] location The location information about where the log came from
  /// \param[in] severity The severity of the log message expressed as an integer
  /// \param[in] name The name of the logger that this message came from
  /// \param[in] timestamp The time at which the log message was generated
  /// \param[in] msg The message being logged
  /// \param[out] logging_output An output buffer for the formatted message
  int rcutils_logging_format_message(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Int8> name,
    int timestamp,
    ffi.Pointer<ffi.Int8> msg,
    ffi.Pointer<rcutils_char_array_t> logging_output,
  ) {
    return (_rcutils_logging_format_message ??= _dylib.lookupFunction<
            _c_rcutils_logging_format_message,
            _dart_rcutils_logging_format_message>(
        'rcutils_logging_format_message'))(
      location,
      severity,
      name,
      timestamp,
      msg,
      logging_output,
    );
  }

  _dart_rcutils_logging_format_message? _rcutils_logging_format_message;

  /// /// Get the default level for loggers.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, provided logging system is already initialized
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \return The level.
  int rcutils_logging_get_default_logger_level() {
    return (_rcutils_logging_get_default_logger_level ??= _dylib.lookupFunction<
            _c_rcutils_logging_get_default_logger_level,
            _dart_rcutils_logging_get_default_logger_level>(
        'rcutils_logging_get_default_logger_level'))();
  }

  _dart_rcutils_logging_get_default_logger_level?
      _rcutils_logging_get_default_logger_level;

  /// /// Set the default severity level for loggers.
  ///
  /// If the severity level requested is `RCUTILS_LOG_SEVERITY_UNSET`, the default
  /// value for the default logger (`RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL`)
  /// will be restored instead.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, provided logging system is already initialized
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] level The level to be used.
  void rcutils_logging_set_default_logger_level(
    int level,
  ) {
    return (_rcutils_logging_set_default_logger_level ??= _dylib.lookupFunction<
            _c_rcutils_logging_set_default_logger_level,
            _dart_rcutils_logging_set_default_logger_level>(
        'rcutils_logging_set_default_logger_level'))(
      level,
    );
  }

  _dart_rcutils_logging_set_default_logger_level?
      _rcutils_logging_set_default_logger_level;

  /// /// Get the severity level for a logger.
  ///
  /// This considers the severity level of the specifed logger only.
  /// To get the effective level of a logger given the severity level of its
  /// ancestors, see rcutils_logging_get_logger_effective_level().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, provided logging system is already initialized
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] name The name of the logger, must be null terminated c string
  /// \return The level of the logger if it has been set, or
  /// \return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or
  /// \return `g_rcutils_logging_default_logger_level` for an empty name, or
  /// \return -1 on invalid arguments, or
  /// \return -1 if an error occurred
  int rcutils_logging_get_logger_level(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return (_rcutils_logging_get_logger_level ??= _dylib.lookupFunction<
            _c_rcutils_logging_get_logger_level,
            _dart_rcutils_logging_get_logger_level>(
        'rcutils_logging_get_logger_level'))(
      name,
    );
  }

  _dart_rcutils_logging_get_logger_level? _rcutils_logging_get_logger_level;

  /// /// Get the level for a logger and its name length.
  ///
  /// Identical to rcutils_logging_get_logger_level() but without
  /// relying on the logger name to be a null terminated c string.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, provided logging system is already initialized
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] name The name of the logger
  /// \param[in] name_length Logger name length
  /// \return The level of the logger if it has been set, or
  /// \return `RCUTILS_LOG_SEVERITY_UNSET` if unset, or
  /// \return `g_rcutils_logging_default_logger_level` for `name_length` of `0`, or
  /// \return -1 on invalid arguments, or
  /// \return -1 if an error occurred
  int rcutils_logging_get_logger_leveln(
    ffi.Pointer<ffi.Int8> name,
    int name_length,
  ) {
    return (_rcutils_logging_get_logger_leveln ??= _dylib.lookupFunction<
            _c_rcutils_logging_get_logger_leveln,
            _dart_rcutils_logging_get_logger_leveln>(
        'rcutils_logging_get_logger_leveln'))(
      name,
      name_length,
    );
  }

  _dart_rcutils_logging_get_logger_leveln? _rcutils_logging_get_logger_leveln;

  /// /// Set the severity level for a logger.
  ///
  /// If an empty string is specified as the name, the
  /// `g_rcutils_logging_default_logger_level` will be set.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] name The name of the logger, must be null terminated c string.
  /// \param[in] level The level to be used.
  /// \return `RCUTILS_RET_OK` if successful, or
  /// \return `RCUTILS_RET_INVALID_ARGUMENT` on invalid arguments, or
  /// \return `RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID` if severity map invalid, or
  /// \return `RCUTILS_RET_ERROR` if an unspecified error occured
  int rcutils_logging_set_logger_level(
    ffi.Pointer<ffi.Int8> name,
    int level,
  ) {
    return (_rcutils_logging_set_logger_level ??= _dylib.lookupFunction<
            _c_rcutils_logging_set_logger_level,
            _dart_rcutils_logging_set_logger_level>(
        'rcutils_logging_set_logger_level'))(
      name,
      level,
    );
  }

  _dart_rcutils_logging_set_logger_level? _rcutils_logging_set_logger_level;

  /// /// Determine if a logger is enabled for a severity level.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, provided logging system is already initialized
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] name The name of the logger, must be null terminated c string or NULL.
  /// \param[in] severity The severity level.
  ///
  /// \return true if the logger is enabled for the level; false otherwise.
  bool rcutils_logging_logger_is_enabled_for(
    ffi.Pointer<ffi.Int8> name,
    int severity,
  ) {
    return (_rcutils_logging_logger_is_enabled_for ??= _dylib.lookupFunction<
                _c_rcutils_logging_logger_is_enabled_for,
                _dart_rcutils_logging_logger_is_enabled_for>(
            'rcutils_logging_logger_is_enabled_for'))(
          name,
          severity,
        ) !=
        0;
  }

  _dart_rcutils_logging_logger_is_enabled_for?
      _rcutils_logging_logger_is_enabled_for;

  /// /// Determine the effective level for a logger.
  ///
  /// The effective level is determined as the severity level of
  /// the logger if it is set, otherwise it is the first specified severity
  /// level of the logger's ancestors, starting with its closest ancestor.
  /// The ancestor hierarchy is signified by logger names being separated by dots:
  /// a logger named `x` is an ancestor of `x.y`, and both `x` and `x.y` are
  /// ancestors of `x.y.z`, etc.
  /// If the level has not been set for the logger nor any of its
  /// ancestors, the default level is used.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, provided logging system is already initialized
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] name The name of the logger, must be null terminated c string.
  ///
  /// \return The level, or
  /// \return -1 on invalid arguments, or
  /// \return -1 if an error occurred.
  int rcutils_logging_get_logger_effective_level(
    ffi.Pointer<ffi.Int8> name,
  ) {
    return (_rcutils_logging_get_logger_effective_level ??=
        _dylib.lookupFunction<_c_rcutils_logging_get_logger_effective_level,
                _dart_rcutils_logging_get_logger_effective_level>(
            'rcutils_logging_get_logger_effective_level'))(
      name,
    );
  }

  _dart_rcutils_logging_get_logger_effective_level?
      _rcutils_logging_get_logger_effective_level;

  /// /// Log a message.
  ///
  /// The attributes of this function are also being influenced by the currently
  /// set output handler.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No, for formatted outputs <= 1023 characters
  /// | Yes, for formatted outputs >= 1024 characters
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] location The pointer to the location struct or NULL
  /// \param[in] severity The severity level
  /// \param[in] name The name of the logger, must be null terminated c string or NULL
  /// \param[in] format The format string
  /// \param[in] ... The variable arguments
  void rcutils_log(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> format,
  ) {
    return (_rcutils_log ??= _dylib
        .lookupFunction<_c_rcutils_log, _dart_rcutils_log>('rcutils_log'))(
      location,
      severity,
      name,
      format,
    );
  }

  _dart_rcutils_log? _rcutils_log;

  /// /// The default output handler outputs log messages to the standard streams.
  ///
  /// The messages with a severity level `DEBUG` and `INFO` are written to `stdout`.
  /// The messages with a severity level `WARN`, `ERROR`, and `FATAL` are written
  /// to `stderr`.
  /// The console output format of the logged message can be configured through
  /// the `RCUTILS_CONSOLE_OUTPUT_FORMAT` environment variable: see
  /// rcutils_logging_initialize_with_allocator() for details.
  /// For configuring if using colours or not, `RCUTILS_COLORIZED_OUTPUT` can be used:
  /// see rcutils_logging_initialize_with_allocator() for details.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes, if the underlying *printf functions are
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] location The pointer to the location struct or NULL
  /// \param[in] severity The severity level
  /// \param[in] name The name of the logger, must be null terminated c string
  /// \param[in] timestamp The timestamp for when the log message was made
  /// \param[in] format The format string
  /// \param[in] args The `va_list` used by the logger
  void rcutils_logging_console_output_handler(
    ffi.Pointer<rcutils_log_location_t> location,
    int severity,
    ffi.Pointer<ffi.Int8> name,
    int timestamp,
    ffi.Pointer<ffi.Int8> format,
    ffi.Pointer<ffi.Pointer<__va_list_tag>> args,
  ) {
    return (_rcutils_logging_console_output_handler ??= _dylib.lookupFunction<
            _c_rcutils_logging_console_output_handler,
            _dart_rcutils_logging_console_output_handler>(
        'rcutils_logging_console_output_handler'))(
      location,
      severity,
      name,
      timestamp,
      format,
      args,
    );
  }

  _dart_rcutils_logging_console_output_handler?
      _rcutils_logging_console_output_handler;

  /// /// Get zero initialized mesage info.
  rmw_message_info_t rmw_get_zero_initialized_message_info() {
    return (_rmw_get_zero_initialized_message_info ??= _dylib.lookupFunction<
            _c_rmw_get_zero_initialized_message_info,
            _dart_rmw_get_zero_initialized_message_info>(
        'rmw_get_zero_initialized_message_info'))();
  }

  _dart_rmw_get_zero_initialized_message_info?
      _rmw_get_zero_initialized_message_info;

  /// /// Return a rcl_arguments_t struct with members initialized to `NULL`.
  rcl_arguments_t rcl_get_zero_initialized_arguments() {
    return (_rcl_get_zero_initialized_arguments ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_arguments,
            _dart_rcl_get_zero_initialized_arguments>(
        'rcl_get_zero_initialized_arguments'))();
  }

  _dart_rcl_get_zero_initialized_arguments? _rcl_get_zero_initialized_arguments;

  /// /// Parse command line arguments into a structure usable by code.
  ///
  /// \sa rcl_get_zero_initialized_arguments()
  ///
  /// ROS arguments are expected to be scoped by a leading `--ros-args` flag and a trailing double
  /// dash token `--` which may be elided if no non-ROS arguments follow after the last `--ros-args`.
  ///
  /// Remap rule parsing is supported via `-r/--remap` flags e.g. `--remap from:=to` or `-r from:=to`.
  /// Successfully parsed remap rules are stored in the order they were given in `argv`.
  /// If given arguments `{"__ns:=/foo", "__ns:=/bar"}` then the namespace used by nodes in this
  /// process will be `/foo` and not `/bar`.
  ///
  /// \sa rcl_remap_topic_name()
  /// \sa rcl_remap_service_name()
  /// \sa rcl_remap_node_name()
  /// \sa rcl_remap_node_namespace()
  ///
  /// Parameter override rule parsing is supported via `-p/--param` flags e.g. `--param name:=value`
  /// or `-p name:=value`.
  ///
  /// The default log level will be parsed as `--log-level level`, where `level` is a name
  /// representing one of the log levels in the `RCUTILS_LOG_SEVERITY` enum, e.g. `info`, `debug`,
  /// `warn`, not case sensitive.
  /// If multiple of these rules are found, the last one parsed will be used.
  ///
  /// If an argument does not appear to be a valid ROS argument e.g. a `-r/--remap` flag followed by
  /// anything but a valid remap rule, parsing will fail immediately.
  ///
  /// If an argument does not appear to be a known ROS argument, then it is skipped and left unparsed.
  ///
  /// \sa rcl_arguments_get_count_unparsed_ros()
  /// \sa rcl_arguments_get_unparsed_ros()
  ///
  /// All arguments found outside a `--ros-args ... --` scope are skipped and left unparsed.
  ///
  /// \sa rcl_arguments_get_count_unparsed()
  /// \sa rcl_arguments_get_unparsed()
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] argc The number of arguments in argv.
  /// \param[in] argv The values of the arguments.
  /// \param[in] allocator A valid allocator.
  /// \param[out] args_output A structure that will contain the result of parsing.
  /// Must be zero initialized before use.
  /// \return `RCL_RET_OK` if the arguments were parsed successfully, or
  /// \return `RCL_RET_INVALID_ROS_ARGS` if an invalid ROS argument is found, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_parse_arguments(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
    rcutils_allocator_t allocator,
    ffi.Pointer<rcl_arguments_t> args_output,
  ) {
    return (_rcl_parse_arguments ??= _dylib.lookupFunction<
        _c_rcl_parse_arguments,
        _dart_rcl_parse_arguments>('rcl_parse_arguments'))(
      argc,
      argv,
      allocator,
      args_output,
    );
  }

  _dart_rcl_parse_arguments? _rcl_parse_arguments;

  /// /// Return the number of arguments that were not ROS specific arguments.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] args An arguments structure that has been parsed.
  /// \return number of unparsed arguments, or
  /// \return -1 if args is `NULL` or zero initialized.
  int rcl_arguments_get_count_unparsed(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return (_rcl_arguments_get_count_unparsed ??= _dylib.lookupFunction<
            _c_rcl_arguments_get_count_unparsed,
            _dart_rcl_arguments_get_count_unparsed>(
        'rcl_arguments_get_count_unparsed'))(
      args,
    );
  }

  _dart_rcl_arguments_get_count_unparsed? _rcl_arguments_get_count_unparsed;

  /// /// Return a list of indices to non ROS specific arguments.
  ///
  /// Non ROS specific arguments may have been provided i.e. arguments outside a '--ros-args' scope.
  /// This function populates an array of indices to these arguments in the original argv array.
  /// Since the first argument is always assumed to be a process name, the list will always contain
  /// the index 0.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] args An arguments structure that has been parsed.
  /// \param[in] allocator A valid allocator.
  /// \param[out] output_unparsed_indices An allocated array of indices into the original argv array.
  /// This array must be deallocated by the caller using the given allocator.
  /// If there are no unparsed args then the output will be set to NULL.
  /// \return `RCL_RET_OK` if everything goes correctly, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_arguments_get_unparsed(
    ffi.Pointer<rcl_arguments_t> args,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_indices,
  ) {
    return (_rcl_arguments_get_unparsed ??= _dylib.lookupFunction<
        _c_rcl_arguments_get_unparsed,
        _dart_rcl_arguments_get_unparsed>('rcl_arguments_get_unparsed'))(
      args,
      allocator,
      output_unparsed_indices,
    );
  }

  _dart_rcl_arguments_get_unparsed? _rcl_arguments_get_unparsed;

  /// /// Return the number of ROS specific arguments that were not successfully parsed.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] args An arguments structure that has been parsed.
  /// \return number of unparsed ROS specific arguments, or
  /// \return -1 if args is `NULL` or zero initialized.
  int rcl_arguments_get_count_unparsed_ros(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return (_rcl_arguments_get_count_unparsed_ros ??= _dylib.lookupFunction<
            _c_rcl_arguments_get_count_unparsed_ros,
            _dart_rcl_arguments_get_count_unparsed_ros>(
        'rcl_arguments_get_count_unparsed_ros'))(
      args,
    );
  }

  _dart_rcl_arguments_get_count_unparsed_ros?
      _rcl_arguments_get_count_unparsed_ros;

  /// /// Return a list of indices to unknown ROS specific arguments that were left unparsed.
  ///
  /// Some ROS specific arguments may not have been recognized, or were not intended to be
  /// parsed by rcl.
  /// This function populates an array of indices to these arguments in the original argv array.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] args An arguments structure that has been parsed.
  /// \param[in] allocator A valid allocator.
  /// \param[out] output_unparsed_ros_indices An allocated array of indices into the original argv array.
  /// This array must be deallocated by the caller using the given allocator.
  /// If there are no unparsed ROS specific arguments then the output will be set to NULL.
  /// \return `RCL_RET_OK` if everything goes correctly, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_arguments_get_unparsed_ros(
    ffi.Pointer<rcl_arguments_t> args,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_ros_indices,
  ) {
    return (_rcl_arguments_get_unparsed_ros ??= _dylib.lookupFunction<
            _c_rcl_arguments_get_unparsed_ros,
            _dart_rcl_arguments_get_unparsed_ros>(
        'rcl_arguments_get_unparsed_ros'))(
      args,
      allocator,
      output_unparsed_ros_indices,
    );
  }

  _dart_rcl_arguments_get_unparsed_ros? _rcl_arguments_get_unparsed_ros;

  /// /// Return the number of parameter yaml files given in the arguments.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] args An arguments structure that has been parsed.
  /// \return number of yaml files, or
  /// \return -1 if args is `NULL` or zero initialized.
  int rcl_arguments_get_param_files_count(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return (_rcl_arguments_get_param_files_count ??= _dylib.lookupFunction<
            _c_rcl_arguments_get_param_files_count,
            _dart_rcl_arguments_get_param_files_count>(
        'rcl_arguments_get_param_files_count'))(
      args,
    );
  }

  _dart_rcl_arguments_get_param_files_count?
      _rcl_arguments_get_param_files_count;

  /// /// Return a list of yaml parameter file paths specified on the command line.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] arguments An arguments structure that has been parsed.
  /// \param[in] allocator A valid allocator.
  /// \param[out] parameter_files An allocated array of paramter file names.
  /// This array must be deallocated by the caller using the given allocator.
  /// The output is NULL if there were no paramter files.
  /// \return `RCL_RET_OK` if everything goes correctly, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_arguments_get_param_files(
    ffi.Pointer<rcl_arguments_t> arguments,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> parameter_files,
  ) {
    return (_rcl_arguments_get_param_files ??= _dylib.lookupFunction<
        _c_rcl_arguments_get_param_files,
        _dart_rcl_arguments_get_param_files>('rcl_arguments_get_param_files'))(
      arguments,
      allocator,
      parameter_files,
    );
  }

  _dart_rcl_arguments_get_param_files? _rcl_arguments_get_param_files;

  /// /// Return all parameter overrides parsed from the command line.
  ///
  /// Parameter overrides are parsed directly from command line arguments and
  /// parameter files provided in the command line.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] arguments An arguments structure that has been parsed.
  /// \param[out] parameter_overrides Parameter overrides as parsed from command line arguments.
  /// This structure must be finalized by the caller.
  /// The output is NULL if no parameter overrides were parsed.
  /// \return `RCL_RET_OK` if everything goes correctly, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_arguments_get_param_overrides(
    ffi.Pointer<rcl_arguments_t> arguments,
    ffi.Pointer<ffi.Pointer<rcl_params_t>> parameter_overrides,
  ) {
    return (_rcl_arguments_get_param_overrides ??= _dylib.lookupFunction<
            _c_rcl_arguments_get_param_overrides,
            _dart_rcl_arguments_get_param_overrides>(
        'rcl_arguments_get_param_overrides'))(
      arguments,
      parameter_overrides,
    );
  }

  _dart_rcl_arguments_get_param_overrides? _rcl_arguments_get_param_overrides;

  /// /// Return a list of arguments with ROS-specific arguments removed.
  ///
  /// Some arguments may not have been intended as ROS arguments.
  /// This function populates an array of the aruments in a new argv array.
  /// Since the first argument is always assumed to be a process name, the list
  /// will always contain the first value from the argument vector.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] argv The argument vector
  /// \param[in] args An arguments structure that has been parsed.
  /// \param[in] allocator A valid allocator.
  /// \param[out] nonros_argc The count of arguments that aren't ROS-specific
  /// \param[out] nonros_argv An allocated array of arguments that aren't ROS-specific
  /// This array must be deallocated by the caller using the given allocator.
  /// If there are no non-ROS args, then the output will be set to NULL.
  /// \return `RCL_RET_OK` if everything goes correctly, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_remove_ros_arguments(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
    ffi.Pointer<rcl_arguments_t> args,
    rcutils_allocator_t allocator,
    ffi.Pointer<ffi.Int32> nonros_argc,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> nonros_argv,
  ) {
    return (_rcl_remove_ros_arguments ??= _dylib.lookupFunction<
        _c_rcl_remove_ros_arguments,
        _dart_rcl_remove_ros_arguments>('rcl_remove_ros_arguments'))(
      argv,
      args,
      allocator,
      nonros_argc,
      nonros_argv,
    );
  }

  _dart_rcl_remove_ros_arguments? _rcl_remove_ros_arguments;

  /// /// Copy one arguments structure into another.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] args The structure to be copied.
  /// Its allocator is used to copy memory into the new structure.
  /// \param[out] args_out A zero-initialized arguments structure to be copied into.
  /// \return `RCL_RET_OK` if the structure was copied successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_arguments_copy(
    ffi.Pointer<rcl_arguments_t> args,
    ffi.Pointer<rcl_arguments_t> args_out,
  ) {
    return (_rcl_arguments_copy ??=
        _dylib.lookupFunction<_c_rcl_arguments_copy, _dart_rcl_arguments_copy>(
            'rcl_arguments_copy'))(
      args,
      args_out,
    );
  }

  _dart_rcl_arguments_copy? _rcl_arguments_copy;

  /// /// Reclaim resources held inside rcl_arguments_t structure.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] args The structure to be deallocated.
  /// \return `RCL_RET_OK` if the memory was successfully freed, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_arguments_fini(
    ffi.Pointer<rcl_arguments_t> args,
  ) {
    return (_rcl_arguments_fini ??=
        _dylib.lookupFunction<_c_rcl_arguments_fini, _dart_rcl_arguments_fini>(
            'rcl_arguments_fini'))(
      args,
    );
  }

  _dart_rcl_arguments_fini? _rcl_arguments_fini;

  /// /// Return a zero initialized rcl_init_options_t struct.
  rcl_init_options_t rcl_get_zero_initialized_init_options() {
    return (_rcl_get_zero_initialized_init_options ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_init_options,
            _dart_rcl_get_zero_initialized_init_options>(
        'rcl_get_zero_initialized_init_options'))();
  }

  _dart_rcl_get_zero_initialized_init_options?
      _rcl_get_zero_initialized_init_options;

  /// /// Initialize given init_options with the default values and implementation specific values.
  ///
  /// The given allocator is used, if required, during setup of the init options,
  /// but is also used during initialization.
  ///
  /// In either case the given allocator is stored in the returned init options.
  ///
  /// The `impl` pointer should not be changed manually.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// \param[inout] init_options object to be setup
  /// \param[in] allocator to be used during setup and during initialization
  /// \return `RCL_RET_OK` if setup is successful, or
  /// \return `RCL_RET_ALREADY_INIT` if init_options has already be initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_init_options_init(
    ffi.Pointer<rcl_init_options_t> init_options,
    rcutils_allocator_t allocator,
  ) {
    return (_rcl_init_options_init ??= _dylib.lookupFunction<
        _c_rcl_init_options_init,
        _dart_rcl_init_options_init>('rcl_init_options_init'))(
      init_options,
      allocator,
    );
  }

  _dart_rcl_init_options_init? _rcl_init_options_init;

  /// /// Copy the given source init_options to the destination init_options.
  ///
  /// The allocator from the source is used for any allocations and stored in the
  /// destination.
  ///
  /// The destination should either be zero initialized with
  /// `rcl_get_zero_initialized_init_options()` or should have had
  /// `rcl_init_options_fini()` called on it.
  /// Giving an already initialized init options for the destination will result
  /// in a failure with return code `RCL_RET_ALREADY_INIT`.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// \param[in] src rcl_init_options_t object to be copied from
  /// \param[out] dst rcl_init_options_t object to be copied into
  /// \return `RCL_RET_OK` if the copy is successful, or
  /// \return `RCL_RET_ALREADY_INIT` if the dst has already be initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_init_options_copy(
    ffi.Pointer<rcl_init_options_t> src,
    ffi.Pointer<rcl_init_options_t> dst,
  ) {
    return (_rcl_init_options_copy ??= _dylib.lookupFunction<
        _c_rcl_init_options_copy,
        _dart_rcl_init_options_copy>('rcl_init_options_copy'))(
      src,
      dst,
    );
  }

  _dart_rcl_init_options_copy? _rcl_init_options_copy;

  /// /// Finalize the given init_options.
  ///
  /// The given init_options must be non-`NULL` and valid, i.e. had
  /// `rcl_init_options_init()` called on it but not this function yet.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// \param[inout] init_options object to be setup
  /// \return `RCL_RET_OK` if setup is successful, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_init_options_fini(
    ffi.Pointer<rcl_init_options_t> init_options,
  ) {
    return (_rcl_init_options_fini ??= _dylib.lookupFunction<
        _c_rcl_init_options_fini,
        _dart_rcl_init_options_fini>('rcl_init_options_fini'))(
      init_options,
    );
  }

  _dart_rcl_init_options_fini? _rcl_init_options_fini;

  /// /// Return the rmw init options which are stored internally.
  ///
  /// This function can fail and return `NULL` if:
  /// - init_options is NULL
  /// - init_options is invalid, e.g. init_options->impl is NULL
  ///
  /// If NULL is returned an error message will have been set.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// \param[in] init_options object from which the rmw init options should be retrieved
  /// \return pointer to the the rcl init options, or
  /// \return `NULL` if there was an error
  ffi.Pointer<rmw_init_options_t> rcl_init_options_get_rmw_init_options(
    ffi.Pointer<rcl_init_options_t> init_options,
  ) {
    return (_rcl_init_options_get_rmw_init_options ??= _dylib.lookupFunction<
            _c_rcl_init_options_get_rmw_init_options,
            _dart_rcl_init_options_get_rmw_init_options>(
        'rcl_init_options_get_rmw_init_options'))(
      init_options,
    );
  }

  _dart_rcl_init_options_get_rmw_init_options?
      _rcl_init_options_get_rmw_init_options;

  /// /// Return the allocator stored in the init_options.
  ///
  /// This function can fail and return `NULL` if:
  /// - init_options is NULL
  /// - init_options is invalid, e.g. init_options->impl is NULL
  ///
  /// If NULL is returned an error message will have been set.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] init_options object from which the allocator should be retrieved
  /// \return pointer to the rcl allocator, or
  /// \return `NULL` if there was an error
  ffi.Pointer<rcutils_allocator_t> rcl_init_options_get_allocator(
    ffi.Pointer<rcl_init_options_t> init_options,
  ) {
    return (_rcl_init_options_get_allocator ??= _dylib.lookupFunction<
            _c_rcl_init_options_get_allocator,
            _dart_rcl_init_options_get_allocator>(
        'rcl_init_options_get_allocator'))(
      init_options,
    );
  }

  _dart_rcl_init_options_get_allocator? _rcl_init_options_get_allocator;

  /// /// Return a zero initialization context object.
  rcl_context_t rcl_get_zero_initialized_context() {
    return (_rcl_get_zero_initialized_context ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_context,
            _dart_rcl_get_zero_initialized_context>(
        'rcl_get_zero_initialized_context'))();
  }

  _dart_rcl_get_zero_initialized_context? _rcl_get_zero_initialized_context;

  /// /// Finalize a context.
  ///
  /// The context to be finalized must have been previously initialized with
  /// `rcl_init()`, and then later invalidated with `rcl_shutdown()`.
  /// A zero-initialized context that has not been initialized can be finalized.
  /// If context is `NULL`, then `RCL_RET_INVALID_ARGUMENT` is returned.
  /// If context is zero-initialized, then `RCL_RET_OK` is returned.
  /// If context is initialized and valid (`rcl_shutdown()` was not called on it),
  /// then `RCL_RET_INVALID_ARGUMENT` is returned.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \param[inout] context object to be finalized.
  /// \return `RCL_RET_OK` if the shutdown was completed successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occur.
  int rcl_context_fini(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return (_rcl_context_fini ??=
        _dylib.lookupFunction<_c_rcl_context_fini, _dart_rcl_context_fini>(
            'rcl_context_fini'))(
      context,
    );
  }

  _dart_rcl_context_fini? _rcl_context_fini;

  /// /// Return the init options used during initialization for this context.
  ///
  /// This function can fail and return `NULL` if:
  /// - context is NULL
  /// - context is zero-initialized, e.g. context->impl is `NULL`
  ///
  /// If context is uninitialized then that is undefined behavior.
  ///
  /// If `NULL` is returned an error message will have been set.
  ///
  /// The options are for reference only, and therefore the returned pointer is
  /// const.
  /// Changing the values in the options is undefined behavior but will likely
  /// have no effect.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// \param[in] context object from which the init options should be retrieved
  /// \return pointer to the the init options, or
  /// \return `NULL` if there was an error
  ffi.Pointer<rcl_init_options_t> rcl_context_get_init_options(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return (_rcl_context_get_init_options ??= _dylib.lookupFunction<
        _c_rcl_context_get_init_options,
        _dart_rcl_context_get_init_options>('rcl_context_get_init_options'))(
      context,
    );
  }

  _dart_rcl_context_get_init_options? _rcl_context_get_init_options;

  /// /// Returns an unsigned integer that is unique to the given context, or `0` if invalid.
  ///
  /// The given context must be non-`NULL`, but does not need to be initialized or valid.
  /// If context is `NULL`, then `0` will be returned.
  /// If context is uninitialized, then it is undefined behavior.
  ///
  /// The instance ID may be `0` if the context is zero-initialized or if the
  /// context has been invalidated by `rcl_shutdown()`.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \param[in] context object from which the instance id should be retrieved
  /// \return a unique id specific to this context instance, or
  /// \return `0` if invalid, or
  /// \return `0` if context is `NULL`
  int rcl_context_get_instance_id(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return (_rcl_context_get_instance_id ??= _dylib.lookupFunction<
        _c_rcl_context_get_instance_id,
        _dart_rcl_context_get_instance_id>('rcl_context_get_instance_id'))(
      context,
    );
  }

  _dart_rcl_context_get_instance_id? _rcl_context_get_instance_id;

  /// /// Return `true` if the given context is currently valid, otherwise `false`.
  ///
  /// If context is `NULL`, then `false` is returned.
  /// If context is zero-initialized, then `false` is returned.
  /// If context is uninitialized, then it is undefined behavior.
  ///
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \param[in] context object which should be checked for validity
  /// \return `true` if valid, otherwise `false`
  bool rcl_context_is_valid(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return (_rcl_context_is_valid ??= _dylib.lookupFunction<
            _c_rcl_context_is_valid,
            _dart_rcl_context_is_valid>('rcl_context_is_valid'))(
          context,
        ) !=
        0;
  }

  _dart_rcl_context_is_valid? _rcl_context_is_valid;

  /// /// Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`.
  ///
  /// If context is `NULL`, then `NULL` is returned.
  /// If context is zero-initialized, then `NULL` is returned.
  /// If context is uninitialized, then it is undefined behavior.
  ///
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \param[in] context object from which the rmw context should be retrieved.
  /// \return pointer to rmw context if valid, otherwise `NULL`
  ffi.Pointer<rmw_context_t> rcl_context_get_rmw_context(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return (_rcl_context_get_rmw_context ??= _dylib.lookupFunction<
        _c_rcl_context_get_rmw_context,
        _dart_rcl_context_get_rmw_context>('rcl_context_get_rmw_context'))(
      context,
    );
  }

  _dart_rcl_context_get_rmw_context? _rcl_context_get_rmw_context;

  /// /// Initialization of rcl.
  ///
  /// This function can be run any number of times, so long as the given context
  /// has been properly prepared.
  ///
  /// The given `rcl_context_t` must be zero initialized with the function
  /// `rcl_get_zero_initialized_context()` and must not be already initialized
  /// by this function.
  /// If the context is already initialized this function will fail and return the
  /// `RCL_RET_ALREADY_INIT` error code.
  /// A context may be initialized again after it has been finalized with the
  /// `rcl_shutdown()` function and zero initialized again with
  /// `rcl_get_zero_initialized_context()`.
  ///
  /// The `argc` and `argv` parameters may contain command line arguments for the
  /// program.
  /// rcl specific arguments will be parsed, but not removed.
  /// If `argc` is `0` and `argv` is `NULL` no parameters will be parsed.
  ///
  /// The `options` argument must be non-`NULL` and must have been initialized
  /// with `rcl_init_options_init()`.
  /// It is unmodified by this function, and the ownership is not transfered to
  /// the context, but instead a copy is made into the context for later reference.
  /// Therefore, the given options need to be cleaned up with
  /// `rcl_init_options_fini()` after this function returns.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \param[in] argc number of strings in argv
  /// \param[in] argv command line arguments; rcl specific arguments are removed
  /// \param[in] options options used during initialization
  /// \param[out] context resulting context object that represents this init
  /// \return `RCL_RET_OK` if initialization is successful, or
  /// \return `RCL_RET_ALREADY_INIT` if rcl_init has already been called, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_INVALID_ROS_ARGS` if an invalid ROS argument is found, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_init(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
    ffi.Pointer<rcl_init_options_t> options,
    ffi.Pointer<rcl_context_t> context,
  ) {
    return (_rcl_init ??=
        _dylib.lookupFunction<_c_rcl_init, _dart_rcl_init>('rcl_init'))(
      argc,
      argv,
      options,
      context,
    );
  }

  _dart_rcl_init? _rcl_init;

  /// /// Shutdown a given rcl context.
  ///
  /// The given context must have been initialized with `rcl_init()`.
  /// If not, this function will fail with `RCL_RET_ALREADY_SHUTDOWN`.
  ///
  /// When this function is called:
  /// - Any rcl objects created using this context are invalidated.
  /// - Functions called on invalid objects may or may not fail.
  /// - Calls to `rcl_context_is_initialized()` will return `false`.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \param[inout] context object to shutdown
  /// \return `RCL_RET_OK` if the shutdown was completed successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ALREADY_SHUTDOWN` if the context is not currently valid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occur.
  int rcl_shutdown(
    ffi.Pointer<rcl_context_t> context,
  ) {
    return (_rcl_shutdown ??= _dylib
        .lookupFunction<_c_rcl_shutdown, _dart_rcl_shutdown>('rcl_shutdown'))(
      context,
    );
  }

  _dart_rcl_shutdown? _rcl_shutdown;

  /// /// Determine the default domain ID, based on the environment.
  ///
  /// \param[out] domain_id Must not be NULL.
  /// \returns RCL_RET_INVALID_ARGUMENT if an argument is invalid, or,
  /// \returns RCL_RET_ERROR in case of an unexpected error, or,
  /// \returns RCL_RET_OK.
  int rcl_get_default_domain_id(
    ffi.Pointer<ffi.Uint64> domain_id,
  ) {
    return (_rcl_get_default_domain_id ??= _dylib.lookupFunction<
        _c_rcl_get_default_domain_id,
        _dart_rcl_get_default_domain_id>('rcl_get_default_domain_id'))(
      domain_id,
    );
  }

  _dart_rcl_get_default_domain_id? _rcl_get_default_domain_id;

  /// /// Return the default node options in a rcl_node_options_t.
  ///
  /// The default values are:
  ///
  /// - domain_id = RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID
  /// - allocator = rcl_get_default_allocator()
  /// - use_global_arguments = true
  /// - enable_rosout = true
  /// - arguments = rcl_get_zero_initialized_arguments()
  rcl_node_options_t rcl_node_get_default_options() {
    return (_rcl_node_get_default_options ??= _dylib.lookupFunction<
        _c_rcl_node_get_default_options,
        _dart_rcl_node_get_default_options>('rcl_node_get_default_options'))();
  }

  _dart_rcl_node_get_default_options? _rcl_node_get_default_options;

  /// /// Copy one options structure into another.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] options The structure to be copied.
  /// Its allocator is used to copy memory into the new structure.
  /// \param[out] options_out An options structure containing default values.
  /// \return `RCL_RET_OK` if the structure was copied successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_node_options_copy(
    ffi.Pointer<rcl_node_options_t> options,
    ffi.Pointer<rcl_node_options_t> options_out,
  ) {
    return (_rcl_node_options_copy ??= _dylib.lookupFunction<
        _c_rcl_node_options_copy,
        _dart_rcl_node_options_copy>('rcl_node_options_copy'))(
      options,
      options_out,
    );
  }

  _dart_rcl_node_options_copy? _rcl_node_options_copy;

  /// /// Finalize the given node_options.
  ///
  /// The given node_options must be non-`NULL` and valid, i.e. had
  /// `rcl_node_get_default_options()` called on it but not this function yet.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// \param[inout] options object to be finalized
  /// \return `RCL_RET_OK` if setup is successful, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_node_options_fini(
    ffi.Pointer<rcl_node_options_t> options,
  ) {
    return (_rcl_node_options_fini ??= _dylib.lookupFunction<
        _c_rcl_node_options_fini,
        _dart_rcl_node_options_fini>('rcl_node_options_fini'))(
      options,
    );
  }

  _dart_rcl_node_options_fini? _rcl_node_options_fini;

  /// /// Return a rcl_node_t struct with members initialized to `NULL`.
  rcl_node_t rcl_get_zero_initialized_node() {
    return (_rcl_get_zero_initialized_node ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_node,
            _dart_rcl_get_zero_initialized_node>(
        'rcl_get_zero_initialized_node'))();
  }

  _dart_rcl_get_zero_initialized_node? _rcl_get_zero_initialized_node;

  /// /// Initialize a ROS node.
  ///
  /// Calling this on a rcl_node_t makes it a valid node handle until rcl_shutdown
  /// is called or until rcl_node_fini is called on it.
  ///
  /// After calling, the ROS node object can be used to create other middleware
  /// primitives like publishers, services, parameters, etc.
  ///
  /// The name of the node must not be NULL and adhere to naming restrictions,
  /// see the rmw_validate_node_name() function for rules.
  ///
  /// \todo TODO(wjwwood): node name uniqueness is no yet enforced
  ///
  /// The name of the node cannot coincide with another node of the same name.
  /// If a node of the same name is already in the domain, it will be shutdown.
  ///
  /// The namespace of the node should not be NULL and should also pass the
  /// rmw_validate_namespace() function's rules.
  ///
  /// Additionally this function allows namespaces which lack a leading forward
  /// slash.
  /// Because there is no notion of a relative namespace, there is no difference
  /// between a namespace which lacks a forward and the same namespace with a
  /// leasing forward slash.
  /// Therefore, a namespace like ``"foo/bar"`` is automatically changed to
  /// ``"/foo/bar"`` by this function.
  /// Similarly, the namespace ``""`` will implicitly become ``"/"`` which is a
  /// valid namespace.
  ///
  /// \todo TODO(wjwwood):
  /// Parameter infrastructure is currently initialized in the language specific
  /// client library, e.g. rclcpp for C++, but will be initialized here in the
  /// future. When that happens there will be an option to avoid parameter
  /// infrastructure with an option in the rcl_node_options_t struct.
  ///
  /// A node contains infrastructure for ROS parameters, which include advertising
  /// publishers and service servers.
  /// This function will create those external parameter interfaces even if
  /// parameters are not used later.
  ///
  /// The rcl_node_t given must be allocated and zero initialized.
  /// Passing an rcl_node_t which has already had this function called on it, more
  /// recently than rcl_node_fini, will fail.
  /// An allocated rcl_node_t with uninitialized memory is undefined behavior.
  ///
  /// Expected usage:
  ///
  /// ```c
  /// rcl_context_t context = rcl_get_zero_initialized_context();
  /// // ... initialize the context with rcl_init()
  /// rcl_node_t node = rcl_get_zero_initialized_node();
  /// rcl_node_options_t node_ops = rcl_node_get_default_options();
  /// // ... node options customization
  /// rcl_ret_t ret = rcl_node_init(&node, "node_name", "/node_ns", &context, &node_ops);
  /// // ... error handling and then use the node, but eventually deinitialize it:
  /// ret = rcl_node_fini(&node);
  /// // ... error handling for rcl_node_fini()
  /// ```
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \pre the node handle must be allocated, zero initialized, and invalid
  /// \pre the context handle must be allocated, initialized, and valid
  /// \post the node handle is valid and can be used in other `rcl_*` functions
  ///
  /// \param[inout] node a preallocated rcl_node_t
  /// \param[in] name the name of the node, must be a valid c-string
  /// \param[in] namespace_ the namespace of the node, must be a valid c-string
  /// \param[in] context the context instance with which the node should be
  /// associated
  /// \param[in] options the node options.
  /// The options are deep copied into the node.
  /// The caller is always responsible for freeing memory used options they
  /// pass in.
  /// \return `RCL_RET_OK` if the node was initialized successfully, or
  /// \return `RCL_RET_ALREADY_INIT` if the node has already be initialized, or
  /// \return `RCL_RET_NOT_INIT` if the given context is invalid, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_NODE_INVALID_NAME` if the name is invalid, or
  /// \return `RCL_RET_NODE_INVALID_NAMESPACE` if the namespace_ is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_node_init(
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> namespace_,
    ffi.Pointer<rcl_context_t> context,
    ffi.Pointer<rcl_node_options_t> options,
  ) {
    return (_rcl_node_init ??=
        _dylib.lookupFunction<_c_rcl_node_init, _dart_rcl_node_init>(
            'rcl_node_init'))(
      node,
      name,
      namespace_,
      context,
      options,
    );
  }

  _dart_rcl_node_init? _rcl_node_init;

  /// /// Finalize a rcl_node_t.
  ///
  /// Destroys any automatically created infrastructure and deallocates memory.
  /// After calling, the rcl_node_t can be safely deallocated.
  ///
  /// All middleware primitives created by the user, e.g. publishers, services, etc,
  /// which were created from this node must be finalized using their respective
  /// `rcl_*_fini()` functions before this is called.
  /// \sa rcl_publisher_fini()
  /// \sa rcl_subscription_fini()
  /// \sa rcl_client_fini()
  /// \sa rcl_service_fini()
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \param[in] node rcl_node_t to be finalized
  /// \return `RCL_RET_OK` if node was finalized successfully, or
  /// \return `RCL_RET_NODE_INVALID` if the node pointer is null, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_node_fini(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_fini ??=
        _dylib.lookupFunction<_c_rcl_node_fini, _dart_rcl_node_fini>(
            'rcl_node_fini'))(
      node,
    );
  }

  _dart_rcl_node_fini? _rcl_node_fini;

  /// /// Return `true` if the node is valid, else `false`.
  ///
  /// Also return `false` if the node pointer is `NULL` or the allocator is invalid.
  ///
  /// A node is invalid if:
  /// - the implementation is `NULL` (rcl_node_init not called or failed)
  /// - rcl_shutdown has been called since the node has been initialized
  /// - the node has been finalized with rcl_node_fini
  ///
  /// There is a possible validity race condition.
  ///
  /// Consider:
  ///
  /// ```c
  /// assert(rcl_node_is_valid(node));  // <-- thread 1
  /// rcl_shutdown();                   // <-- thread 2
  /// // use node as if valid           // <-- thread 1
  /// ```
  ///
  /// In the third line the node is now invalid, even though on the previous line
  /// of thread 1 it was checked to be valid.
  /// This is why this function is considered not thread-safe.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// \param[in] node rcl_node_t to be validated
  /// \return `true` if the node and allocator are valid, otherwise `false`.
  bool rcl_node_is_valid(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_is_valid ??= _dylib.lookupFunction<_c_rcl_node_is_valid,
            _dart_rcl_node_is_valid>('rcl_node_is_valid'))(
          node,
        ) !=
        0;
  }

  _dart_rcl_node_is_valid? _rcl_node_is_valid;

  /// /// Return true if node is valid, except for the context being valid.
  ///
  /// This is used in clean up functions that need to access the node, but do not
  /// need use any functions with the context.
  ///
  /// It is identical to rcl_node_is_valid except it ignores the state of the
  /// context associated with the node.
  /// \sa rcl_node_is_valid()
  bool rcl_node_is_valid_except_context(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_is_valid_except_context ??= _dylib.lookupFunction<
                _c_rcl_node_is_valid_except_context,
                _dart_rcl_node_is_valid_except_context>(
            'rcl_node_is_valid_except_context'))(
          node,
        ) !=
        0;
  }

  _dart_rcl_node_is_valid_except_context? _rcl_node_is_valid_except_context;

  /// /// Return the name of the node.
  ///
  /// This function returns the node's internal name string.
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is `NULL`
  /// - node has not been initialized (the implementation is invalid)
  ///
  /// The returned string is only valid as long as the given rcl_node_t is valid.
  /// The value of the string may change if the value in the rcl_node_t changes,
  /// and therefore copying the string is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node pointer to the node
  /// \return name string if successful, otherwise `NULL`
  ffi.Pointer<ffi.Int8> rcl_node_get_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_get_name ??=
        _dylib.lookupFunction<_c_rcl_node_get_name, _dart_rcl_node_get_name>(
            'rcl_node_get_name'))(
      node,
    );
  }

  _dart_rcl_node_get_name? _rcl_node_get_name;

  /// /// Return the namespace of the node.
  ///
  /// This function returns the node's internal namespace string.
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is `NULL`
  /// - node has not been initialized (the implementation is invalid)
  ///
  /// The returned string is only valid as long as the given rcl_node_t is valid.
  /// The value of the string may change if the value in the rcl_node_t changes,
  /// and therefore copying the string is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node pointer to the node
  /// \return name string if successful, otherwise `NULL`
  ffi.Pointer<ffi.Int8> rcl_node_get_namespace(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_get_namespace ??= _dylib.lookupFunction<
        _c_rcl_node_get_namespace,
        _dart_rcl_node_get_namespace>('rcl_node_get_namespace'))(
      node,
    );
  }

  _dart_rcl_node_get_namespace? _rcl_node_get_namespace;

  /// /// Return the fully qualified name of the node.
  ///
  /// This function returns the node's internal namespace and name combined string.
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is `NULL`
  /// - node has not been initialized (the implementation is invalid)
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node pointer to the node
  /// \return fully qualified name string if successful, otherwise `NULL`
  ffi.Pointer<ffi.Int8> rcl_node_get_fully_qualified_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_get_fully_qualified_name ??= _dylib.lookupFunction<
            _c_rcl_node_get_fully_qualified_name,
            _dart_rcl_node_get_fully_qualified_name>(
        'rcl_node_get_fully_qualified_name'))(
      node,
    );
  }

  _dart_rcl_node_get_fully_qualified_name? _rcl_node_get_fully_qualified_name;

  /// /// Return the rcl node options.
  ///
  /// This function returns the node's internal options struct.
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is `NULL`
  /// - node has not been initialized (the implementation is invalid)
  ///
  /// The returned struct is only valid as long as the given rcl_node_t is valid.
  /// The values in the struct may change if the options of the rcl_node_t changes,
  /// and therefore copying the struct is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node pointer to the node
  /// \return options struct if successful, otherwise `NULL`
  ffi.Pointer<rcl_node_options_t> rcl_node_get_options(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_get_options ??= _dylib.lookupFunction<
        _c_rcl_node_get_options,
        _dart_rcl_node_get_options>('rcl_node_get_options'))(
      node,
    );
  }

  _dart_rcl_node_get_options? _rcl_node_get_options;

  /// /// Return the ROS domain ID that the node is using.
  ///
  /// This function returns the ROS domain ID that the node is in.
  ///
  /// This function should be used to determine what `domain_id` was used rather
  /// than checking the domain_id field in the node options, because if
  /// `RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID` is used when creating the node then
  /// it is not changed after creation, but this function will return the actual
  /// `domain_id` used.
  ///
  /// The `domain_id` field must point to an allocated `size_t` object to which
  /// the ROS domain ID will be written.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node the handle to the node being queried
  /// \param[out] domain_id storage for the domain id
  /// \return `RCL_RET_OK` if node the domain ID was retrieved successfully, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_node_get_domain_id(
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<ffi.Uint64> domain_id,
  ) {
    return (_rcl_node_get_domain_id ??= _dylib.lookupFunction<
        _c_rcl_node_get_domain_id,
        _dart_rcl_node_get_domain_id>('rcl_node_get_domain_id'))(
      node,
      domain_id,
    );
  }

  _dart_rcl_node_get_domain_id? _rcl_node_get_domain_id;

  /// /// Return the rmw node handle.
  ///
  /// The handle returned is a pointer to the internally held rmw handle.
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is `NULL`
  /// - node has not been initialized (the implementation is invalid)
  ///
  /// The returned handle is made invalid if the node is finalized or if
  /// rcl_shutdown() is called.
  /// The returned handle is not guaranteed to be valid for the life time of the
  /// node as it may be finalized and recreated itself.
  /// Therefore it is recommended to get the handle from the node using
  /// this function each time it is needed and avoid use of the handle
  /// concurrently with functions that might change it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node pointer to the rcl node
  /// \return rmw node handle if successful, otherwise `NULL`
  ffi.Pointer<rmw_node_t> rcl_node_get_rmw_handle(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_get_rmw_handle ??= _dylib.lookupFunction<
        _c_rcl_node_get_rmw_handle,
        _dart_rcl_node_get_rmw_handle>('rcl_node_get_rmw_handle'))(
      node,
    );
  }

  _dart_rcl_node_get_rmw_handle? _rcl_node_get_rmw_handle;

  /// /// Return the associated rcl instance id.
  ///
  /// This id is stored when rcl_node_init is called and can be compared with the
  /// value returned by rcl_get_instance_id() to check if this node was created in
  /// the current rcl context (since the latest call to rcl_init().
  ///
  /// This function can fail, and therefore return `0`, if:
  /// - node is `NULL`
  /// - node has not been initialized (the implementation is invalid)
  ///
  /// This function will succeed even if rcl_shutdown() has been called
  /// since the node was created.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node pointer to the rcl node
  /// \return rcl instance id captured during node init or `0` on error
  int rcl_node_get_rcl_instance_id(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_get_rcl_instance_id ??= _dylib.lookupFunction<
        _c_rcl_node_get_rcl_instance_id,
        _dart_rcl_node_get_rcl_instance_id>('rcl_node_get_rcl_instance_id'))(
      node,
    );
  }

  _dart_rcl_node_get_rcl_instance_id? _rcl_node_get_rcl_instance_id;

  /// /// Return a guard condition which is triggered when the ROS graph changes.
  ///
  /// The handle returned is a pointer to an internally held rcl guard condition.
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is `NULL`
  /// - node is invalid
  ///
  /// The returned handle is made invalid if the node is finialized or if
  /// rcl_shutdown() is called.
  ///
  /// The guard condition will be triggered anytime a change to the ROS graph occurs.
  /// A ROS graph change includes things like (but not limited to) a new publisher
  /// advertises, a new subscription is created, a new service becomes available,
  /// a subscription is canceled, etc.
  ///
  /// \todo TODO(wjwwood): link to exhaustive list of graph events
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node pointer to the rcl node
  /// \return rcl guard condition handle if successful, otherwise `NULL`
  ffi.Pointer<rcl_guard_condition_t> rcl_node_get_graph_guard_condition(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_get_graph_guard_condition ??= _dylib.lookupFunction<
            _c_rcl_node_get_graph_guard_condition,
            _dart_rcl_node_get_graph_guard_condition>(
        'rcl_node_get_graph_guard_condition'))(
      node,
    );
  }

  _dart_rcl_node_get_graph_guard_condition? _rcl_node_get_graph_guard_condition;

  /// /// Return the logger name of the node.
  ///
  /// This function returns the node's internal logger name string.
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is `NULL`
  /// - node has not been initialized (the implementation is invalid)
  ///
  /// The returned string is only valid as long as the given rcl_node_t is valid.
  /// The value of the string may change if the value in the rcl_node_t changes,
  /// and therefore copying the string is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] node pointer to the node
  /// \return logger_name string if successful, otherwise `NULL`
  ffi.Pointer<ffi.Int8> rcl_node_get_logger_name(
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_node_get_logger_name ??= _dylib.lookupFunction<
        _c_rcl_node_get_logger_name,
        _dart_rcl_node_get_logger_name>('rcl_node_get_logger_name'))(
      node,
    );
  }

  _dart_rcl_node_get_logger_name? _rcl_node_get_logger_name;

  /// /// Get the message type support handle specific to this identifier.
  ///
  /// The handle's message typesupport identifier function is returned or if the parameters are NULL
  /// then an assert will happen.
  ///
  /// \param handle Handle to message type support
  /// \param identifier The typesupport identifier to get the handle function for
  /// \return The associated message typesupport handle function.
  ffi.Pointer<rosidl_message_type_support_t> get_message_typesupport_handle(
    ffi.Pointer<rosidl_message_type_support_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return (_get_message_typesupport_handle ??= _dylib.lookupFunction<
            _c_get_message_typesupport_handle,
            _dart_get_message_typesupport_handle>(
        'get_message_typesupport_handle'))(
      handle,
      identifier,
    );
  }

  _dart_get_message_typesupport_handle? _get_message_typesupport_handle;

  /// If the identifier is the same as this handle's typesupport_identifier the handle is simply
  /// returned or if the parameters are NULL then an assert will happen.
  ///
  /// \param handle Handle to message type support
  /// \param identifier The typesupport identifier to get the handle function for
  /// \return if the identifier match's the handle's identifier then the handle's function
  /// is returned.
  ffi.Pointer<rosidl_message_type_support_t>
      get_message_typesupport_handle_function(
    ffi.Pointer<rosidl_message_type_support_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return (_get_message_typesupport_handle_function ??= _dylib.lookupFunction<
            _c_get_message_typesupport_handle_function,
            _dart_get_message_typesupport_handle_function>(
        'get_message_typesupport_handle_function'))(
      handle,
      identifier,
    );
  }

  _dart_get_message_typesupport_handle_function?
      _get_message_typesupport_handle_function;

  /// /// Return a rcl_publisher_t struct with members set to `NULL`.
  ///
  /// Should be called to get a null rcl_publisher_t before passing to
  /// rcl_publisher_init().
  rcl_publisher_t rcl_get_zero_initialized_publisher() {
    return (_rcl_get_zero_initialized_publisher ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_publisher,
            _dart_rcl_get_zero_initialized_publisher>(
        'rcl_get_zero_initialized_publisher'))();
  }

  _dart_rcl_get_zero_initialized_publisher? _rcl_get_zero_initialized_publisher;

  /// /// Initialize a rcl publisher.
  ///
  /// After calling this function on a rcl_publisher_t, it can be used to publish
  /// messages of the given type to the given topic using rcl_publish().
  ///
  /// The given rcl_node_t must be valid and the resulting rcl_publisher_t is only
  /// valid as long as the given rcl_node_t remains valid.
  ///
  /// The rosidl_message_type_support_t is obtained on a per .msg type basis.
  /// When the user defines a ROS message, code is generated which provides the
  /// required rosidl_message_type_support_t object.
  /// This object can be obtained using a language appropriate mechanism.
  /// \todo TODO(wjwwood) write these instructions once and link to it instead
  ///
  /// For C, a macro can be used (for example `std_msgs/String`):
  ///
  /// ```c
  /// #include <rosidl_runtime_c/message_type_support_struct.h>
  /// #include <std_msgs/msg/string.h>
  /// const rosidl_message_type_support_t * string_ts =
  /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  /// ```
  ///
  /// For C++, a template function is used:
  ///
  /// ```cpp
  /// #include <rosidl_typesupport_cpp/message_type_support.hpp>
  /// #include <std_msgs/msg/string.hpp>
  /// const rosidl_message_type_support_t * string_ts =
  /// rosidl_typesupport_cpp::get_message_type_support_handle<std_msgs::msg::String>();
  /// ```
  ///
  /// The rosidl_message_type_support_t object contains message type specific
  /// information used to publish messages.
  ///
  /// The topic name must be a c string which follows the topic and service name
  /// format rules for unexpanded names, also known as non-fully qualified names:
  ///
  /// \see rcl_expand_topic_name
  ///
  /// The options struct allows the user to set the quality of service settings as
  /// well as a custom allocator which is used when initializing/finalizing the
  /// publisher to allocate space for incidentals, e.g. the topic name string.
  ///
  /// Expected usage (for C messages):
  ///
  /// ```c
  /// #include <rcl/rcl.h>
  /// #include <rosidl_runtime_c/message_type_support_struct.h>
  /// #include <std_msgs/msg/string.h>
  ///
  /// rcl_node_t node = rcl_get_zero_initialized_node();
  /// rcl_node_options_t node_ops = rcl_node_get_default_options();
  /// rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  /// // ... error handling
  /// const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  /// rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();
  /// rcl_publisher_options_t publisher_ops = rcl_publisher_get_default_options();
  /// ret = rcl_publisher_init(&publisher, &node, ts, "chatter", &publisher_ops);
  /// // ... error handling, and on shutdown do finalization:
  /// ret = rcl_publisher_fini(&publisher, &node);
  /// // ... error handling for rcl_publisher_fini()
  /// ret = rcl_node_fini(&node);
  /// // ... error handling for rcl_deinitialize_node()
  /// ```
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] publisher preallocated publisher structure
  /// \param[in] node valid rcl node handle
  /// \param[in] type_support type support object for the topic's type
  /// \param[in] topic_name the name of the topic to publish on
  /// \param[in] options publisher options, including quality of service settings
  /// \return `RCL_RET_OK` if the publisher was initialized successfully, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_ALREADY_INIT` if the publisher is already initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory fails, or
  /// \return `RCL_RET_TOPIC_NAME_INVALID` if the given topic name is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_publisher_init(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<rcl_publisher_options_t> options,
  ) {
    return (_rcl_publisher_init ??=
        _dylib.lookupFunction<_c_rcl_publisher_init, _dart_rcl_publisher_init>(
            'rcl_publisher_init'))(
      publisher,
      node,
      type_support,
      topic_name,
      options,
    );
  }

  _dart_rcl_publisher_init? _rcl_publisher_init;

  /// /// Finalize a rcl_publisher_t.
  ///
  /// After calling, the node will no longer be advertising that it is publishing
  /// on this topic (assuming this is the only publisher on this topic).
  ///
  /// After calling, calls to rcl_publish will fail when using this publisher.
  /// However, the given node handle is still valid.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] publisher handle to the publisher to be finalized
  /// \param[in] node a valid (not finalized) handle to the node used to create the publisher
  /// \return `RCL_RET_OK` if publisher was finalized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_publisher_fini(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_publisher_fini ??=
        _dylib.lookupFunction<_c_rcl_publisher_fini, _dart_rcl_publisher_fini>(
            'rcl_publisher_fini'))(
      publisher,
      node,
    );
  }

  _dart_rcl_publisher_fini? _rcl_publisher_fini;

  /// /// Return the default publisher options in a rcl_publisher_options_t.
  ///
  /// The defaults are:
  ///
  /// - qos = rmw_qos_profile_default
  /// - allocator = rcl_get_default_allocator()
  /// - rmw_publisher_options = rmw_get_default_publisher_options()
  rcl_publisher_options_t rcl_publisher_get_default_options() {
    return (_rcl_publisher_get_default_options ??= _dylib.lookupFunction<
            _c_rcl_publisher_get_default_options,
            _dart_rcl_publisher_get_default_options>(
        'rcl_publisher_get_default_options'))();
  }

  _dart_rcl_publisher_get_default_options? _rcl_publisher_get_default_options;

  /// /// Borrow a loaned message.
  ///
  /// The memory allocated for the ros message belongs to the middleware and must not be deallocated
  /// other than by a call to \sa rcl_return_loaned_message_from_publisher.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No [0]
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// [0] the underlying middleware might allocate new memory or returns an existing chunk form a pool.
  /// The function in rcl however does not allocate any additional memory.
  ///
  /// \param[in] publisher Publisher to which the allocated message is associated.
  /// \param[in] type_support Typesupport to which the internal ros message is allocated.
  /// \param[out] ros_message The pointer to be filled to a valid ros message by the middleware.
  /// \return `RCL_RET_OK` if the ros message was correctly initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if an argument other than the ros message is null, or
  /// \return `RCL_RET_BAD_ALLOC` if the ros message could not be correctly created, or
  /// \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  /// \return `RCL_RET_ERROR` if an unexpected error occured.
  int rcl_borrow_loaned_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
  ) {
    return (_rcl_borrow_loaned_message ??= _dylib.lookupFunction<
        _c_rcl_borrow_loaned_message,
        _dart_rcl_borrow_loaned_message>('rcl_borrow_loaned_message'))(
      publisher,
      type_support,
      ros_message,
    );
  }

  _dart_rcl_borrow_loaned_message? _rcl_borrow_loaned_message;

  /// /// Return a loaned message previously borrowed from a publisher.
  ///
  /// The ownership of the passed in ros message will be transferred back to the middleware.
  /// The middleware might deallocate and destroy the message so that the pointer is no longer
  /// guaranteed to be valid after that call.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher Publisher to which the loaned message is associated.
  /// \param[in] loaned_message Loaned message to be deallocated and destroyed.
  /// \return `RCL_RET_OK` if successful, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if an argument is null, or
  /// \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  /// \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  /// \return `RCL_RET_ERROR` if an unexpected error occurs and no message can be initialized.
  int rcl_return_loaned_message_from_publisher(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return (_rcl_return_loaned_message_from_publisher ??= _dylib.lookupFunction<
            _c_rcl_return_loaned_message_from_publisher,
            _dart_rcl_return_loaned_message_from_publisher>(
        'rcl_return_loaned_message_from_publisher'))(
      publisher,
      loaned_message,
    );
  }

  _dart_rcl_return_loaned_message_from_publisher?
      _rcl_return_loaned_message_from_publisher;

  /// /// Publish a ROS message on a topic using a publisher.
  ///
  /// It is the job of the caller to ensure that the type of the ros_message
  /// parameter and the type associate with the publisher (via the type support)
  /// match.
  /// Passing a different type to publish produces undefined behavior and cannot
  /// be checked by this function and therefore no deliberate error will occur.
  ///
  /// \todo TODO(wjwwood):
  /// The blocking behavior of publish is a still a point of dispute.
  /// This section should be updated once the behavior is clearly defined.
  /// See: https://github.com/ros2/ros2/issues/255
  ///
  /// Calling rcl_publish() is a potentially blocking call.
  /// When called rcl_publish() will immediately do any publishing related work,
  /// including, but not limited to, converting the message into a different type,
  /// serializing the message, collecting publish statistics, etc.
  /// The last thing it will do is call the underlying middleware's publish
  /// function which may or may not block based on the quality of service settings
  /// given via the publisher options in rcl_publisher_init().
  /// For example, if the reliability is set to reliable, then a publish may block
  /// until space in the publish queue is available, but if the reliability is set
  /// to best effort then it should not block.
  ///
  /// The ROS message given by the `ros_message` void pointer is always owned by
  /// the calling code, but should remain constant during publish.
  ///
  /// This function is thread safe so long as access to both the publisher and the
  /// `ros_message` is synchronized.
  /// That means that calling rcl_publish() from multiple threads is allowed, but
  /// calling rcl_publish() at the same time as non-thread safe publisher
  /// functions is not, e.g. calling rcl_publish() and rcl_publisher_fini()
  /// concurrently is not allowed.
  /// Before calling rcl_publish() the message can change and after calling
  /// rcl_publish() the message can change, but it cannot be changed during the
  /// publish call.
  /// The same `ros_message`, however, can be passed to multiple calls of
  /// rcl_publish() simultaneously, even if the publishers differ.
  /// The `ros_message` is unmodified by rcl_publish().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///
  /// \param[in] publisher handle to the publisher which will do the publishing
  /// \param[in] ros_message type-erased pointer to the ROS message
  /// \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  /// \return `RCL_RET_OK` if the message was published successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_publish(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return (_rcl_publish ??= _dylib
        .lookupFunction<_c_rcl_publish, _dart_rcl_publish>('rcl_publish'))(
      publisher,
      ros_message,
      allocation,
    );
  }

  _dart_rcl_publish? _rcl_publish;

  /// /// Publish a serialized message on a topic using a publisher.
  ///
  /// It is the job of the caller to ensure that the type of the serialized message
  /// parameter and the type associate with the publisher (via the type support)
  /// match.
  /// Even though this call to publish takes an already serialized serialized message,
  /// the publisher has to register its type as a ROS known message type.
  /// Passing a serialized message from a different type leads to undefined behavior on the subscriber side.
  /// The publish call might be able to send any abitrary serialized message, it is however
  /// not garantueed that the subscriber side successfully deserializes this byte stream.
  ///
  /// Apart from this, the `publish_serialized` function has the same behavior as `rcl_publish`
  /// expect that no serialization step is done.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///
  /// \param[in] publisher handle to the publisher which will do the publishing
  /// \param[in] serialized_message  pointer to the already serialized message in raw form
  /// \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  /// \return `RCL_RET_OK` if the message was published successfully, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_publish_serialized_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return (_rcl_publish_serialized_message ??= _dylib.lookupFunction<
            _c_rcl_publish_serialized_message,
            _dart_rcl_publish_serialized_message>(
        'rcl_publish_serialized_message'))(
      publisher,
      serialized_message,
      allocation,
    );
  }

  _dart_rcl_publish_serialized_message? _rcl_publish_serialized_message;

  /// /// Publish a loaned message on a topic using a publisher.
  ///
  /// A previously borrowed loaned message can be sent via this call to `rcl_publish_loaned_message`.
  /// By calling this function, the ownership of the loaned message is getting transferred back
  /// to the middleware.
  /// The pointer to the `ros_message` is not guaranteed to be valid after as the middleware
  /// migth deallocate the memory for this message internally.
  /// It is thus recommended to call this function only in combination with
  /// \sa `rcl_borrow_loaned_message`.
  ///
  /// Apart from this, the `publish_loaned_message` function has the same behavior as `rcl_publish`
  /// except that no serialization step is done.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No [0]
  /// Thread-Safe        | Yes [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[0] the middleware might deallocate the loaned message.
  /// The RCL function however does not allocate any memory.</i>
  /// <i>[1] for unique pairs of publishers and messages, see above for more</i>
  ///
  /// \param[in] publisher handle to the publisher which will do the publishing
  /// \param[in] ros_message  pointer to the previously borrow loaned message
  /// \param[in] allocation structure pointer, used for memory preallocation (may be NULL)
  /// \return `RCL_RET_OK` if the message was published successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  /// \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_publish_loaned_message(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return (_rcl_publish_loaned_message ??= _dylib.lookupFunction<
        _c_rcl_publish_loaned_message,
        _dart_rcl_publish_loaned_message>('rcl_publish_loaned_message'))(
      publisher,
      ros_message,
      allocation,
    );
  }

  _dart_rcl_publish_loaned_message? _rcl_publish_loaned_message;

  /// /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
  ///
  /// If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
  /// this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
  /// of the system that this Node is still alive.
  /// This function must be called at least as often as the qos_profile's liveliness_lease_duration
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher handle to the publisher that needs liveliness to be asserted
  /// \return `RCL_RET_OK` if the liveliness assertion was completed successfully, or
  /// \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_publisher_assert_liveliness(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_assert_liveliness ??= _dylib.lookupFunction<
            _c_rcl_publisher_assert_liveliness,
            _dart_rcl_publisher_assert_liveliness>(
        'rcl_publisher_assert_liveliness'))(
      publisher,
    );
  }

  _dart_rcl_publisher_assert_liveliness? _rcl_publisher_assert_liveliness;

  /// /// Get the topic name for the publisher.
  ///
  /// This function returns the publisher's internal topic name string.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - publisher is `NULL`
  /// - publisher is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned string is only valid as long as the rcl_publisher_t is valid.
  /// The value of the string may change if the topic name changes, and therefore
  /// copying the string is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher pointer to the publisher
  /// \return name string if successful, otherwise `NULL`
  ffi.Pointer<ffi.Int8> rcl_publisher_get_topic_name(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_get_topic_name ??= _dylib.lookupFunction<
        _c_rcl_publisher_get_topic_name,
        _dart_rcl_publisher_get_topic_name>('rcl_publisher_get_topic_name'))(
      publisher,
    );
  }

  _dart_rcl_publisher_get_topic_name? _rcl_publisher_get_topic_name;

  /// /// Return the rcl publisher options.
  ///
  /// This function returns the publisher's internal options struct.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - publisher is `NULL`
  /// - publisher is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned struct is only valid as long as the rcl_publisher_t is valid.
  /// The values in the struct may change if the options of the publisher change,
  /// and therefore copying the struct is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher pointer to the publisher
  /// \return options struct if successful, otherwise `NULL`
  ffi.Pointer<rcl_publisher_options_t> rcl_publisher_get_options(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_get_options ??= _dylib.lookupFunction<
        _c_rcl_publisher_get_options,
        _dart_rcl_publisher_get_options>('rcl_publisher_get_options'))(
      publisher,
    );
  }

  _dart_rcl_publisher_get_options? _rcl_publisher_get_options;

  /// /// Return the rmw publisher handle.
  ///
  /// The handle returned is a pointer to the internally held rmw handle.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - publisher is `NULL`
  /// - publisher is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned handle is made invalid if the publisher is finalized or if
  /// rcl_shutdown() is called.
  /// The returned handle is not guaranteed to be valid for the life time of the
  /// publisher as it may be finalized and recreated itself.
  /// Therefore it is recommended to get the handle from the publisher using
  /// this function each time it is needed and avoid use of the handle
  /// concurrently with functions that might change it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher pointer to the rcl publisher
  /// \return rmw publisher handle if successful, otherwise `NULL`
  ffi.Pointer<rmw_publisher_t> rcl_publisher_get_rmw_handle(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_get_rmw_handle ??= _dylib.lookupFunction<
        _c_rcl_publisher_get_rmw_handle,
        _dart_rcl_publisher_get_rmw_handle>('rcl_publisher_get_rmw_handle'))(
      publisher,
    );
  }

  _dart_rcl_publisher_get_rmw_handle? _rcl_publisher_get_rmw_handle;

  /// /// Return the context associated with this publisher.
  ///
  /// This function can fail, and therefore return `NULL`, if the:
  /// - publisher is `NULL`
  /// - publisher is invalid (never called init, called fini, etc.)
  ///
  /// The returned context is made invalid if the publisher is finalized or if
  /// rcl_shutdown() is called.
  /// Therefore it is recommended to get the handle from the publisher using
  /// this function each time it is needed and avoid use of the handle
  /// concurrently with functions that might change it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher pointer to the rcl publisher
  /// \return context if successful, otherwise `NULL`
  ffi.Pointer<rcl_context_t> rcl_publisher_get_context(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_get_context ??= _dylib.lookupFunction<
        _c_rcl_publisher_get_context,
        _dart_rcl_publisher_get_context>('rcl_publisher_get_context'))(
      publisher,
    );
  }

  _dart_rcl_publisher_get_context? _rcl_publisher_get_context;

  /// /// Return true if the publisher is valid, otherwise false.
  ///
  /// The bool returned is `false` if `publisher` is invalid.
  /// The bool returned is `true` otherwise.
  /// In the case where `false` is to be returned, an error message is set.
  /// This function cannot fail.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher pointer to the rcl publisher
  /// \return `true` if `publisher` is valid, otherwise `false`
  bool rcl_publisher_is_valid(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_is_valid ??= _dylib.lookupFunction<
            _c_rcl_publisher_is_valid,
            _dart_rcl_publisher_is_valid>('rcl_publisher_is_valid'))(
          publisher,
        ) !=
        0;
  }

  _dart_rcl_publisher_is_valid? _rcl_publisher_is_valid;

  /// /// Return true if the publisher is valid except the context, otherwise false.
  ///
  /// This is used in clean up functions that need to access the publisher, but do
  /// not need use any functions with the context.
  ///
  /// It is identical to rcl_publisher_is_valid except it ignores the state of the
  /// context associated with the publisher.
  /// \sa rcl_publisher_is_valid()
  bool rcl_publisher_is_valid_except_context(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_is_valid_except_context ??= _dylib.lookupFunction<
                _c_rcl_publisher_is_valid_except_context,
                _dart_rcl_publisher_is_valid_except_context>(
            'rcl_publisher_is_valid_except_context'))(
          publisher,
        ) !=
        0;
  }

  _dart_rcl_publisher_is_valid_except_context?
      _rcl_publisher_is_valid_except_context;

  /// /// Get the number of subscriptions matched to a publisher.
  ///
  /// Used to get the internal count of subscriptions matched to a publisher.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] only if the underlying rmw doesn't make use of this feature </i>
  ///
  /// \param[in] publisher pointer to the rcl publisher
  /// \param[out] subscription_count number of matched subscriptions
  /// \return `RCL_RET_OK` if the count was retrieved, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_publisher_get_subscription_count(
    ffi.Pointer<rcl_publisher_t> publisher,
    ffi.Pointer<ffi.Uint64> subscription_count,
  ) {
    return (_rcl_publisher_get_subscription_count ??= _dylib.lookupFunction<
            _c_rcl_publisher_get_subscription_count,
            _dart_rcl_publisher_get_subscription_count>(
        'rcl_publisher_get_subscription_count'))(
      publisher,
      subscription_count,
    );
  }

  _dart_rcl_publisher_get_subscription_count?
      _rcl_publisher_get_subscription_count;

  /// /// Get the actual qos settings of the publisher.
  ///
  /// Used to get the actual qos settings of the publisher.
  /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  /// can only be resolved after the creation of the publisher, and it
  /// depends on the underlying rmw implementation.
  /// If the underlying setting in use can't be represented in ROS terms,
  /// it will be set to RMW_*_UNKNOWN.
  /// The returned struct is only valid as long as the rcl_publisher_t is valid.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher pointer to the rcl publisher
  /// \return qos struct if successful, otherwise `NULL`
  ffi.Pointer<rmw_qos_profile_t> rcl_publisher_get_actual_qos(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_get_actual_qos ??= _dylib.lookupFunction<
        _c_rcl_publisher_get_actual_qos,
        _dart_rcl_publisher_get_actual_qos>('rcl_publisher_get_actual_qos'))(
      publisher,
    );
  }

  _dart_rcl_publisher_get_actual_qos? _rcl_publisher_get_actual_qos;

  /// /// Check if publisher instance can loan messages.
  ///
  /// Depending on the middleware and the message type, this will return true if the middleware
  /// can allocate a ROS message instance.
  bool rcl_publisher_can_loan_messages(
    ffi.Pointer<rcl_publisher_t> publisher,
  ) {
    return (_rcl_publisher_can_loan_messages ??= _dylib.lookupFunction<
                _c_rcl_publisher_can_loan_messages,
                _dart_rcl_publisher_can_loan_messages>(
            'rcl_publisher_can_loan_messages'))(
          publisher,
        ) !=
        0;
  }

  _dart_rcl_publisher_can_loan_messages? _rcl_publisher_can_loan_messages;

  /// /// Return an rmw_message_sequence_t struct with members initialized to `NULL`
  rmw_message_sequence_t rmw_get_zero_initialized_message_sequence() {
    return (_rmw_get_zero_initialized_message_sequence ??=
        _dylib.lookupFunction<_c_rmw_get_zero_initialized_message_sequence,
                _dart_rmw_get_zero_initialized_message_sequence>(
            'rmw_get_zero_initialized_message_sequence'))();
  }

  _dart_rmw_get_zero_initialized_message_sequence?
      _rmw_get_zero_initialized_message_sequence;

  /// /// Initialize an rmw_message_sequence_t object.
  ///
  /// \param[inout] sequence sequence object to be initialized.
  /// \param[in] size capacity of the sequence to be allocated.
  /// \param[in] allocator the allcator used to allocate memory.
  int rmw_message_sequence_init(
    ffi.Pointer<rmw_message_sequence_t> sequence,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rmw_message_sequence_init ??= _dylib.lookupFunction<
        _c_rmw_message_sequence_init,
        _dart_rmw_message_sequence_init>('rmw_message_sequence_init'))(
      sequence,
      size,
      allocator,
    );
  }

  _dart_rmw_message_sequence_init? _rmw_message_sequence_init;

  /// /// Finalize an rmw_message_sequence_t object.
  ///
  /// The rmw_message_sequence_t struct has members which require memory to be allocated to them
  /// before setting values.
  /// This function reclaims any allocated resources within the object and zeroes out all other
  /// members.
  ///
  /// Note: This will not call `fini` or deallocate the underlying message structures.
  ///
  /// \param[inout] sequence sequence object to be finalized.
  int rmw_message_sequence_fini(
    ffi.Pointer<rmw_message_sequence_t> sequence,
  ) {
    return (_rmw_message_sequence_fini ??= _dylib.lookupFunction<
        _c_rmw_message_sequence_fini,
        _dart_rmw_message_sequence_fini>('rmw_message_sequence_fini'))(
      sequence,
    );
  }

  _dart_rmw_message_sequence_fini? _rmw_message_sequence_fini;

  /// /// Return an rmw_message_info_sequence_t struct with members initialized to `NULL`
  rmw_message_info_sequence_t rmw_get_zero_initialized_message_info_sequence() {
    return (_rmw_get_zero_initialized_message_info_sequence ??=
        _dylib.lookupFunction<_c_rmw_get_zero_initialized_message_info_sequence,
                _dart_rmw_get_zero_initialized_message_info_sequence>(
            'rmw_get_zero_initialized_message_info_sequence'))();
  }

  _dart_rmw_get_zero_initialized_message_info_sequence?
      _rmw_get_zero_initialized_message_info_sequence;

  /// /// Initialize an rmw_message_info_sequence_t object.
  ///
  /// \param[inout] sequence sequence object to be initialized.
  /// \param[in] size capacity of the sequence to be allocated.
  /// \param[in] allocator the allcator used to allocate memory.
  int rmw_message_info_sequence_init(
    ffi.Pointer<rmw_message_info_sequence_t> sequence,
    int size,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rmw_message_info_sequence_init ??= _dylib.lookupFunction<
            _c_rmw_message_info_sequence_init,
            _dart_rmw_message_info_sequence_init>(
        'rmw_message_info_sequence_init'))(
      sequence,
      size,
      allocator,
    );
  }

  _dart_rmw_message_info_sequence_init? _rmw_message_info_sequence_init;

  /// /// Finalize an rmw_message_sequence_t object.
  ///
  /// The rmw_message_sequence_t struct has members which require memory to be allocated to them
  /// before setting values.
  /// This function reclaims any allocated resources within the object and zeroes out all other
  /// members.
  ///
  /// \param[inout] sequence sequence object to be finalized.
  int rmw_message_info_sequence_fini(
    ffi.Pointer<rmw_message_info_sequence_t> sequence,
  ) {
    return (_rmw_message_info_sequence_fini ??= _dylib.lookupFunction<
            _c_rmw_message_info_sequence_fini,
            _dart_rmw_message_info_sequence_fini>(
        'rmw_message_info_sequence_fini'))(
      sequence,
    );
  }

  _dart_rmw_message_info_sequence_fini? _rmw_message_info_sequence_fini;

  /// /// Return a rcl_subscription_t struct with members set to `NULL`.
  ///
  /// Should be called to get a null rcl_subscription_t before passing to
  /// rcl_subscription_init().
  rcl_subscription_t rcl_get_zero_initialized_subscription() {
    return (_rcl_get_zero_initialized_subscription ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_subscription,
            _dart_rcl_get_zero_initialized_subscription>(
        'rcl_get_zero_initialized_subscription'))();
  }

  _dart_rcl_get_zero_initialized_subscription?
      _rcl_get_zero_initialized_subscription;

  /// /// Initialize a ROS subscription.
  ///
  /// After calling this function on a rcl_subscription_t, it can be used to take
  /// messages of the given type to the given topic using rcl_take().
  ///
  /// The given rcl_node_t must be valid and the resulting rcl_subscription_t is
  /// only valid as long as the given rcl_node_t remains valid.
  ///
  /// The rosidl_message_type_support_t is obtained on a per .msg type basis.
  /// When the user defines a ROS message, code is generated which provides the
  /// required rosidl_message_type_support_t object.
  /// This object can be obtained using a language appropriate mechanism.
  /// \todo TODO(wjwwood) write these instructions once and link to it instead
  /// For C a macro can be used (for example `std_msgs/String`):
  ///
  /// ```c
  /// #include <rosidl_runtime_c/message_type_support_struct.h>
  /// #include <std_msgs/msg/string.h>
  /// const rosidl_message_type_support_t * string_ts =
  /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  /// ```
  ///
  /// For C++ a template function is used:
  ///
  /// ```cpp
  /// #include <rosidl_runtime_cpp/message_type_support.hpp>
  /// #include <std_msgs/msgs/string.hpp>
  /// using rosidl_typesupport_cpp::get_message_type_support_handle;
  /// const rosidl_message_type_support_t * string_ts =
  /// get_message_type_support_handle<std_msgs::msg::String>();
  /// ```
  ///
  /// The rosidl_message_type_support_t object contains message type specific
  /// information used to publish messages.
  ///
  /// The topic name must be a c string which follows the topic and service name
  /// format rules for unexpanded names, also known as non-fully qualified names:
  ///
  /// \see rcl_expand_topic_name
  ///
  /// The options struct allows the user to set the quality of service settings as
  /// well as a custom allocator which is used when (de)initializing the
  /// subscription to allocate space for incidental things, e.g. the topic
  /// name string.
  ///
  /// Expected usage (for C messages):
  ///
  /// ```c
  /// #include <rcl/rcl.h>
  /// #include <rosidl_runtime_c/message_type_support_struct.h>
  /// #include <std_msgs/msg/string.h>
  ///
  /// rcl_node_t node = rcl_get_zero_initialized_node();
  /// rcl_node_options_t node_ops = rcl_node_get_default_options();
  /// rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  /// // ... error handling
  /// const rosidl_message_type_support_t * ts =
  /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
  /// rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();
  /// rcl_subscription_options_t subscription_ops = rcl_subscription_get_default_options();
  /// ret = rcl_subscription_init(&subscription, &node, ts, "chatter", &subscription_ops);
  /// // ... error handling, and when finished deinitialization
  /// ret = rcl_subscription_fini(&subscription, &node);
  /// // ... error handling for rcl_subscription_fini()
  /// ret = rcl_node_fini(&node);
  /// // ... error handling for rcl_node_fini()
  /// ```
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[out] subscription preallocated subscription structure
  /// \param[in] node valid rcl node handle
  /// \param[in] type_support type support object for the topic's type
  /// \param[in] topic_name the name of the topic
  /// \param[in] options subscription options, including quality of service settings
  /// \return `RCL_RET_OK` if subscription was initialized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ALREADY_INIT` if the subcription is already initialized, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_TOPIC_NAME_INVALID` if the given topic name is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_subscription_init(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<rcl_subscription_options_t> options,
  ) {
    return (_rcl_subscription_init ??= _dylib.lookupFunction<
        _c_rcl_subscription_init,
        _dart_rcl_subscription_init>('rcl_subscription_init'))(
      subscription,
      node,
      type_support,
      topic_name,
      options,
    );
  }

  _dart_rcl_subscription_init? _rcl_subscription_init;

  /// /// Finalize a rcl_subscription_t.
  ///
  /// After calling, the node will no longer be subscribed on this topic
  /// (assuming this is the only subscription on this topic in this node).
  ///
  /// After calling, calls to rcl_wait and rcl_take will fail when using this
  /// subscription.
  /// Additioanlly rcl_wait will be interrupted if currently blocking.
  /// However, the given node handle is still valid.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] subscription handle to the subscription to be deinitialized
  /// \param[in] node a valid (not finalized) handle to the node used to create the subscription
  /// \return `RCL_RET_OK` if subscription was deinitialized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_subscription_fini(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_subscription_fini ??= _dylib.lookupFunction<
        _c_rcl_subscription_fini,
        _dart_rcl_subscription_fini>('rcl_subscription_fini'))(
      subscription,
      node,
    );
  }

  _dart_rcl_subscription_fini? _rcl_subscription_fini;

  /// /// Return the default subscription options in a rcl_subscription_options_t.
  ///
  /// The defaults are:
  ///
  /// - qos = rmw_qos_profile_default
  /// - allocator = rcl_get_default_allocator()
  /// - rmw_subscription_options = rmw_get_default_subscription_options();
  rcl_subscription_options_t rcl_subscription_get_default_options() {
    return (_rcl_subscription_get_default_options ??= _dylib.lookupFunction<
            _c_rcl_subscription_get_default_options,
            _dart_rcl_subscription_get_default_options>(
        'rcl_subscription_get_default_options'))();
  }

  _dart_rcl_subscription_get_default_options?
      _rcl_subscription_get_default_options;

  /// /// Take a ROS message from a topic using a rcl subscription.
  ///
  /// It is the job of the caller to ensure that the type of the ros_message
  /// argument and the type associated with the subscription, via the type
  /// support, match.
  /// Passing a different type to rcl_take produces undefined behavior and cannot
  /// be checked by this function and therefore no deliberate error will occur.
  ///
  /// TODO(wjwwood) blocking of take?
  /// TODO(wjwwood) pre-, during-, and post-conditions for message ownership?
  /// TODO(wjwwood) is rcl_take thread-safe?
  /// TODO(wjwwood) Should there be an rcl_message_info_t?
  ///
  /// The ros_message pointer should point to an already allocated ROS message
  /// struct of the correct type, into which the taken ROS message will be copied
  /// if one is available.
  /// If taken is false after calling, then the ROS message will be unmodified.
  ///
  /// The taken boolean may be false even if a wait set reports that the
  /// subscription was ready to be taken from in some cases, e.g. when the
  /// state of the subscription changes it may cause the wait set to wake up
  /// but subsequent takes to fail to take anything.
  ///
  /// If allocation is required when taking the message, e.g. if space needs to
  /// be allocated for a dynamically sized array in the target message, then the
  /// allocator given in the subscription options is used.
  ///
  /// The rmw_message_info struct contains meta information about this particular
  /// message instance, like what the GUID of the publisher which published it
  /// originally or whether or not the message received from within the same
  /// process.
  /// The message_info argument should be an already allocated rmw_message_info_t
  /// structure.
  /// Passing `NULL` for message_info will result in the argument being ignored.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] only if required when filling the message, avoided for fixed sizes</i>
  ///
  /// \param[in] subscription the handle to the subscription from which to take
  /// \param[inout] ros_message type-erased ptr to a allocated ROS message
  /// \param[out] message_info rmw struct which contains meta-data for the message
  /// \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  /// \return `RCL_RET_OK` if the message was taken, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
  /// occurred in the middleware, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_take(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rcl_take ??=
        _dylib.lookupFunction<_c_rcl_take, _dart_rcl_take>('rcl_take'))(
      subscription,
      ros_message,
      message_info,
      allocation,
    );
  }

  _dart_rcl_take? _rcl_take;

  /// /// Take a sequence of messages from a topic using a rcl subscription.
  ///
  /// In contrast to `rcl_take`, this function can take multiple messages at
  /// the same time.
  /// It is the job of the caller to ensure that the type of the message_sequence
  /// argument and the type associated with the subscription, via the type
  /// support, match.
  ///
  /// The message_sequence pointer should point to an already allocated sequence
  /// of ROS messages of the correct type, into which the taken ROS messages will
  /// be copied if messages are available.
  /// The message_sequence `size` member will be set to the number of messages
  /// correctly taken.
  ///
  /// The rmw_message_info_sequence struct contains meta information about the
  /// corresponding message instance index.
  /// The message_info_sequence argument should be an already allocated
  /// rmw_message_info_sequence_t structure.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] only if storage in the serialized_message is insufficient</i>
  ///
  /// \param[in] subscription the handle to the subscription from which to take.
  /// \param[in] count number of messages to attempt to take.
  /// \param[inout] message_sequence pointer to a (pre-allocated) message sequence.
  /// \param[inout] message_info_sequence pointer to a (pre-allocated) message info sequence.
  /// \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  /// \return `RCL_RET_OK` if one or more messages was taken, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
  /// occurred in the middleware, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_take_sequence(
    ffi.Pointer<rcl_subscription_t> subscription,
    int count,
    ffi.Pointer<rmw_message_sequence_t> message_sequence,
    ffi.Pointer<rmw_message_info_sequence_t> message_info_sequence,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rcl_take_sequence ??=
        _dylib.lookupFunction<_c_rcl_take_sequence, _dart_rcl_take_sequence>(
            'rcl_take_sequence'))(
      subscription,
      count,
      message_sequence,
      message_info_sequence,
      allocation,
    );
  }

  _dart_rcl_take_sequence? _rcl_take_sequence;

  /// /// Take a serialized raw message from a topic using a rcl subscription.
  ///
  /// In contrast to `rcl_take`, this function stores the taken message in
  /// its raw binary representation.
  /// It is the job of the caller to ensure that the type associate with the subscription
  /// matches, and can optionally be deserialized into its ROS message via, the correct
  /// type support.
  /// If the `serialized_message` parameter contains enough preallocated memory, the incoming
  /// message can be taken without any additional memory allocation.
  /// If not, the function will dynamically allocate enough memory for the message.
  /// Passing a different type to rcl_take produces undefined behavior and cannot
  /// be checked by this function and therefore no deliberate error will occur.
  ///
  /// Apart from the differences above, this function behaves like `rcl_take`.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] only if storage in the serialized_message is insufficient</i>
  ///
  /// \param[in] subscription the handle to the subscription from which to take
  /// \param[inout] serialized_message pointer to a (pre-allocated) serialized message.
  /// \param[out] message_info rmw struct which contains meta-data for the message
  /// \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  /// \return `RCL_RET_OK` if the message was published, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
  /// occurred in the middleware, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_take_serialized_message(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rcl_take_serialized_message ??= _dylib.lookupFunction<
        _c_rcl_take_serialized_message,
        _dart_rcl_take_serialized_message>('rcl_take_serialized_message'))(
      subscription,
      serialized_message,
      message_info,
      allocation,
    );
  }

  _dart_rcl_take_serialized_message? _rcl_take_serialized_message;

  /// /// Take a loaned message from a topic using a rcl subscription.
  ///
  /// Depending on the middleware, incoming messages can be loaned to the user's callback
  /// without further copying.
  /// The implicit contract here is that the middleware owns the memory allocated for this message.
  /// The user must not destroy the message, but rather has to return it with a call to
  /// \sa rcl_return_loaned_message to the middleware.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] subscription the handle to the subscription from which to take
  /// \param[inout] loaned_message a pointer to the loaned messages.
  /// \param[out] message_info rmw struct which contains meta-data for the message.
  /// \param[in] allocation structure pointer used for memory preallocation (may be NULL)
  /// \return `RCL_RET_OK` if the loaned message sequence was taken, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
  /// occurred in the middleware, or
  /// \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_take_loaned_message(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rcl_take_loaned_message ??= _dylib.lookupFunction<
        _c_rcl_take_loaned_message,
        _dart_rcl_take_loaned_message>('rcl_take_loaned_message'))(
      subscription,
      loaned_message,
      message_info,
      allocation,
    );
  }

  _dart_rcl_take_loaned_message? _rcl_take_loaned_message;

  /// /// Return a loaned message from a topic using a rcl subscription.
  ///
  /// If a loaned message was previously obtained from the middleware with a call to
  /// \sa rcl_take_loaned_message, this message has to be returned to indicate to the middleware
  /// that the user no longer needs that memory.
  /// The user must not delete the message.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] subscription the handle to the subscription from which to take
  /// \param[in] loaned_message a pointer to the loaned messages.
  /// \return `RCL_RET_OK` if the message was published, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  /// \return `RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_return_loaned_message_from_subscription(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return (_rcl_return_loaned_message_from_subscription ??=
        _dylib.lookupFunction<_c_rcl_return_loaned_message_from_subscription,
                _dart_rcl_return_loaned_message_from_subscription>(
            'rcl_return_loaned_message_from_subscription'))(
      subscription,
      loaned_message,
    );
  }

  _dart_rcl_return_loaned_message_from_subscription?
      _rcl_return_loaned_message_from_subscription;

  /// /// Get the topic name for the subscription.
  ///
  /// This function returns the subscription's internal topic name string.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - subscription is `NULL`
  /// - subscription is invalid (never called init, called fini, or invalid)
  ///
  /// The returned string is only valid as long as the subscription is valid.
  /// The value of the string may change if the topic name changes, and therefore
  /// copying the string is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] subscription the pointer to the subscription
  /// \return name string if successful, otherwise `NULL`
  ffi.Pointer<ffi.Int8> rcl_subscription_get_topic_name(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return (_rcl_subscription_get_topic_name ??= _dylib.lookupFunction<
            _c_rcl_subscription_get_topic_name,
            _dart_rcl_subscription_get_topic_name>(
        'rcl_subscription_get_topic_name'))(
      subscription,
    );
  }

  _dart_rcl_subscription_get_topic_name? _rcl_subscription_get_topic_name;

  /// /// Return the rcl subscription options.
  ///
  /// This function returns the subscription's internal options struct.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - subscription is `NULL`
  /// - subscription is invalid (never called init, called fini, or invalid)
  ///
  /// The returned struct is only valid as long as the subscription is valid.
  /// The values in the struct may change if the subscription's options change,
  /// and therefore copying the struct is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] subscription pointer to the subscription
  /// \return options struct if successful, otherwise `NULL`
  ffi.Pointer<rcl_subscription_options_t> rcl_subscription_get_options(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return (_rcl_subscription_get_options ??= _dylib.lookupFunction<
        _c_rcl_subscription_get_options,
        _dart_rcl_subscription_get_options>('rcl_subscription_get_options'))(
      subscription,
    );
  }

  _dart_rcl_subscription_get_options? _rcl_subscription_get_options;

  /// /// Return the rmw subscription handle.
  ///
  /// The handle returned is a pointer to the internally held rmw handle.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - subscription is `NULL`
  /// - subscription is invalid (never called init, called fini, or invalid)
  ///
  /// The returned handle is made invalid if the subscription is finalized or if
  /// rcl_shutdown() is called.
  /// The returned handle is not guaranteed to be valid for the life time of the
  /// subscription as it may be finalized and recreated itself.
  /// Therefore it is recommended to get the handle from the subscription using
  /// this function each time it is needed and avoid use of the handle
  /// concurrently with functions that might change it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] subscription pointer to the rcl subscription
  /// \return rmw subscription handle if successful, otherwise `NULL`
  ffi.Pointer<rmw_subscription_t> rcl_subscription_get_rmw_handle(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return (_rcl_subscription_get_rmw_handle ??= _dylib.lookupFunction<
            _c_rcl_subscription_get_rmw_handle,
            _dart_rcl_subscription_get_rmw_handle>(
        'rcl_subscription_get_rmw_handle'))(
      subscription,
    );
  }

  _dart_rcl_subscription_get_rmw_handle? _rcl_subscription_get_rmw_handle;

  /// /// Check that the subscription is valid.
  ///
  /// The bool returned is `false` if `subscription` is invalid.
  /// The bool returned is `true` otherwise.
  /// In the case where `false` is to be returned, an error message is set.
  /// This function cannot fail.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] subscription pointer to the rcl subscription
  /// \return `true` if `subscription` is valid, otherwise `false`
  bool rcl_subscription_is_valid(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return (_rcl_subscription_is_valid ??= _dylib.lookupFunction<
            _c_rcl_subscription_is_valid,
            _dart_rcl_subscription_is_valid>('rcl_subscription_is_valid'))(
          subscription,
        ) !=
        0;
  }

  _dart_rcl_subscription_is_valid? _rcl_subscription_is_valid;

  /// /// Get the number of publishers matched to a subscription.
  ///
  /// Used to get the internal count of publishers matched to a subscription.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] only if the underlying rmw doesn't make use of this feature </i>
  ///
  /// \param[in] subscription pointer to the rcl subscription
  /// \param[out] publisher_count number of matched publishers
  /// \return `RCL_RET_OK` if the count was retrieved, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_subscription_get_publisher_count(
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Uint64> publisher_count,
  ) {
    return (_rcl_subscription_get_publisher_count ??= _dylib.lookupFunction<
            _c_rcl_subscription_get_publisher_count,
            _dart_rcl_subscription_get_publisher_count>(
        'rcl_subscription_get_publisher_count'))(
      subscription,
      publisher_count,
    );
  }

  _dart_rcl_subscription_get_publisher_count?
      _rcl_subscription_get_publisher_count;

  /// /// Get the actual qos settings of the subscription.
  ///
  /// Used to get the actual qos settings of the subscription.
  /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  /// can only be resolved after the creation of the subscription, and it
  /// depends on the underlying rmw implementation.
  /// If the underlying setting in use can't be represented in ROS terms,
  /// it will be set to RMW_*_UNKNOWN.
  /// The returned struct is only valid as long as the rcl_subscription_t is valid.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] subscription pointer to the rcl subscription
  /// \return qos struct if successful, otherwise `NULL`
  ffi.Pointer<rmw_qos_profile_t> rcl_subscription_get_actual_qos(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return (_rcl_subscription_get_actual_qos ??= _dylib.lookupFunction<
            _c_rcl_subscription_get_actual_qos,
            _dart_rcl_subscription_get_actual_qos>(
        'rcl_subscription_get_actual_qos'))(
      subscription,
    );
  }

  _dart_rcl_subscription_get_actual_qos? _rcl_subscription_get_actual_qos;

  /// /// Check if subscription instance can loan messages.
  ///
  /// Depending on the middleware and the message type, this will return true if the middleware
  /// can allocate a ROS message instance.
  bool rcl_subscription_can_loan_messages(
    ffi.Pointer<rcl_subscription_t> subscription,
  ) {
    return (_rcl_subscription_can_loan_messages ??= _dylib.lookupFunction<
                _c_rcl_subscription_can_loan_messages,
                _dart_rcl_subscription_can_loan_messages>(
            'rcl_subscription_can_loan_messages'))(
          subscription,
        ) !=
        0;
  }

  _dart_rcl_subscription_can_loan_messages? _rcl_subscription_can_loan_messages;

  /// /// Get the service type support handle specific to this identifier.
  ///
  /// The handle's message typesupport identifier function is returned or if the parameters are NULL
  /// then an assert will happen.
  ///
  /// \param handle Handle to service type support
  /// \param identifier The typesupport identifier to get the handle function for
  /// \return The associated service typesupport handle function.
  ffi.Pointer<rosidl_service_type_support_t> get_service_typesupport_handle(
    ffi.Pointer<rosidl_service_type_support_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return (_get_service_typesupport_handle ??= _dylib.lookupFunction<
            _c_get_service_typesupport_handle,
            _dart_get_service_typesupport_handle>(
        'get_service_typesupport_handle'))(
      handle,
      identifier,
    );
  }

  _dart_get_service_typesupport_handle? _get_service_typesupport_handle;

  /// /// Get the service type support handle function specific to this identifier.
  ///
  /// If the identifier is the same as this handle's typesupport_identifier the handle is simply
  /// returned or if the parameters are NULL then an assert will happen.
  ///
  /// \param handle Handle to service type support
  /// \param identifier The typesupport identifier to get the handle function for
  /// \return if the identifier match's the handle's identifier then the handle's function
  /// is returned.
  ffi.Pointer<rosidl_service_type_support_t>
      get_service_typesupport_handle_function(
    ffi.Pointer<rosidl_service_type_support_t> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return (_get_service_typesupport_handle_function ??= _dylib.lookupFunction<
            _c_get_service_typesupport_handle_function,
            _dart_get_service_typesupport_handle_function>(
        'get_service_typesupport_handle_function'))(
      handle,
      identifier,
    );
  }

  _dart_get_service_typesupport_handle_function?
      _get_service_typesupport_handle_function;

  /// /// Return a rcl_client_t struct with members set to `NULL`.
  ///
  /// Should be called to get a null rcl_client_t before passing to
  /// rcl_client_init().
  rcl_client_t rcl_get_zero_initialized_client() {
    return (_rcl_get_zero_initialized_client ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_client,
            _dart_rcl_get_zero_initialized_client>(
        'rcl_get_zero_initialized_client'))();
  }

  _dart_rcl_get_zero_initialized_client? _rcl_get_zero_initialized_client;

  /// /// Initialize a rcl client.
  ///
  /// After calling this function on a rcl_client_t, it can be used to send
  /// requests of the given type by calling rcl_send_request().
  /// If the request is received by a (possibly remote) service and if the service
  /// sends a response, the client can access the response through
  /// rcl_take_response() once the response is available to the client.
  ///
  /// The given rcl_node_t must be valid and the resulting rcl_client_t is only
  /// valid as long as the given rcl_node_t remains valid.
  ///
  /// The rosidl_service_type_support_t is obtained on a per `.srv` type basis.
  /// When the user defines a ROS service, code is generated which provides the
  /// required rosidl_service_type_support_t object.
  /// This object can be obtained using a language appropriate mechanism.
  /// \todo TODO(wjwwood) write these instructions once and link to it instead
  ///
  /// For C, a macro can be used (for example `example_interfaces/AddTwoInts`):
  ///
  /// ```c
  /// #include <rosidl_runtime_c/service_type_support_struct.h>
  /// #include <example_interfaces/srv/add_two_ints.h>
  ///
  /// const rosidl_service_type_support_t * ts =
  /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  /// ```
  ///
  /// For C++, a template function is used:
  ///
  /// ```cpp
  /// #include <rosidl_typesupport_cpp/service_type_support.hpp>
  /// #include <example_interfaces/srv/add_two_ints.hpp>
  ///
  /// using rosidl_typesupport_cpp::get_service_type_support_handle;
  /// const rosidl_service_type_support_t * ts =
  /// get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();
  /// ```
  ///
  /// The rosidl_service_type_support_t object contains service type specific
  /// information used to send or take requests and responses.
  ///
  /// The topic name must be a c string which follows the topic and service name
  /// format rules for unexpanded names, also known as non-fully qualified names:
  ///
  /// \see rcl_expand_topic_name
  ///
  /// The options struct allows the user to set the quality of service settings as
  /// well as a custom allocator which is used when initializing/finalizing the
  /// client to allocate space for incidentals, e.g. the service name string.
  ///
  /// Expected usage (for C services):
  ///
  /// ```c
  /// #include <rcl/rcl.h>
  /// #include <rosidl_runtime_c/service_type_support_struct.h>
  /// #include <example_interfaces/srv/add_two_ints.h>
  ///
  /// rcl_node_t node = rcl_get_zero_initialized_node();
  /// rcl_node_options_t node_ops = rcl_node_get_default_options();
  /// rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  /// // ... error handling
  /// const rosidl_service_type_support_t * ts =
  /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  /// rcl_client_t client = rcl_get_zero_initialized_client();
  /// rcl_client_options_t client_ops = rcl_client_get_default_options();
  /// ret = rcl_client_init(&client, &node, ts, "add_two_ints", &client_ops);
  /// // ... error handling, and on shutdown do finalization:
  /// ret = rcl_client_fini(&client, &node);
  /// // ... error handling for rcl_client_fini()
  /// ret = rcl_node_fini(&node);
  /// // ... error handling for rcl_node_fini()
  /// ```
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] client preallocated rcl_client_t structure
  /// \param[in] node valid rcl_node_t
  /// \param[in] type_support type support object for the service's type
  /// \param[in] service_name the name of the service to request
  /// \param[in] options client options, including quality of service settings
  /// \return `RCL_RET_OK` if the client was initialized successfully, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_ALREADY_INIT` if the client is already initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory fails, or
  /// \return `RCL_RET_SERVICE_NAME_INVALID` if the given service name is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_client_init(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> service_name,
    ffi.Pointer<rcl_client_options_t> options,
  ) {
    return (_rcl_client_init ??=
        _dylib.lookupFunction<_c_rcl_client_init, _dart_rcl_client_init>(
            'rcl_client_init'))(
      client,
      node,
      type_support,
      service_name,
      options,
    );
  }

  _dart_rcl_client_init? _rcl_client_init;

  /// /// Finalize a rcl_client_t.
  ///
  /// After calling this function, calls to rcl_send_request() and
  /// rcl_take_response() will fail when using this client.
  /// However, the given node handle is still valid.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] client handle to the client to be finalized
  /// \param[in] node a valid (not finalized) handle to the node used to create the client
  /// \return `RCL_RET_OK` if client was finalized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_client_fini(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_client_fini ??=
        _dylib.lookupFunction<_c_rcl_client_fini, _dart_rcl_client_fini>(
            'rcl_client_fini'))(
      client,
      node,
    );
  }

  _dart_rcl_client_fini? _rcl_client_fini;

  /// /// Return the default client options in a rcl_client_options_t.
  ///
  /// The defaults are:
  ///
  /// - qos = rmw_qos_profile_services_default
  /// - allocator = rcl_get_default_allocator()
  rcl_client_options_t rcl_client_get_default_options() {
    return (_rcl_client_get_default_options ??= _dylib.lookupFunction<
            _c_rcl_client_get_default_options,
            _dart_rcl_client_get_default_options>(
        'rcl_client_get_default_options'))();
  }

  _dart_rcl_client_get_default_options? _rcl_client_get_default_options;

  /// /// Send a ROS request using a client.
  ///
  /// It is the job of the caller to ensure that the type of the `ros_request`
  /// parameter and the type associate with the client (via the type support)
  /// match.
  /// Passing a different type to `send_request` produces undefined behavior and
  /// cannot be checked by this function and therefore no deliberate error will
  /// occur.
  ///
  /// rcl_send_request() is an non-blocking call.
  ///
  /// The ROS request message given by the `ros_request` void pointer is always
  /// owned by the calling code, but should remain constant during `send_request`.
  ///
  /// This function is thread safe so long as access to both the client and the
  /// `ros_request` is synchronized.
  /// That means that calling rcl_send_request() from multiple threads is allowed,
  /// but calling rcl_send_request() at the same time as non-thread safe client
  /// functions is not, e.g. calling rcl_send_request() and rcl_client_fini()
  /// concurrently is not allowed.
  /// Before calling rcl_send_request() the message can change and after calling
  /// rcl_send_request() the message can change, but it cannot be changed during
  /// the `send_request` call.
  /// The same `ros_request`, however, can be passed to multiple calls of
  /// rcl_send_request() simultaneously, even if the clients differ.
  /// The `ros_request` is unmodified by rcl_send_request().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] for unique pairs of clients and requests, see above for more</i>
  ///
  /// \param[in] client handle to the client which will make the response
  /// \param[in] ros_request type-erased pointer to the ROS request message
  /// \param[out] sequence_number the sequence number
  /// \return `RCL_RET_OK` if the request was sent successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_CLIENT_INVALID` if the client is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_send_request(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Int64> sequence_number,
  ) {
    return (_rcl_send_request ??=
        _dylib.lookupFunction<_c_rcl_send_request, _dart_rcl_send_request>(
            'rcl_send_request'))(
      client,
      ros_request,
      sequence_number,
    );
  }

  _dart_rcl_send_request? _rcl_send_request;

  /// /// Take a ROS response using a client
  ///
  /// It is the job of the caller to ensure that the type of the `ros_response`
  /// parameter and the type associate with the client (via the type support)
  /// match.
  /// Passing a different type to take_response produces undefined behavior and
  /// cannot be checked by this function and therefore no deliberate error will
  /// occur.
  /// The request_header is an rmw struct for meta-information about the request
  /// sent (e.g. the sequence number).
  /// The caller must provide a pointer to an allocated struct.
  /// This function will populate the struct's fields.
  /// `ros_response` should point to an already allocated ROS response message
  /// struct of the correct type, into which the response from the service will be
  /// copied.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] only if required when filling the message, avoided for fixed sizes</i>
  ///
  /// \param[in] client handle to the client which will take the response
  /// \param[inout] request_header pointer to the request header
  /// \param[inout] ros_response type-erased pointer to the ROS response message
  /// \return `RCL_RET_OK` if the response was taken successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_CLIENT_INVALID` if the client is invalid, or
  /// \return `RCL_RET_CLIENT_TAKE_FAILED` if take failed but no error occurred
  /// in the middleware, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_take_response_with_info(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rmw_service_info_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return (_rcl_take_response_with_info ??= _dylib.lookupFunction<
        _c_rcl_take_response_with_info,
        _dart_rcl_take_response_with_info>('rcl_take_response_with_info'))(
      client,
      request_header,
      ros_response,
    );
  }

  _dart_rcl_take_response_with_info? _rcl_take_response_with_info;

  /// /// backwards compatibility function that takes a rmw_request_id_t only
  int rcl_take_response(
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return (_rcl_take_response ??=
        _dylib.lookupFunction<_c_rcl_take_response, _dart_rcl_take_response>(
            'rcl_take_response'))(
      client,
      request_header,
      ros_response,
    );
  }

  _dart_rcl_take_response? _rcl_take_response;

  /// /// Get the name of the service that this client will request a response from.
  ///
  /// This function returns the client's internal service name string.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - client is `NULL`
  /// - client is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned string is only valid as long as the rcl_client_t is valid.
  /// The value of the string may change if the service name changes, and therefore
  /// copying the string is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] client pointer to the client
  /// \return name string if successful, otherwise `NULL`
  ffi.Pointer<ffi.Int8> rcl_client_get_service_name(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return (_rcl_client_get_service_name ??= _dylib.lookupFunction<
        _c_rcl_client_get_service_name,
        _dart_rcl_client_get_service_name>('rcl_client_get_service_name'))(
      client,
    );
  }

  _dart_rcl_client_get_service_name? _rcl_client_get_service_name;

  /// /// Return the rcl client options.
  ///
  /// This function returns the client's internal options struct.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - client is `NULL`
  /// - client is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned struct is only valid as long as the rcl_client_t is valid.
  /// The values in the struct may change if the options of the client change,
  /// and therefore copying the struct is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] client pointer to the client
  /// \return options struct if successful, otherwise `NULL`
  ffi.Pointer<rcl_client_options_t> rcl_client_get_options(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return (_rcl_client_get_options ??= _dylib.lookupFunction<
        _c_rcl_client_get_options,
        _dart_rcl_client_get_options>('rcl_client_get_options'))(
      client,
    );
  }

  _dart_rcl_client_get_options? _rcl_client_get_options;

  /// /// Return the rmw client handle.
  ///
  /// The handle returned is a pointer to the internally held rmw handle.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - client is `NULL`
  /// - client is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned handle is made invalid if the client is finalized or if
  /// rcl_shutdown() is called.
  /// The returned handle is not guaranteed to be valid for the life time of the
  /// client as it may be finalized and recreated itself.
  /// Therefore it is recommended to get the handle from the client using
  /// this function each time it is needed and avoid use of the handle
  /// concurrently with functions that might change it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] client pointer to the rcl client
  /// \return rmw client handle if successful, otherwise `NULL`
  ffi.Pointer<rmw_client_t> rcl_client_get_rmw_handle(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return (_rcl_client_get_rmw_handle ??= _dylib.lookupFunction<
        _c_rcl_client_get_rmw_handle,
        _dart_rcl_client_get_rmw_handle>('rcl_client_get_rmw_handle'))(
      client,
    );
  }

  _dart_rcl_client_get_rmw_handle? _rcl_client_get_rmw_handle;

  /// /// Check that the client is valid.
  ///
  /// The bool returned is `false` if client is invalid.
  /// The bool returned is `true` otherwise.
  /// In the case where `false` is to be returned, an error message is set.
  /// This function cannot fail.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] client pointer to the rcl client
  /// \return `true` if `client` is valid, otherwise `false`
  bool rcl_client_is_valid(
    ffi.Pointer<rcl_client_t> client,
  ) {
    return (_rcl_client_is_valid ??= _dylib.lookupFunction<
            _c_rcl_client_is_valid,
            _dart_rcl_client_is_valid>('rcl_client_is_valid'))(
          client,
        ) !=
        0;
  }

  _dart_rcl_client_is_valid? _rcl_client_is_valid;

  /// /// Return a rcl_guard_condition_t struct with members set to `NULL`.
  rcl_guard_condition_t rcl_get_zero_initialized_guard_condition() {
    return (_rcl_get_zero_initialized_guard_condition ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_guard_condition,
            _dart_rcl_get_zero_initialized_guard_condition>(
        'rcl_get_zero_initialized_guard_condition'))();
  }

  _dart_rcl_get_zero_initialized_guard_condition?
      _rcl_get_zero_initialized_guard_condition;

  /// /// Initialize a rcl guard_condition.
  ///
  /// After calling this function on a rcl_guard_condition_t, it can be passed to
  /// rcl_wait() and then concurrently it can be triggered to wake-up rcl_wait().
  ///
  /// Expected usage:
  ///
  /// ```c
  /// #include <rcl/rcl.h>
  ///
  /// // ... error handling
  /// rcl_guard_condition_t guard_condition = rcl_get_zero_initialized_guard_condition();
  /// // ... customize guard condition options
  /// rcl_ret_t ret = rcl_guard_condition_init(
  /// &guard_condition, context, rcl_guard_condition_get_default_options());
  /// // ... error handling, and on shutdown do deinitialization:
  /// ret = rcl_guard_condition_fini(&guard_condition);
  /// // ... error handling for rcl_guard_condition_fini()
  /// ```
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] guard_condition preallocated guard_condition structure
  /// \param[in] context the context instance with which the guard condition
  /// should be associated
  /// \param[in] options the guard_condition's options
  /// \return `RCL_RET_OK` if guard_condition was initialized successfully, or
  /// \return `RCL_RET_ALREADY_INIT` if the guard condition is already initialized, or
  /// \return `RCL_RET_NOT_INIT` if the given context is invalid, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_guard_condition_init(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<rcl_context_t> context,
    rcl_guard_condition_options_t options,
  ) {
    return (_rcl_guard_condition_init ??= _dylib.lookupFunction<
        _c_rcl_guard_condition_init,
        _dart_rcl_guard_condition_init>('rcl_guard_condition_init'))(
      guard_condition,
      context,
      options,
    );
  }

  _dart_rcl_guard_condition_init? _rcl_guard_condition_init;

  /// /// Same as rcl_guard_condition_init(), but reusing an existing rmw handle.
  ///
  /// In addition to the documentation for rcl_guard_condition_init(), the
  /// `rmw_guard_condition` parameter must not be `NULL` and must point to a valid
  /// rmw guard condition.
  ///
  /// Also the life time of the rcl guard condition is tied to the life time of
  /// the rmw guard condition.
  /// So if the rmw guard condition is destroyed before the rcl guard condition,
  /// the rcl guard condition becomes invalid.
  ///
  /// Similarly if the resulting rcl guard condition is fini'ed before the rmw
  /// guard condition, then the rmw guard condition is no longer valid.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] guard_condition preallocated guard_condition structure
  /// \param[in] rmw_guard_condition existing rmw guard condition to reuse
  /// \param[in] context the context instance with which the rmw guard condition
  /// was initialized with, i.e. the rmw context inside rcl context needs to
  /// match rmw context in rmw guard condition
  /// \param[in] options the guard_condition's options
  /// \return `RCL_RET_OK` if guard_condition was initialized successfully, or
  /// \return `RCL_RET_ALREADY_INIT` if the guard condition is already initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_guard_condition_init_from_rmw(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<rmw_guard_condition_t> rmw_guard_condition,
    ffi.Pointer<rcl_context_t> context,
    rcl_guard_condition_options_t options,
  ) {
    return (_rcl_guard_condition_init_from_rmw ??= _dylib.lookupFunction<
            _c_rcl_guard_condition_init_from_rmw,
            _dart_rcl_guard_condition_init_from_rmw>(
        'rcl_guard_condition_init_from_rmw'))(
      guard_condition,
      rmw_guard_condition,
      context,
      options,
    );
  }

  _dart_rcl_guard_condition_init_from_rmw? _rcl_guard_condition_init_from_rmw;

  /// /// Finalize a rcl_guard_condition_t.
  ///
  /// After calling, calls to rcl_trigger_guard_condition() will fail when using
  /// this guard condition.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] specifically not thread-safe with rcl_trigger_guard_condition()</i>
  ///
  /// \param[inout] guard_condition handle to the guard_condition to be finalized
  /// \return `RCL_RET_OK` if guard_condition was finalized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_guard_condition_fini(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return (_rcl_guard_condition_fini ??= _dylib.lookupFunction<
        _c_rcl_guard_condition_fini,
        _dart_rcl_guard_condition_fini>('rcl_guard_condition_fini'))(
      guard_condition,
    );
  }

  _dart_rcl_guard_condition_fini? _rcl_guard_condition_fini;

  /// /// Return the default options in a rcl_guard_condition_options_t struct.
  ///
  /// The defaults are:
  ///
  /// - allocator = rcl_get_default_allocator()
  rcl_guard_condition_options_t rcl_guard_condition_get_default_options() {
    return (_rcl_guard_condition_get_default_options ??= _dylib.lookupFunction<
            _c_rcl_guard_condition_get_default_options,
            _dart_rcl_guard_condition_get_default_options>(
        'rcl_guard_condition_get_default_options'))();
  }

  _dart_rcl_guard_condition_get_default_options?
      _rcl_guard_condition_get_default_options;

  /// /// Trigger a rcl guard condition.
  ///
  /// This function can fail, and return RCL_RET_INVALID_ARGUMENT, if the:
  /// - guard condition is `NULL`
  /// - guard condition is invalid (never called init or called fini)
  ///
  /// A guard condition can be triggered from any thread.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] it can be called concurrently with itself, even on the same guard condition</i>
  ///
  /// \param[in] guard_condition handle to the guard_condition to be triggered
  /// \return `RCL_RET_OK` if the guard condition was triggered, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_trigger_guard_condition(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return (_rcl_trigger_guard_condition ??= _dylib.lookupFunction<
        _c_rcl_trigger_guard_condition,
        _dart_rcl_trigger_guard_condition>('rcl_trigger_guard_condition'))(
      guard_condition,
    );
  }

  _dart_rcl_trigger_guard_condition? _rcl_trigger_guard_condition;

  /// /// Return the guard condition options.
  ///
  /// Returned is a pointer to the internally held rcl_guard_condition_options_t.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - guard_condition is `NULL`
  /// - guard_condition is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned pointer is made invalid if the guard condition is finalized.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] guard_condition pointer to the rcl guard_condition
  /// \return rcl guard condition options if successful, otherwise `NULL`
  ffi.Pointer<rcl_guard_condition_options_t> rcl_guard_condition_get_options(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return (_rcl_guard_condition_get_options ??= _dylib.lookupFunction<
            _c_rcl_guard_condition_get_options,
            _dart_rcl_guard_condition_get_options>(
        'rcl_guard_condition_get_options'))(
      guard_condition,
    );
  }

  _dart_rcl_guard_condition_get_options? _rcl_guard_condition_get_options;

  /// /// Return the rmw guard condition handle.
  ///
  /// The handle returned is a pointer to the internally held rmw handle.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - guard_condition is `NULL`
  /// - guard_condition is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned handle is made invalid if the guard condition is finalized or
  /// if rcl_shutdown() is called.
  /// The returned handle is not guaranteed to be valid for the life time of the
  /// guard condition as it may be finalized and recreated itself.
  /// Therefore it is recommended to get the handle from the guard condition using
  /// this function each time it is needed and avoid use of the handle
  /// concurrently with functions that might change it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] guard_condition pointer to the rcl guard_condition
  /// \return rmw guard condition handle if successful, otherwise `NULL`
  ffi.Pointer<rmw_guard_condition_t> rcl_guard_condition_get_rmw_handle(
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ) {
    return (_rcl_guard_condition_get_rmw_handle ??= _dylib.lookupFunction<
            _c_rcl_guard_condition_get_rmw_handle,
            _dart_rcl_guard_condition_get_rmw_handle>(
        'rcl_guard_condition_get_rmw_handle'))(
      guard_condition,
    );
  }

  _dart_rcl_guard_condition_get_rmw_handle? _rcl_guard_condition_get_rmw_handle;

  /// /// Return a rcl_service_t struct with members set to `NULL`.
  ///
  /// Should be called to get a null rcl_service_t before passing to
  /// rcl_service_init().
  rcl_service_t rcl_get_zero_initialized_service() {
    return (_rcl_get_zero_initialized_service ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_service,
            _dart_rcl_get_zero_initialized_service>(
        'rcl_get_zero_initialized_service'))();
  }

  _dart_rcl_get_zero_initialized_service? _rcl_get_zero_initialized_service;

  /// /// Initialize a rcl service.
  ///
  /// After calling this function on a rcl_service_t, it can be used to take
  /// requests of the given type to the given topic using rcl_take_request().
  /// It can also send a response to a request using rcl_send_response().
  ///
  /// The given rcl_node_t must be valid and the resulting rcl_service_t is
  /// only valid as long as the given rcl_node_t remains valid.
  ///
  /// The rosidl_service_type_support_t is obtained on a per .srv type basis.
  /// When the user defines a ROS service, code is generated which provides the
  /// required rosidl_service_type_support_t object.
  /// This object can be obtained using a language appropriate mechanism.
  /// \todo TODO(wjwwood) write these instructions once and link to it instead
  ///
  /// For C, a macro can be used (for example `example_interfaces/AddTwoInts`):
  ///
  /// ```c
  /// #include <rosidl_runtime_c/service_type_support_struct.h>
  /// #include <example_interfaces/srv/add_two_ints.h>
  /// const rosidl_service_type_support_t * ts =
  /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  /// ```
  ///
  /// For C++, a template function is used:
  ///
  /// ```cpp
  /// #include <rosidl_runtime_cpp/service_type_support.hpp>
  /// #include <example_interfaces/srv/add_two_ints.h>
  /// using rosidl_typesupport_cpp::get_service_type_support_handle;
  /// const rosidl_service_type_support_t * ts =
  /// get_service_type_support_handle<example_interfaces::srv::AddTwoInts>();
  /// ```
  ///
  /// The rosidl_service_type_support_t object contains service type specific
  /// information used to send or take requests and responses.
  ///
  /// The topic name must be a c string which follows the topic and service name
  /// format rules for unexpanded names, also known as non-fully qualified names:
  ///
  /// \see rcl_expand_topic_name
  ///
  /// The options struct allows the user to set the quality of service settings as
  /// well as a custom allocator which is used when initializing/finalizing the
  /// client to allocate space for incidentals, e.g. the service name string.
  ///
  /// Expected usage (for C services):
  ///
  /// ```c
  /// #include <rcl/rcl.h>
  /// #include <rosidl_runtime_c/service_type_support_struct.h>
  /// #include <example_interfaces/srv/add_two_ints.h>
  ///
  /// rcl_node_t node = rcl_get_zero_initialized_node();
  /// rcl_node_options_t node_ops = rcl_node_get_default_options();
  /// rcl_ret_t ret = rcl_node_init(&node, "node_name", "/my_namespace", &node_ops);
  /// // ... error handling
  /// const rosidl_service_type_support_t * ts =
  /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
  /// rcl_service_t service = rcl_get_zero_initialized_service();
  /// rcl_service_options_t service_ops = rcl_service_get_default_options();
  /// ret = rcl_service_init(&service, &node, ts, "add_two_ints", &service_ops);
  /// // ... error handling, and on shutdown do finalization:
  /// ret = rcl_service_fini(&service, &node);
  /// // ... error handling for rcl_service_fini()
  /// ret = rcl_node_fini(&node);
  /// // ... error handling for rcl_node_fini()
  /// ```
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[out] service preallocated service structure
  /// \param[in] node valid rcl node handle
  /// \param[in] type_support type support object for the service's type
  /// \param[in] service_name the name of the service
  /// \param[in] options service options, including quality of service settings
  /// \return `RCL_RET_OK` if service was initialized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ALREADY_INIT` if the service is already initialized, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_SERVICE_NAME_INVALID` if the given service name is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_service_init(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rcl_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> service_name,
    ffi.Pointer<rcl_service_options_t> options,
  ) {
    return (_rcl_service_init ??=
        _dylib.lookupFunction<_c_rcl_service_init, _dart_rcl_service_init>(
            'rcl_service_init'))(
      service,
      node,
      type_support,
      service_name,
      options,
    );
  }

  _dart_rcl_service_init? _rcl_service_init;

  /// /// Finalize a rcl_service_t.
  ///
  /// After calling, the node will no longer listen for requests for this service.
  /// (assuming this is the only service of this type in this node).
  ///
  /// After calling, calls to rcl_wait(), rcl_take_request(), and
  /// rcl_send_response() will fail when using this service.
  /// Additionally rcl_wait() will be interrupted if currently blocking.
  /// However, the given node handle is still valid.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] service handle to the service to be deinitialized
  /// \param[in] node a valid (not finalized) handle to the node used to create the service
  /// \return `RCL_RET_OK` if service was deinitialized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SERVICE_INVALID` if the service is invalid, or
  /// \return `RCL_RET_NODE_INVALID` if the node is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_service_fini(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rcl_node_t> node,
  ) {
    return (_rcl_service_fini ??=
        _dylib.lookupFunction<_c_rcl_service_fini, _dart_rcl_service_fini>(
            'rcl_service_fini'))(
      service,
      node,
    );
  }

  _dart_rcl_service_fini? _rcl_service_fini;

  /// /// Return the default service options in a rcl_service_options_t.
  ///
  /// The defaults are:
  ///
  /// - qos = rmw_qos_profile_services_default
  /// - allocator = rcl_get_default_allocator()
  rcl_service_options_t rcl_service_get_default_options() {
    return (_rcl_service_get_default_options ??= _dylib.lookupFunction<
            _c_rcl_service_get_default_options,
            _dart_rcl_service_get_default_options>(
        'rcl_service_get_default_options'))();
  }

  _dart_rcl_service_get_default_options? _rcl_service_get_default_options;

  /// /// Take a pending ROS request using a rcl service.
  ///
  /// It is the job of the caller to ensure that the type of the ros_request
  /// argument and the type associate with the service, via the type
  /// support, match.
  /// Passing a different type to rcl_take produces undefined behavior and cannot
  /// be checked by this function and therefore no deliberate error will occur.
  ///
  /// TODO(jacquelinekay) blocking of take?
  /// TODO(jacquelinekay) pre-, during-, and post-conditions for message ownership?
  /// TODO(jacquelinekay) is rcl_take_request thread-safe?
  /// TODO(jacquelinekay) Should there be an rcl_request_id_t?
  ///
  /// The ros_request pointer should point to an already allocated ROS request message
  /// struct of the correct type, into which the taken ROS request will be copied
  /// if one is available.
  /// If taken is false after calling, then the ROS request will be unmodified.
  ///
  /// If allocation is required when taking the request, e.g. if space needs to
  /// be allocated for a dynamically sized array in the target message, then the
  /// allocator given in the service options is used.
  ///
  /// request_header is a pointer to pre-allocated a rmw struct containing
  /// meta-information about the request (e.g. the sequence number).
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] only if required when filling the request, avoided for fixed sizes</i>
  ///
  /// \param[in] service the handle to the service from which to take
  /// \param[inout] request_header ptr to the struct holding metadata about the request
  /// \param[inout] ros_request type-erased ptr to an allocated ROS request message
  /// \return `RCL_RET_OK` if the request was taken, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SERVICE_INVALID` if the service is invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_SERVICE_TAKE_FAILED` if take failed but no error occurred
  /// in the middleware, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_take_request_with_info(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rmw_service_info_t> request_header,
    ffi.Pointer<ffi.Void> ros_request,
  ) {
    return (_rcl_take_request_with_info ??= _dylib.lookupFunction<
        _c_rcl_take_request_with_info,
        _dart_rcl_take_request_with_info>('rcl_take_request_with_info'))(
      service,
      request_header,
      ros_request,
    );
  }

  _dart_rcl_take_request_with_info? _rcl_take_request_with_info;

  /// /// backwards compatibility version that takes a request_id only
  int rcl_take_request(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_request,
  ) {
    return (_rcl_take_request ??=
        _dylib.lookupFunction<_c_rcl_take_request, _dart_rcl_take_request>(
            'rcl_take_request'))(
      service,
      request_header,
      ros_request,
    );
  }

  _dart_rcl_take_request? _rcl_take_request;

  /// /// Send a ROS response to a client using a service.
  ///
  /// It is the job of the caller to ensure that the type of the `ros_response`
  /// parameter and the type associate with the service (via the type support)
  /// match.
  /// Passing a different type to send_response produces undefined behavior and
  /// cannot be checked by this function and therefore no deliberate error will
  /// occur.
  ///
  /// send_response() is an non-blocking call.
  ///
  /// The ROS response message given by the `ros_response` void pointer is always
  /// owned by the calling code, but should remain constant during
  /// rcl_send_response().
  ///
  /// This function is thread safe so long as access to both the service and the
  /// `ros_response` is synchronized.
  /// That means that calling rcl_send_response() from multiple threads is
  /// allowed, but calling rcl_send_response() at the same time as non-thread safe
  /// service functions is not, e.g. calling rcl_send_response() and
  /// rcl_service_fini() concurrently is not allowed.
  /// Before calling rcl_send_response() the message can change and after calling
  /// rcl_send_response() the message can change, but it cannot be changed during
  /// the rcl_send_response() call.
  /// The same `ros_response`, however, can be passed to multiple calls of
  /// rcl_send_response() simultaneously, even if the services differ.
  /// The `ros_response` is unmodified by rcl_send_response().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  /// <i>[1] for unique pairs of services and responses, see above for more</i>
  ///
  /// \param[in] service handle to the service which will make the response
  /// \param[inout] response_header ptr to the struct holding metadata about the request ID
  /// \param[in] ros_response type-erased pointer to the ROS response message
  /// \return `RCL_RET_OK` if the response was sent successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_SERVICE_INVALID` if the service is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_send_response(
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<rmw_request_id_t> response_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return (_rcl_send_response ??=
        _dylib.lookupFunction<_c_rcl_send_response, _dart_rcl_send_response>(
            'rcl_send_response'))(
      service,
      response_header,
      ros_response,
    );
  }

  _dart_rcl_send_response? _rcl_send_response;

  /// /// Get the topic name for the service.
  ///
  /// This function returns the service's internal topic name string.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - service is `NULL`
  /// - service is invalid (never called init, called fini, or invalid)
  ///
  /// The returned string is only valid as long as the service is valid.
  /// The value of the string may change if the topic name changes, and therefore
  /// copying the string is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] service the pointer to the service
  /// \return name string if successful, otherwise `NULL`
  ffi.Pointer<ffi.Int8> rcl_service_get_service_name(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return (_rcl_service_get_service_name ??= _dylib.lookupFunction<
        _c_rcl_service_get_service_name,
        _dart_rcl_service_get_service_name>('rcl_service_get_service_name'))(
      service,
    );
  }

  _dart_rcl_service_get_service_name? _rcl_service_get_service_name;

  /// /// Return the rcl service options.
  ///
  /// This function returns the service's internal options struct.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - service is `NULL`
  /// - service is invalid (never called init, called fini, or invalid)
  ///
  /// The returned struct is only valid as long as the service is valid.
  /// The values in the struct may change if the service's options change,
  /// and therefore copying the struct is recommended if this is a concern.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] service pointer to the service
  /// \return options struct if successful, otherwise `NULL`
  ffi.Pointer<rcl_service_options_t> rcl_service_get_options(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return (_rcl_service_get_options ??= _dylib.lookupFunction<
        _c_rcl_service_get_options,
        _dart_rcl_service_get_options>('rcl_service_get_options'))(
      service,
    );
  }

  _dart_rcl_service_get_options? _rcl_service_get_options;

  /// /// Return the rmw service handle.
  ///
  /// The handle returned is a pointer to the internally held rmw handle.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - service is `NULL`
  /// - service is invalid (never called init, called fini, or invalid)
  ///
  /// The returned handle is made invalid if the service is finalized or if
  /// rcl_shutdown() is called.
  /// The returned handle is not guaranteed to be valid for the life time of the
  /// service as it may be finalized and recreated itself.
  /// Therefore it is recommended to get the handle from the service using
  /// this function each time it is needed and avoid use of the handle
  /// concurrently with functions that might change it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] service pointer to the rcl service
  /// \return rmw service handle if successful, otherwise `NULL`
  ffi.Pointer<rmw_service_t> rcl_service_get_rmw_handle(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return (_rcl_service_get_rmw_handle ??= _dylib.lookupFunction<
        _c_rcl_service_get_rmw_handle,
        _dart_rcl_service_get_rmw_handle>('rcl_service_get_rmw_handle'))(
      service,
    );
  }

  _dart_rcl_service_get_rmw_handle? _rcl_service_get_rmw_handle;

  /// /// Check that the service is valid.
  ///
  /// The bool returned is `false` if `service` is invalid.
  /// The bool returned is `true` otherwise.
  /// In the case where `false` is to be returned, an error message is set.
  /// This function cannot fail.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] service pointer to the rcl service
  /// \return `true` if `service` is valid, otherwise `false`
  bool rcl_service_is_valid(
    ffi.Pointer<rcl_service_t> service,
  ) {
    return (_rcl_service_is_valid ??= _dylib.lookupFunction<
            _c_rcl_service_is_valid,
            _dart_rcl_service_is_valid>('rcl_service_is_valid'))(
          service,
        ) !=
        0;
  }

  _dart_rcl_service_is_valid? _rcl_service_is_valid;

  /// /// Check if the clock has valid values.
  ///
  /// This function returns true if the time source appears to be valid.
  /// It will check that the type is not uninitialized, and that pointers
  /// are not invalid.
  /// Note that if data is uninitialized it may give a false positive.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] clock the handle to the clock which is being queried
  /// \return true if the source is believed to be valid, otherwise return false.
  bool rcl_clock_valid(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return (_rcl_clock_valid ??=
            _dylib.lookupFunction<_c_rcl_clock_valid, _dart_rcl_clock_valid>(
                'rcl_clock_valid'))(
          clock,
        ) !=
        0;
  }

  _dart_rcl_clock_valid? _rcl_clock_valid;

  /// /// Initialize a clock based on the passed type.
  ///
  /// This will allocate all necessary internal structures, and initialize variables.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes [1]
  /// Thread-Safe        | No [2]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] If `clock_type` is `RCL_ROS_TIME`</i>
  /// <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object.</i>
  ///
  /// \param[in] clock_type the type identifying the time source to provide
  /// \param[in] clock the handle to the clock which is being initialized
  /// \param[in] allocator The allocator to use for allocations
  /// \return `RCL_RET_OK` if the time source was successfully initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_clock_init(
    int clock_type,
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcl_clock_init ??=
        _dylib.lookupFunction<_c_rcl_clock_init, _dart_rcl_clock_init>(
            'rcl_clock_init'))(
      clock_type,
      clock,
      allocator,
    );
  }

  _dart_rcl_clock_init? _rcl_clock_init;

  /// /// Finalize a clock.
  ///
  /// This will deallocate all necessary internal structures, and clean up any variables.
  /// It can be combined with any of the init functions.
  ///
  /// Passing a clock with type RCL_CLOCK_UNINITIALIZED will result in
  /// RCL_RET_INVALID_ARGUMENT being returned.
  ///
  /// This function is not thread-safe with any other function operating on the same
  /// clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object associated with the
  /// `clock` object.</i>
  ///
  /// \param[in] clock the handle to the clock which is being finalized
  /// \return `RCL_RET_OK` if the time source was successfully finalized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return (_rcl_clock_fini ??=
        _dylib.lookupFunction<_c_rcl_clock_fini, _dart_rcl_clock_fini>(
            'rcl_clock_fini'))(
      clock,
    );
  }

  _dart_rcl_clock_fini? _rcl_clock_fini;

  /// /// Initialize a clock as a RCL_ROS_TIME time source.
  ///
  /// This will allocate all necessary internal structures, and initialize variables.
  /// It is specifically setting up a RCL_ROS_TIME time source.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object.</i>
  ///
  /// \param[in] clock the handle to the clock which is being initialized
  /// \param[in] allocator The allocator to use for allocations
  /// \return `RCL_RET_OK` if the time source was successfully initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_ros_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcl_ros_clock_init ??=
        _dylib.lookupFunction<_c_rcl_ros_clock_init, _dart_rcl_ros_clock_init>(
            'rcl_ros_clock_init'))(
      clock,
      allocator,
    );
  }

  _dart_rcl_ros_clock_init? _rcl_ros_clock_init;

  /// /// Finalize a clock as a `RCL_ROS_TIME` time source.
  ///
  /// This will deallocate all necessary internal structures, and clean up any variables.
  /// It is specifically setting up a `RCL_ROS_TIME` time source. It is expected
  /// to be paired with the init fuction.
  ///
  /// This function is not thread-safe with any other function operating on the same
  /// clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object associated with the
  /// `clock` object.</i>
  ///
  /// \param[in] clock the handle to the clock which is being initialized
  /// \return `RCL_RET_OK` if the time source was successfully finalized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_ros_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return (_rcl_ros_clock_fini ??=
        _dylib.lookupFunction<_c_rcl_ros_clock_fini, _dart_rcl_ros_clock_fini>(
            'rcl_ros_clock_fini'))(
      clock,
    );
  }

  _dart_rcl_ros_clock_fini? _rcl_ros_clock_fini;

  /// /// Initialize a clock as a `RCL_STEADY_TIME` time source.
  ///
  /// This will allocate all necessary internal structures, and initialize variables.
  /// It is specifically setting up a `RCL_STEADY_TIME` time source.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object.</i>
  ///
  /// \param[in] clock the handle to the clock which is being initialized
  /// \param[in] allocator The allocator to use for allocations
  /// \return `RCL_RET_OK` if the time source was successfully initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_steady_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcl_steady_clock_init ??= _dylib.lookupFunction<
        _c_rcl_steady_clock_init,
        _dart_rcl_steady_clock_init>('rcl_steady_clock_init'))(
      clock,
      allocator,
    );
  }

  _dart_rcl_steady_clock_init? _rcl_steady_clock_init;

  /// /// Finalize a clock as a `RCL_STEADY_TIME` time source.
  ///
  /// Finalize the clock as a `RCL_STEADY_TIME` time source.
  ///
  /// This will deallocate all necessary internal structures, and clean up any variables.
  /// It is specifically setting up a steady time source. It is expected to be
  /// paired with the init fuction.
  ///
  /// This function is not thread-safe with any other function operating on the same
  /// clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object associated with the
  /// `clock` object.</i>
  ///
  /// \param[in] clock the handle to the clock which is being initialized
  /// \return `RCL_RET_OK` if the time source was successfully finalized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_steady_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return (_rcl_steady_clock_fini ??= _dylib.lookupFunction<
        _c_rcl_steady_clock_fini,
        _dart_rcl_steady_clock_fini>('rcl_steady_clock_fini'))(
      clock,
    );
  }

  _dart_rcl_steady_clock_fini? _rcl_steady_clock_fini;

  /// /// Initialize a clock as a `RCL_SYSTEM_TIME` time source.
  ///
  /// Initialize the clock as a `RCL_SYSTEM_TIME` time source.
  ///
  /// This will allocate all necessary internal structures, and initialize variables.
  /// It is specifically setting up a system time source.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object associated with the
  /// `clock` object.</i>
  ///
  /// \param[in] clock the handle to the clock which is being initialized
  /// \param[in] allocator The allocator to use for allocations
  /// \return `RCL_RET_OK` if the time source was successfully initialized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_system_clock_init(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcl_system_clock_init ??= _dylib.lookupFunction<
        _c_rcl_system_clock_init,
        _dart_rcl_system_clock_init>('rcl_system_clock_init'))(
      clock,
      allocator,
    );
  }

  _dart_rcl_system_clock_init? _rcl_system_clock_init;

  /// /// Finalize a clock as a `RCL_SYSTEM_TIME` time source.
  ///
  /// Finalize the clock as a `RCL_SYSTEM_TIME` time source.
  ///
  /// This will deallocate all necessary internal structures, and clean up any variables.
  /// It is specifically setting up a system time source. It is expected to be paired with
  /// the init fuction.
  ///
  /// This function is not thread-safe with any function operating on the same clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object associated with the
  /// `clock` object.</i>
  ///
  /// \param[in] clock the handle to the clock which is being initialized.
  /// \return `RCL_RET_OK` if the time source was successfully finalized, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_system_clock_fini(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return (_rcl_system_clock_fini ??= _dylib.lookupFunction<
        _c_rcl_system_clock_fini,
        _dart_rcl_system_clock_fini>('rcl_system_clock_fini'))(
      clock,
    );
  }

  _dart_rcl_system_clock_fini? _rcl_system_clock_fini;

  /// /// Compute the difference between two time points
  ///
  /// This function takes two time points and computes the duration between them.
  /// The two time points must be using the same time abstraction, and the
  /// resultant duration will also be of the same abstraction.
  ///
  /// The value will be computed as duration = finish - start. If start is after
  /// finish the duration will be negative.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] start The time point for the start of the duration.
  /// \param[in] finish The time point for the end of the duration.
  /// \param[out] delta The duration between the start and finish.
  /// \return `RCL_RET_OK` if the difference was computed successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_difference_times(
    ffi.Pointer<rcl_time_point_t> start,
    ffi.Pointer<rcl_time_point_t> finish,
    ffi.Pointer<rcl_duration_t> delta,
  ) {
    return (_rcl_difference_times ??= _dylib.lookupFunction<
        _c_rcl_difference_times,
        _dart_rcl_difference_times>('rcl_difference_times'))(
      start,
      finish,
      delta,
    );
  }

  _dart_rcl_difference_times? _rcl_difference_times;

  /// /// Fill the time point value with the current value of the associated clock.
  ///
  /// This function will populate the data of the time_point_value object with the
  /// current value from it's associated time abstraction.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes [1]
  /// Lock-Free          | Yes
  ///
  /// <i>[1] If `clock` is of `RCL_ROS_TIME` type.</i>
  ///
  /// \param[in] clock The time source from which to set the value.
  /// \param[out] time_point_value The time_point value to populate.
  /// \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_clock_get_now(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<ffi.Int64> time_point_value,
  ) {
    return (_rcl_clock_get_now ??=
        _dylib.lookupFunction<_c_rcl_clock_get_now, _dart_rcl_clock_get_now>(
            'rcl_clock_get_now'))(
      clock,
      time_point_value,
    );
  }

  _dart_rcl_clock_get_now? _rcl_clock_get_now;

  /// /// Enable the ROS time abstraction override.
  ///
  /// This method will enable the ROS time abstraction override values,
  /// such that the time source will report the set value instead of falling
  /// back to system time.
  ///
  /// This function is not thread-safe with `rcl_clock_add_jump_callback`,
  /// nor `rcl_clock_remove_jump_callback` functions when used on the same
  /// clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence [1]
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [2]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>
  /// <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>
  ///
  /// \param[in] clock The clock to enable.
  /// \return `RCL_RET_OK` if the time source was enabled successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_enable_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return (_rcl_enable_ros_time_override ??= _dylib.lookupFunction<
        _c_rcl_enable_ros_time_override,
        _dart_rcl_enable_ros_time_override>('rcl_enable_ros_time_override'))(
      clock,
    );
  }

  _dart_rcl_enable_ros_time_override? _rcl_enable_ros_time_override;

  /// /// Disable the ROS time abstraction override.
  ///
  /// This method will disable the `RCL_ROS_TIME` time abstraction override values,
  /// such that the time source will report the system time even if a custom
  /// value has been set.
  ///
  /// This function is not thread-safe with `rcl_clock_add_jump_callback`,
  /// nor `rcl_clock_remove_jump_callback` functions when used on the same
  /// clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence [1]
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [2]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>
  /// <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>
  ///
  /// \param[in] clock The clock to disable.
  /// \return `RCL_RET_OK` if the time source was disabled successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_disable_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
  ) {
    return (_rcl_disable_ros_time_override ??= _dylib.lookupFunction<
        _c_rcl_disable_ros_time_override,
        _dart_rcl_disable_ros_time_override>('rcl_disable_ros_time_override'))(
      clock,
    );
  }

  _dart_rcl_disable_ros_time_override? _rcl_disable_ros_time_override;

  /// /// Check if the `RCL_ROS_TIME` time source has the override enabled.
  ///
  /// This will populate the is_enabled object to indicate if the
  /// time overide is enabled. If it is enabled, the set value will be returned.
  /// Otherwise this time source will return the equivalent to system time abstraction.
  ///
  /// This function is not thread-safe with `rcl_enable_ros_time_override` nor
  /// `rcl_disable_ros_time_override` functions when used on the same clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>
  ///
  /// \param[in] clock The clock to query.
  /// \param[out] is_enabled Whether the override is enabled..
  /// \return `RCL_RET_OK` if the time source was queried successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_is_enabled_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<ffi.Uint8> is_enabled,
  ) {
    return (_rcl_is_enabled_ros_time_override ??= _dylib.lookupFunction<
            _c_rcl_is_enabled_ros_time_override,
            _dart_rcl_is_enabled_ros_time_override>(
        'rcl_is_enabled_ros_time_override'))(
      clock,
      is_enabled,
    );
  }

  _dart_rcl_is_enabled_ros_time_override? _rcl_is_enabled_ros_time_override;

  /// /// Set the current time for this `RCL_ROS_TIME` time source.
  ///
  /// This function will update the internal storage for the `RCL_ROS_TIME`
  /// time source.
  /// If queried and override enabled the time source will return this value,
  /// otherwise it will return the system time.
  ///
  /// This function is not thread-safe with `rcl_clock_add_jump_callback`,
  /// nor `rcl_clock_remove_jump_callback` functions when used on the same
  /// clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence [1]
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No [2]
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Only applies to the function itself, as jump callbacks may not abide to it.</i>
  /// <i>[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.</i>
  ///
  /// \param[in] clock The clock to update.
  /// \param[in] time_value The new current time.
  /// \return `RCL_RET_OK` if the time source was set successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_set_ros_time_override(
    ffi.Pointer<rcl_clock_t> clock,
    int time_value,
  ) {
    return (_rcl_set_ros_time_override ??= _dylib.lookupFunction<
        _c_rcl_set_ros_time_override,
        _dart_rcl_set_ros_time_override>('rcl_set_ros_time_override'))(
      clock,
      time_value,
    );
  }

  _dart_rcl_set_ros_time_override? _rcl_set_ros_time_override;

  /// /// Add a callback to be called when a time jump exceeds a threshold.
  ///
  /// The callback is called twice when the threshold is exceeded: once before the clock is
  /// updated, and once after.
  /// The user_data pointer is passed to the callback as the last argument.
  /// A callback and user_data pair must be unique among the callbacks added to a clock.
  ///
  /// This function is not thread-safe with `rcl_clock_remove_jump_callback`,
  /// `rcl_enable_ros_time_override`, `rcl_disable_ros_time_override` nor
  /// `rcl_set_ros_time_override` functions when used on the same clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object associated with the
  /// `clock` object.</i>
  ///
  /// \param[in] clock A clock to add a jump callback to.
  /// \param[in] threshold Criteria indicating when to call the callback.
  /// \param[in] callback A callback to call.
  /// \param[in] user_data A pointer to be passed to the callback.
  /// \return `RCL_RET_OK` if the callback was added successfully, or
  /// \return `RCL_RET_BAD_ALLOC` if a memory allocation failed, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occurs.
  int rcl_clock_add_jump_callback(
    ffi.Pointer<rcl_clock_t> clock,
    rcl_jump_threshold_t threshold,
    ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return (_rcl_clock_add_jump_callback ??= _dylib.lookupFunction<
        _c_rcl_clock_add_jump_callback,
        _dart_rcl_clock_add_jump_callback>('rcl_clock_add_jump_callback'))(
      clock,
      threshold,
      callback,
      user_data,
    );
  }

  _dart_rcl_clock_add_jump_callback? _rcl_clock_add_jump_callback;

  /// /// Remove a previously added time jump callback.
  ///
  /// This function is not thread-safe with `rcl_clock_add_jump_callback`
  /// `rcl_enable_ros_time_override`, `rcl_disable_ros_time_override` nor
  /// `rcl_set_ros_time_override` functions when used on the same clock object.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No [1]
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// <i>[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
  /// Thread-safety is also affected by that of the `allocator` object associated with the
  /// `clock` object.</i>
  ///
  /// \param[in] clock The clock to remove a jump callback from.
  /// \param[in] callback The callback to call.
  /// \param[in] user_data A pointer to be passed to the callback.
  /// \return `RCL_RET_OK` if the callback was added successfully, or
  /// \return `RCL_RET_BAD_ALLOC` if a memory allocation failed, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` the callback was not found or an unspecified error occurs.
  int rcl_clock_remove_jump_callback(
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return (_rcl_clock_remove_jump_callback ??= _dylib.lookupFunction<
            _c_rcl_clock_remove_jump_callback,
            _dart_rcl_clock_remove_jump_callback>(
        'rcl_clock_remove_jump_callback'))(
      clock,
      callback,
      user_data,
    );
  }

  _dart_rcl_clock_remove_jump_callback? _rcl_clock_remove_jump_callback;

  /// /// Get the message bounds handle specific to this identifier.
  ///
  /// The handle's sequence bound is simply returned or if the parameters are NULL then an assert
  /// will happen.
  ///
  /// \param handle Handle to service type support
  /// \param identifier The identifier to get the handle for
  /// \return The associated sequence bound handle function.
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> get_sequence_bound_handle(
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return (_get_sequence_bound_handle ??= _dylib.lookupFunction<
        _c_get_sequence_bound_handle,
        _dart_get_sequence_bound_handle>('get_sequence_bound_handle'))(
      handle,
      identifier,
    );
  }

  _dart_get_sequence_bound_handle? _get_sequence_bound_handle;

  /// /// Get the message bounds handle function specific to this identifier.
  ///
  /// If the identifier is the same as this handle function's identifier the handle is simply returned
  /// or if the parameters are NULL then an assert will happen.
  ///
  /// \param handle Handle to service type support
  /// \param identifier The identifier to get the handle function for
  /// \return if the identifier match's the handle's identifier then the handle's function
  /// is returned.
  ffi.Pointer<rosidl_runtime_c__Sequence__bound>
      get_sequence_bound_handle_function(
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> handle,
    ffi.Pointer<ffi.Int8> identifier,
  ) {
    return (_get_sequence_bound_handle_function ??= _dylib.lookupFunction<
            _c_get_sequence_bound_handle_function,
            _dart_get_sequence_bound_handle_function>(
        'get_sequence_bound_handle_function'))(
      handle,
      identifier,
    );
  }

  _dart_get_sequence_bound_handle_function? _get_sequence_bound_handle_function;

  /// /// Return a rmw_subscription_options_t initialized with default values.
  rmw_subscription_options_t rmw_get_default_subscription_options() {
    return (_rmw_get_default_subscription_options ??= _dylib.lookupFunction<
            _c_rmw_get_default_subscription_options,
            _dart_rmw_get_default_subscription_options>(
        'rmw_get_default_subscription_options'))();
  }

  _dart_rmw_get_default_subscription_options?
      _rmw_get_default_subscription_options;

  /// /// Get the name of the rmw implementation being used
  ///
  /// \return Name of rmw implementation
  ffi.Pointer<ffi.Int8> rmw_get_implementation_identifier() {
    return (_rmw_get_implementation_identifier ??= _dylib.lookupFunction<
            _c_rmw_get_implementation_identifier,
            _dart_rmw_get_implementation_identifier>(
        'rmw_get_implementation_identifier'))();
  }

  _dart_rmw_get_implementation_identifier? _rmw_get_implementation_identifier;

  /// /// Get the unique serialization format for this middleware.
  ///
  /// Return the format in which binary data is serialized.
  /// One middleware can only have one encoding.
  /// In contrast to the implementation identifier, the serialization format can be equal between
  /// multiple RMW implementations.
  /// This means, that the same binary messages can be deserialized by RMW implementations with the
  /// same format.
  /// \sa rmw_serialize
  /// \sa rmw_deserialize
  /// \return serialization format
  ffi.Pointer<ffi.Int8> rmw_get_serialization_format() {
    return (_rmw_get_serialization_format ??= _dylib.lookupFunction<
        _c_rmw_get_serialization_format,
        _dart_rmw_get_serialization_format>('rmw_get_serialization_format'))();
  }

  _dart_rmw_get_serialization_format? _rmw_get_serialization_format;

  /// /// Create a node and return a handle to that node.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - name is not a valid non-null node name
  /// - namespace_ is not a valid non-null namespace
  /// - context is not valid i.e. it is zero-initialized, or
  /// its implementation identifier does not match that of
  /// this API implementation, or has been invalidated by
  /// `rmw_shutdown()`
  /// - memory allocation fails during node creation
  /// - an unspecified error occurs
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No [1]
  /// Lock-Free          | No [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// This should be defined by the rmw implementation.
  ///
  /// \param[in] context init context that this node should be associated with
  /// \param[in] name the node name
  /// \param[in] namespace_ the node namespace
  /// \return rmw node handle, or `NULL` if there was an error
  ffi.Pointer<rmw_node_t> rmw_create_node(
    ffi.Pointer<rmw_context_t> context,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> namespace_,
    int domain_id,
    bool localhost_only,
  ) {
    return (_rmw_create_node ??=
        _dylib.lookupFunction<_c_rmw_create_node, _dart_rmw_create_node>(
            'rmw_create_node'))(
      context,
      name,
      namespace_,
      domain_id,
      localhost_only ? 1 : 0,
    );
  }

  _dart_rmw_create_node? _rmw_create_node;

  /// /// Finalize a given node handle, reclaim the resources, and deallocate the node handle.
  ///
  /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given node handle unchanged.
  /// Otherwise, it will proceed despite errors, freeing as many resources as it can, including
  /// the node handle. Usage of a deallocated node handle is undefined behavior.
  ///
  /// \pre All publishers, subscribers, services, and clients created from this node must
  /// have been destroyed prior to this call. Some rmw implementations may verify this,
  /// returning `RMW_RET_ERROR` and setting a human readable error message if any entity
  /// created from this node has not yet been destroyed. However, this is not guaranteed
  /// and so callers should ensure that this is the case before calling this function.
  ///
  /// \param[in] node the node handle to be destroyed
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if node is invalid, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  /// identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_destroy_node(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return (_rmw_destroy_node ??=
        _dylib.lookupFunction<_c_rmw_destroy_node, _dart_rmw_destroy_node>(
            'rmw_destroy_node'))(
      node,
    );
  }

  _dart_rmw_destroy_node? _rmw_destroy_node;

  int rmw_node_assert_liveliness(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return (_rmw_node_assert_liveliness ??= _dylib.lookupFunction<
        _c_rmw_node_assert_liveliness,
        _dart_rmw_node_assert_liveliness>('rmw_node_assert_liveliness'))(
      node,
    );
  }

  _dart_rmw_node_assert_liveliness? _rmw_node_assert_liveliness;

  /// /// Return a guard condition which is triggered when the ROS graph changes.
  ///
  /// The guard condition will be triggered anytime a change to the ROS graph occurs.
  /// A ROS graph change occurs whenever:
  /// - A node joins or leaves the ROS graph.
  /// This change will be reflected in rmw_get_node_names() and
  /// rmw_get_node_names_with_enclaves() outcome.
  /// - A topic subscription joins or leaves the ROS graph.
  /// This change will be reflected in rmw_get_topic_names_and_types(),
  /// rmw_get_subscriber_names_and_types_by_node(), and
  /// rmw_get_subscriptions_info_by_topic() outcome.
  /// - A topic publisher joins or leaves the ROS graph.
  /// This change will be reflected in rmw_get_topic_names_and_types(),
  /// rmw_get_publisher_names_and_types_by_node(), and
  /// rmw_get_publishers_info_by_topic() outcome.
  /// - A topic subscription matches a topic publisher with compatible QoS policies.
  /// This change will be reflected in rmw_subscription_count_matched_publishers() outcome.
  /// - A topic publisher matches a topic subscription with compatible QoS policies.
  /// This change will be reflected in rmw_publisher_count_matched_subscriptions() outcome.
  /// - A service server joins or leaves the ROS graph.
  /// This change will be reflected in rmw_get_service_names_and_types() and
  /// rmw_get_service_names_and_types_by_node() outcome.
  /// - A service client joins or leaves the ROS graph.
  /// This change will be reflected in rmw_get_service_names_and_types() and
  /// rmw_get_client_names_and_types_by_node() outcome.
  /// - A service client matches a service server with compatible QoS policies.
  /// This change will be reflected in rmw_service_server_is_available() outcome.
  ///
  /// \note The state of the ROS graph, and any changes that may take place,
  /// are reported as seen by the associated `node`.
  ///
  /// The guard condition is owned and internally held by the `node`.
  /// It will be invalidated if `node` is finalized using rmw_destroy_node().
  /// It is undefined behavior to use an invalidated guard condition.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  ///
  /// \param[in] node Node to retrieve the guard condition from.
  /// \return Guard condition if successful, or `NULL` if
  /// `node` is `NULL`, or an unspecified error occurs.
  ffi.Pointer<rmw_guard_condition_t> rmw_node_get_graph_guard_condition(
    ffi.Pointer<rmw_node_t> node,
  ) {
    return (_rmw_node_get_graph_guard_condition ??= _dylib.lookupFunction<
            _c_rmw_node_get_graph_guard_condition,
            _dart_rmw_node_get_graph_guard_condition>(
        'rmw_node_get_graph_guard_condition'))(
      node,
    );
  }

  _dart_rmw_node_get_graph_guard_condition? _rmw_node_get_graph_guard_condition;

  /// /// Initialize a publisher allocation to be used with later publications.
  ///
  /// This creates an allocation object that can be used in conjunction with
  /// the rmw_publish method to perform more carefully control memory allocations.
  ///
  /// This will allow the middleware to preallocate the correct amount of memory
  /// for a given message type and message bounds.
  /// As allocation is performed in this method, it will not be necessary to allocate
  /// in the `rmw_publish` method.
  ///
  /// \param[in] type_support Type support of the message to be preallocated.
  /// \param[in] message_bounds Bounds structure of the message to be preallocated.
  /// \param[out] allocation Allocation structure to be passed to `rmw_publish`.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_UNSUPPORTED` if it's unimplemented
  /// \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_init_publisher_allocation(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return (_rmw_init_publisher_allocation ??= _dylib.lookupFunction<
        _c_rmw_init_publisher_allocation,
        _dart_rmw_init_publisher_allocation>('rmw_init_publisher_allocation'))(
      type_support,
      message_bounds,
      allocation,
    );
  }

  _dart_rmw_init_publisher_allocation? _rmw_init_publisher_allocation;

  /// /// Destroy a publisher allocation object.
  ///
  /// This deallocates any memory allocated by `rmw_init_publisher_allocation`.
  ///
  /// \param[in] allocation Allocation object to be destroyed.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_UNSUPPORTED` if it's unimplemented
  /// \return `RMW_RET_INVALID_ARGUMENT` if argument is null, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_fini_publisher_allocation(
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return (_rmw_fini_publisher_allocation ??= _dylib.lookupFunction<
        _c_rmw_fini_publisher_allocation,
        _dart_rmw_fini_publisher_allocation>('rmw_fini_publisher_allocation'))(
      allocation,
    );
  }

  _dart_rmw_fini_publisher_allocation? _rmw_fini_publisher_allocation;

  /// /// Return a rmw_publisher_options_t initialized with default values.
  rmw_publisher_options_t rmw_get_default_publisher_options() {
    return (_rmw_get_default_publisher_options ??= _dylib.lookupFunction<
            _c_rmw_get_default_publisher_options,
            _dart_rmw_get_default_publisher_options>(
        'rmw_get_default_publisher_options'))();
  }

  _dart_rmw_get_default_publisher_options? _rmw_get_default_publisher_options;

  /// /// Create a publisher and return a handle to that publisher.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is not a valid non-null handle for this rmw implementation,
  /// as returned by `rmw_create_node()`
  /// - type_support is a not valid non-null message type support, as returned by
  /// `ROSIDL_GET_MSG_TYPE_SUPPORT()`
  /// - topic_name is not a valid non-null topic name, according to
  /// `rmw_validate_full_topic_name()`
  /// - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies
  /// - publisher_options is not a valid non-null option set, as returned by
  /// `rmw_get_default_publisher_options()`
  /// - memory allocation fails during publisher creation
  /// - an unspecified error occurs
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] node Handle to node with which to register this publisher
  /// \param[in] type_support Type support for the messages to be published
  /// \param[in] topic_name Name of the topic to publish to, often a fully qualified
  /// topic name unless `qos_profile` is configured to avoid ROS namespace conventions
  /// i.e. to create a native topic publisher
  /// \param[in] qos_profile QoS policies for this publisher
  /// \param[in] publisher_options Options to configure this publisher
  /// \return rmw publisher handle, or `NULL` if there was an error
  ffi.Pointer<rmw_publisher_t> rmw_create_publisher(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<rmw_qos_profile_t> qos_profile,
    ffi.Pointer<rmw_publisher_options_t> publisher_options,
  ) {
    return (_rmw_create_publisher ??= _dylib.lookupFunction<
        _c_rmw_create_publisher,
        _dart_rmw_create_publisher>('rmw_create_publisher'))(
      node,
      type_support,
      topic_name,
      qos_profile,
      publisher_options,
    );
  }

  _dart_rmw_create_publisher? _rmw_create_publisher;

  /// /// Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle.
  ///
  /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given publisher handle unchanged.
  /// Otherwise, it will proceed despite errors, freeing as many resources as it can, including
  /// the publisher handle. Usage of a deallocated publisher handle is undefined behavior.
  ///
  /// \pre Given node must be the one the publisher was registered with.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] node Handle to node with which the given publisher is registered
  /// \param[in] publisher Handle to publisher to be finalized
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if node or publisher is `NULL`, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or publisher
  /// implementation identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_destroy_publisher(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_publisher_t> publisher,
  ) {
    return (_rmw_destroy_publisher ??= _dylib.lookupFunction<
        _c_rmw_destroy_publisher,
        _dart_rmw_destroy_publisher>('rmw_destroy_publisher'))(
      node,
      publisher,
    );
  }

  _dart_rmw_destroy_publisher? _rmw_destroy_publisher;

  /// /// Borrow a loaned ROS message.
  ///
  /// This ROS message is owned by the middleware, that will keep it alive (i.e. in valid
  /// memory space) until the caller publishes it using rmw_publish_loaned_message() or
  /// returns it using rmw_return_loaned_message_from_publisher().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To borrow a ROS message is a synchronous operation.
  /// It is also non-blocking, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on borrow or not.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when using ROS message loaning support.
  ///
  /// \par Thread-safety
  /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is safe to borrow ROS messages from the same publisher concurrently.
  ///
  /// \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  /// \pre Given `type_support` must be a valid `rosidl` message type support, matching the
  /// one registered with the `publisher` on creation.
  ///
  /// \param[in] publisher Publisher to which the loaned ROS message will be associated.
  /// \param[in] type_support Message type support of the loaned ROS message.
  /// \param[out] ros_message Pointer to type erased ROS message loaned by the middleware.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `type_support` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `*ros_message` is not NULL (to prevent leaks), or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier
  /// does not match this implementation, or
  /// \return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or
  /// \return `RMW_RET_ERROR` if an unexpected error occured.
  int rmw_borrow_loaned_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
  ) {
    return (_rmw_borrow_loaned_message ??= _dylib.lookupFunction<
        _c_rmw_borrow_loaned_message,
        _dart_rmw_borrow_loaned_message>('rmw_borrow_loaned_message'))(
      publisher,
      type_support,
      ros_message,
    );
  }

  _dart_rmw_borrow_loaned_message? _rmw_borrow_loaned_message;

  /// /// Return a loaned message previously borrowed from a publisher.
  ///
  /// Tells the middleware that a borrowed ROS message is no longer needed by the caller.
  /// Ownership of the ROS message is given back to the middleware.
  /// If this function fails early due to a logical error, such as an invalid argument,
  /// the loaned ROS message will be left unchanged.
  /// Otherwise, ownership of the ROS message will be given back to the middleware.
  /// It is up to the middleware what will be made of the returned ROS message.
  /// It is undefined behavior to use a loaned ROS message after returning it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To return a ROS message is a synchronous operation.
  /// It is also non-blocking, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Thread-safety
  /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is safe to return borrowed ROS messages to the same publisher concurrently.
  /// However, since ownership of the loaned ROS message is given back to the middleware and
  /// this transfer is not synchronized, it is not safe to return the same loaned ROS message
  /// concurrently.
  ///
  /// \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  /// \pre Given `loaned_message` must have been previously borrowed from the same publisher
  /// using rmw_borrow_loaned_message().
  ///
  /// \param[in] publisher Publisher to which the loaned ROS message is associated.
  /// \param[in] loaned_message Type erased loaned ROS message to be returned.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier
  /// does not match this implementation, or
  /// \return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs and no message can be initialized.
  int rmw_return_loaned_message_from_publisher(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return (_rmw_return_loaned_message_from_publisher ??= _dylib.lookupFunction<
            _c_rmw_return_loaned_message_from_publisher,
            _dart_rmw_return_loaned_message_from_publisher>(
        'rmw_return_loaned_message_from_publisher'))(
      publisher,
      loaned_message,
    );
  }

  _dart_rmw_return_loaned_message_from_publisher?
      _rmw_return_loaned_message_from_publisher;

  /// /// Publish a ROS message.
  ///
  /// Send a ROS message to all subscriptions with matching QoS policies using the given publisher.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// It is implementation defined whether to publish a ROS message is a
  /// synchronous or asynchronous, blocking or non-blocking operation.
  /// However, asynchronous implementations are not allowed to access the
  /// given ROS message after this function returns.
  /// Check the implementation documentation to learn about publish behavior.
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on publish or not.
  /// For instance, implementations that serialize ROS messages to send it over the
  /// wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  /// A publisher allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when publishing ROS messages with and without publisher allocations.
  ///
  /// \par Thread-safety
  /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is safe to publish using the same publisher concurrently.
  /// However, when publishing regular ROS messages:
  /// - Access to the ROS message is read-only but it is not synchronized.
  /// Concurrent `ros_message` reads are safe, but concurrent reads and writes are not.
  /// - Access to the publisher allocation is not synchronized, unless specifically stated
  /// otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
  /// Check the implementation documentation to learn about publisher allocations' thread-safety.
  ///
  /// \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  /// \pre Given `ros_message` must be a valid message, whose type matches the message type
  /// support the `publisher` was registered with on creation.
  /// \pre If not NULL, given `allocation` must be a valid publisher allocation, initialized
  /// with rmw_publisher_allocation_init() with a message type support that matches the
  /// one registered with `publisher` on creation.
  ///
  /// \param[in] publisher Publisher to be used to send message.
  /// \param[in] ros_message Type erased ROS message to be sent.
  /// \param[in] allocation Pre-allocated memory to be used. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_publish(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return (_rmw_publish ??= _dylib
        .lookupFunction<_c_rmw_publish, _dart_rmw_publish>('rmw_publish'))(
      publisher,
      ros_message,
      allocation,
    );
  }

  _dart_rmw_publish? _rmw_publish;

  /// /// Publish a loaned ROS message.
  ///
  /// Send a previously borrowed ROS message to all subscriptions with matching QoS policies
  /// using the given publisher, then return ROS message ownership to the middleware.
  ///
  /// If this function fails early due to a logical error, such as an invalid argument,
  /// the loaned ROS message will be left unchanged.
  /// Otherwise, ownership of the ROS message will be given back to the middleware.
  /// It is up to the middleware what will be made of the returned ROS message.
  /// It is undefined behavior to use a loaned ROS message after publishing it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check the implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// It is implementation defined whether to publish a loaned ROS message is a
  /// synchronous or asynchronous, blocking or non-blocking operation.
  /// Check the implementation documentation to learn about publish behavior.
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on publish or not.
  /// For instance, implementations that serialize ROS messages to send it over the
  /// wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  /// A publisher allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when publishing loaned ROS messages with and without publisher allocations.
  ///
  /// \par Thread-safety
  /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is safe to publish using the same publisher concurrently.
  /// However, when publishing loaned ROS messages:
  /// - Ownership of the loaned ROS message is given back to the middleware.
  /// This transfer is not synchronized, and thus it is not safe to publish the
  /// same loaned ROS message concurrently.
  /// - Access to the publisher allocation is not synchronized, unless specifically stated
  /// otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
  /// Check the implementation documentation to learn about publisher allocations' thread-safety.
  ///
  /// \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  /// \pre Given `ros_message` must be a valid message, borrowed from the same publisher using
  /// rmw_borrow_loaned_message().
  /// \pre If not NULL, given `allocation` must be a valid publisher allocation, initialized
  /// with rmw_publisher_allocation_init() with a message type support that matches the
  /// one registered with `publisher` on creation.
  ///
  /// \param[in] publisher Publisher to be used to send message.
  /// \param[in] ros_message Loaned type erased ROS message to be sent.
  /// \param[in] allocation Pre-allocated memory to be used. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_publish_loaned_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return (_rmw_publish_loaned_message ??= _dylib.lookupFunction<
        _c_rmw_publish_loaned_message,
        _dart_rmw_publish_loaned_message>('rmw_publish_loaned_message'))(
      publisher,
      ros_message,
      allocation,
    );
  }

  _dart_rmw_publish_loaned_message? _rmw_publish_loaned_message;

  /// /// Retrieve the number of matched subscriptions to a publisher.
  ///
  /// Query the underlying middleware to determine how many subscriptions are
  /// matched to a given publisher.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] publisher the publisher object to inspect
  /// \param[out] subscription_count the number of subscriptions matched
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher
  /// implementation identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_publisher_count_matched_subscriptions(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<ffi.Uint64> subscription_count,
  ) {
    return (_rmw_publisher_count_matched_subscriptions ??=
        _dylib.lookupFunction<_c_rmw_publisher_count_matched_subscriptions,
                _dart_rmw_publisher_count_matched_subscriptions>(
            'rmw_publisher_count_matched_subscriptions'))(
      publisher,
      subscription_count,
    );
  }

  _dart_rmw_publisher_count_matched_subscriptions?
      _rmw_publisher_count_matched_subscriptions;

  /// /// Retrieve the actual qos settings of the publisher.
  ///
  /// Query the underlying middleware to determine the qos settings
  /// of the publisher.
  /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  /// can only be resolved after the creation of the publisher, and it
  /// depends on the underlying rmw implementation.
  /// If the underlying setting in use can't be represented in ROS terms,
  /// it will be set to RMW_*_UNKNOWN.
  ///
  /// \note The value of avoid_ros_namespace_conventions field is not resolved
  /// with this function. The rcl function `rcl_publisher_get_actual_qos()`
  /// resolves it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] publisher the publisher object to inspect
  /// \param[out] qos the actual qos settings
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher
  /// implementation identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_publisher_get_actual_qos(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return (_rmw_publisher_get_actual_qos ??= _dylib.lookupFunction<
        _c_rmw_publisher_get_actual_qos,
        _dart_rmw_publisher_get_actual_qos>('rmw_publisher_get_actual_qos'))(
      publisher,
      qos,
    );
  }

  _dart_rmw_publisher_get_actual_qos? _rmw_publisher_get_actual_qos;

  /// /// Publish a ROS message as a byte stream.
  ///
  /// Send a ROS message serialized as a byte stream to all subscriptions with
  /// matching QoS policies using the given publisher.
  /// A ROS message can be serialized manually using rmw_serialize().
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check the implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// It is implementation defined whether to publish a loaned ROS message is a
  /// synchronous or asynchronous, blocking or non-blocking operation.
  /// However, asynchronous implementations are not allowed to access the
  /// given byte stream after this function returns.
  /// Check the implementation documentation to learn about publish behavior.
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on publish or not.
  /// Even if a publisher allocation is provided, an implementation may ignore it.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when publishing serialized messages with and without publisher allocations.
  ///
  /// \par Thread-safety
  /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is safe to publish using the same publisher concurrently.
  /// However, when publishing serialized ROS messages:
  /// - Access to the byte stream is read-only but it is not synchronized.
  /// Concurrent `serialized_message` reads are safe, but concurrent reads and writes are not.
  /// - Access to the publisher allocation is not synchronized, unless specifically stated
  /// otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
  /// Check the implementation documentation to learn about publisher allocations' thread-safety.
  ///
  /// \pre Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
  /// \pre Given `serialized_message` must be a valid serialized message, initialized by
  /// rmw_serialized_message_init() and containing the serialization of a ROS message whose
  /// type matches the message type support the `publisher` was registered with on creation.
  /// \pre If not NULL, given `allocation` must be a valid publisher allocation, initialized
  /// with rmw_publisher_allocation_init() with a message type support that matches the
  /// one registered with `publisher` on creation.
  ///
  /// \param[in] publisher Publisher to be used to send message.
  /// \param[in] ros_message Serialized ROS message to be sent.
  /// \param[in] allocation Pre-allocated memory to be used. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_publish_serialized_message(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<rmw_publisher_allocation_t> allocation,
  ) {
    return (_rmw_publish_serialized_message ??= _dylib.lookupFunction<
            _c_rmw_publish_serialized_message,
            _dart_rmw_publish_serialized_message>(
        'rmw_publish_serialized_message'))(
      publisher,
      serialized_message,
      allocation,
    );
  }

  _dart_rmw_publish_serialized_message? _rmw_publish_serialized_message;

  /// /// Compute the size of a serialized message.
  ///
  /// Given a message definition and bounds, compute the serialized size.
  ///
  /// \param[in] type_support The type support of the message to compute.
  /// \param[in] bounds Artifical bounds to use on unbounded fields.
  /// \param[out] size The computed size of the serialized message.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  /// \return `RMW_RET_UNSUPPORTED` if it's unimplemented, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_get_serialized_message_size(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
    ffi.Pointer<ffi.Uint64> size,
  ) {
    return (_rmw_get_serialized_message_size ??= _dylib.lookupFunction<
            _c_rmw_get_serialized_message_size,
            _dart_rmw_get_serialized_message_size>(
        'rmw_get_serialized_message_size'))(
      type_support,
      message_bounds,
      size,
    );
  }

  _dart_rmw_get_serialized_message_size? _rmw_get_serialized_message_size;

  /// /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
  ///
  /// If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
  /// this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
  /// of the system that this Node is still alive.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] publisher handle to the publisher that needs liveliness to be asserted
  /// \return `RMW_RET_OK` if the liveliness assertion was completed successfully, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs, or
  /// \return `RMW_RET_UNSUPPORTED` if the rmw implementation does not support asserting liveliness.
  int rmw_publisher_assert_liveliness(
    ffi.Pointer<rmw_publisher_t> publisher,
  ) {
    return (_rmw_publisher_assert_liveliness ??= _dylib.lookupFunction<
            _c_rmw_publisher_assert_liveliness,
            _dart_rmw_publisher_assert_liveliness>(
        'rmw_publisher_assert_liveliness'))(
      publisher,
    );
  }

  _dart_rmw_publisher_assert_liveliness? _rmw_publisher_assert_liveliness;

  /// /// Serialize a ROS message into a rmw_serialized_message_t.
  ///
  /// The ROS message is serialized into a byte stream contained within the
  /// rmw_serialized_message_t structure.
  /// The serialization format depends on the underlying implementation.
  ///
  /// \pre Given ROS message must be a valid non-null instance, initialized
  /// by the caller and matching the provided typesupport.
  /// \pre Given typesupport must be a valid non-null instance, as provided
  /// by `rosidl` APIs.
  /// \pre Given serialized message must be a valid non-null instance, initialized
  /// by the caller.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [2]
  /// Lock-Free          | Maybe [2]
  /// <i>[1] if the given serialized message does not have enough capacity to hold
  /// the ROS message serialization</i>
  /// <i>[2] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] ros_message the typed ROS message
  /// \param[in] type_support the typesupport for the ROS message
  /// \param[out] serialized_message the destination for the serialize ROS message
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_serialize(
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ) {
    return (_rmw_serialize ??=
        _dylib.lookupFunction<_c_rmw_serialize, _dart_rmw_serialize>(
            'rmw_serialize'))(
      ros_message,
      type_support,
      serialized_message,
    );
  }

  _dart_rmw_serialize? _rmw_serialize;

  /// /// Deserialize a ROS message.
  ///
  /// The given rmw_serialized_message_t's internal byte stream buffer is deserialized
  /// into the given ROS message.
  /// The serialization format expected in the rmw_serialized_message_t depends on the
  /// underlying implementation.
  ///
  /// \pre Given serialized message must be a valid non-null instance, such
  /// as that returned by `rmw_serialize()`, matching provided typesupport
  /// and ROS message.
  /// \pre Given typesupport must be a valid non-null instance, as provided
  /// by `rosidl` APIs.
  /// \pre Given ROS message must be a valid non-null instance, initialized
  /// by the caller.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [2]
  /// Lock-Free          | Maybe [2]
  /// <i>[1] if the given ROS message contains unbounded fields</i>
  /// <i>[2] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] serialized_message the serialized message holding the byte stream
  /// \param[in] type_support the typesupport for the typed ros message
  /// \param[out] ros_message destination for the deserialized ROS message
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_deserialize(
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Void> ros_message,
  ) {
    return (_rmw_deserialize ??=
        _dylib.lookupFunction<_c_rmw_deserialize, _dart_rmw_deserialize>(
            'rmw_deserialize'))(
      serialized_message,
      type_support,
      ros_message,
    );
  }

  _dart_rmw_deserialize? _rmw_deserialize;

  /// /// Initialize a subscription allocation to be used with later `take`s.
  ///
  /// This creates an allocation object that can be used in conjunction with
  /// the rmw_take method to perform more carefully control memory allocations.
  ///
  /// This will allow the middleware to preallocate the correct amount of memory
  /// for a given message type and message bounds.
  /// As allocation is performed in this method, it will not be necessary to allocate
  /// in the `rmw_take` method.
  ///
  /// \param[in] type_support Type support of the message to be preallocated.
  /// \param[in] message_bounds Bounds structure of the message to be preallocated.
  /// \param[out] allocation Allocation structure to be passed to `rmw_take`.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_UNSUPPORTED` if it's unimplemented
  /// \return `RMW_RET_INVALID_ARGUMENT` if an argument is null, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_init_subscription_allocation(
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_init_subscription_allocation ??= _dylib.lookupFunction<
            _c_rmw_init_subscription_allocation,
            _dart_rmw_init_subscription_allocation>(
        'rmw_init_subscription_allocation'))(
      type_support,
      message_bounds,
      allocation,
    );
  }

  _dart_rmw_init_subscription_allocation? _rmw_init_subscription_allocation;

  /// /// Destroy a publisher allocation object.
  ///
  /// This deallocates memory allocated by `rmw_init_subscription_allocation`.
  ///
  /// \param[in] allocation Allocation object to be destroyed.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_UNSUPPORTED` if it's unimplemented
  /// \return `RMW_RET_INVALID_ARGUMENT` if argument is null, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_fini_subscription_allocation(
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_fini_subscription_allocation ??= _dylib.lookupFunction<
            _c_rmw_fini_subscription_allocation,
            _dart_rmw_fini_subscription_allocation>(
        'rmw_fini_subscription_allocation'))(
      allocation,
    );
  }

  _dart_rmw_fini_subscription_allocation? _rmw_fini_subscription_allocation;

  /// /// Create a subscription and return a handle to that subscription.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - node is not a valid non-null handle for this rmw implementation,
  /// as returned by `rmw_create_node()`
  /// - type_support is a not valid non-null message type support, as returned by
  /// `ROSIDL_GET_MSG_TYPE_SUPPORT()`
  /// - topic_name is not a valid non-null topic name, according to
  /// `rmw_validate_full_topic_name()` if ROS namespace conventions apply
  /// - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies
  /// - subscription_options is not a valid non-null option set, such as the one
  /// returned by `rmw_get_default_subscription_options()`
  /// - memory allocation fails during subscription creation
  /// - an unspecified error occurs
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] node Handle to node with which to register this subscription
  /// \param[in] type_support Type support for the messages to be subscribed to
  /// \param[in] topic_name Name of the topic to subscribe to, often a fully qualified
  /// topic name unless `qos_profile` is configured to avoid ROS namespace conventions
  /// i.e. to create a native topic subscription
  /// \param[in] qos_profile QoS policies for this subscription
  /// \param[in] subscription_options Options for configuring this subscription
  /// \return rmw subscription handle, or `NULL` if there was an error
  ffi.Pointer<rmw_subscription_t> rmw_create_subscription(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_message_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<rmw_qos_profile_t> qos_policies,
    ffi.Pointer<rmw_subscription_options_t> subscription_options,
  ) {
    return (_rmw_create_subscription ??= _dylib.lookupFunction<
        _c_rmw_create_subscription,
        _dart_rmw_create_subscription>('rmw_create_subscription'))(
      node,
      type_support,
      topic_name,
      qos_policies,
      subscription_options,
    );
  }

  _dart_rmw_create_subscription? _rmw_create_subscription;

  /// /// Finalize a given subscription handle, reclaim the resources, and deallocate the subscription
  /// /// handle.
  ///
  /// This function will return early if a logical error, namely `RMW_RET_INVALID_ARGUMENT`
  /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given subscription handle
  /// unchanged.
  /// Otherwise, it will proceed despite errors, freeing as many resources as it can, including
  /// the subscription handle, and return `RMW_RET_ERROR`. Usage of a deallocated subscription
  /// handle is undefined behavior.
  ///
  /// \pre Given node must be the one the subscription was registered with.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] node Handle to node with which the given subscription is registered
  /// \param[in] subscription Handle to subscription to be finalized
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if node or subscription is `NULL`, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or subscription
  /// implementation identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_destroy_subscription(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_subscription_t> subscription,
  ) {
    return (_rmw_destroy_subscription ??= _dylib.lookupFunction<
        _c_rmw_destroy_subscription,
        _dart_rmw_destroy_subscription>('rmw_destroy_subscription'))(
      node,
      subscription,
    );
  }

  _dart_rmw_destroy_subscription? _rmw_destroy_subscription;

  /// /// Retrieve the number of matched publishers to a subscription.
  ///
  /// Query the underlying middleware to determine how many publishers are
  /// matched to a given subscription.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] subscription the subscription object to inspect
  /// \param[out] publisher_count the number of publishers matched
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription
  /// implementation identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_subscription_count_matched_publishers(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Uint64> publisher_count,
  ) {
    return (_rmw_subscription_count_matched_publishers ??=
        _dylib.lookupFunction<_c_rmw_subscription_count_matched_publishers,
                _dart_rmw_subscription_count_matched_publishers>(
            'rmw_subscription_count_matched_publishers'))(
      subscription,
      publisher_count,
    );
  }

  _dart_rmw_subscription_count_matched_publishers?
      _rmw_subscription_count_matched_publishers;

  /// /// Retrieve the actual qos settings of the subscription.
  ///
  /// Query the underlying middleware to determine the qos settings
  /// of the subscription.
  /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
  /// can only be resolved after the creation of the subscription, and it
  /// depends on the underlying rmw implementation.
  /// If the underlying setting in use can't be represented in ROS terms,
  /// it will be set to RMW_*_UNKNOWN.
  ///
  /// \note The value of avoid_ros_namespace_conventions field is not resolved
  /// with this function. The rcl function `rcl_subscription_get_actual_qos()`
  /// resolves it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \param[in] subscription the subscription object to inspect
  /// \param[out] qos the actual qos settings
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if either argument is null, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription
  /// implementation identifier does not match, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_subscription_get_actual_qos(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rmw_qos_profile_t> qos,
  ) {
    return (_rmw_subscription_get_actual_qos ??= _dylib.lookupFunction<
            _c_rmw_subscription_get_actual_qos,
            _dart_rmw_subscription_get_actual_qos>(
        'rmw_subscription_get_actual_qos'))(
      subscription,
      qos,
    );
  }

  _dart_rmw_subscription_get_actual_qos? _rmw_subscription_get_actual_qos;

  /// /// Take an incoming ROS message.
  ///
  /// Take a ROS message already received by the given subscription, removing it from internal queues.
  /// This function will succeed even if no ROS message was received, but `taken` will be false.
  ///
  /// \remarks The same ROS message cannot be taken twice.
  /// Callers do not have to deal with duplicates.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To take a ROS message is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  /// but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations that deserialize ROS messages received over
  /// the wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  /// A subscription allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when taking ROS messages with and without subscription allocations.
  ///
  /// \par Thread-safety
  /// Subscriptions are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take from the same subscription concurrently.
  /// However, when taking regular ROS messages:
  /// - Access to the given ROS message is not synchronized.
  /// It is not safe to read or write `ros_message` while rmw_take() uses it.
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` while rmw_take() uses it.
  /// - Access to the given subscription allocation is not synchronized,
  /// unless specifically stated otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while rmw_take() uses it.
  /// Check the implementation documentation to learn about subscription allocations'
  /// thread-safety.
  ///
  /// \pre Given `subscription` must be a valid subscription, as returned
  /// by rmw_create_subscription().
  /// \pre Given `ros_message` must be a valid message, whose type matches the message type support
  /// registered with the `subscription` on creation.
  /// \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  /// with rmw_subscription_allocation_init() with a message type support that matches the
  /// one registered with the `subscription` on creation.
  /// \post Given `ros_message` will remain a valid message.
  /// It will be left unchanged if this function fails early due to a logical error, such as an
  /// invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  /// It will also be left unchanged if this function succeeds but `taken` is false.
  ///
  /// \param[in] subscription Subscription to take message from.
  /// \param[out] ros_message Type erased ROS message to write to.
  /// \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  /// \param[in] allocation Pre-allocated memory to be used. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_take ??=
        _dylib.lookupFunction<_c_rmw_take, _dart_rmw_take>('rmw_take'))(
      subscription,
      ros_message,
      taken,
      allocation,
    );
  }

  _dart_rmw_take? _rmw_take;

  /// /// Take an incoming ROS message with its metadata.
  ///
  /// Same as rmw_take(), except it also takes ROS message metadata.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To take a ROS message with its metadata is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  /// but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations that deserialize ROS messages received over
  /// the wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  /// A subscription allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when taking ROS messages with and without subscription allocations.
  ///
  /// \par Thread-safety
  /// Subscriptions are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take from the same subscription concurrently.
  /// However, when taking regular ROS messages with metadata:
  /// - Access to the given ROS message is not synchronized.
  /// It is not safe to read or write `ros_message` while rmw_take_with_info() uses it.
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` while rmw_take_with_info() uses it.
  /// - Access to the given ROS message metadata is not synchronized.
  /// It is not safe to read or write `message_info` while rmw_take_with_info() uses it.
  /// - Access to the given subscription allocation is not synchronized,
  /// unless specifically stated otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while rmw_take_with_info()
  /// uses it.
  /// Check the implementation documentation to learn about subscription allocations'
  /// thread-safety.
  ///
  /// \pre Given `subscription` must be a valid subscription, as returned
  /// by rmw_create_subscription().
  /// \pre Given `ros_message` must be a valid message, whose type matches
  /// the message type support registered with the `subscription` on creation.
  /// \pre If not NULL, given `allocation` must be a valid subscription allocation
  /// initialized with rmw_subscription_allocation_init() with a message type support
  /// that matches the one registered with the `subscription` on creation.
  /// \post Given `ros_message` will remain a valid message, and
  /// `message_info`, valid message metadata.
  /// Both will be left unchanged if this function fails early due to a logical error, such as
  /// an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  /// Both will also be left unchanged if this function succeeds but `taken` is false.
  ///
  /// \param[in] subscription Subscription to take ROS message from.
  /// \param[out] ros_message Type erased ROS message to write to.
  /// \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  /// \param[out] message_info Taken ROS message metadata.
  /// \param[in] allocation Pre-allocated memory to be used. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> ros_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_take_with_info ??=
        _dylib.lookupFunction<_c_rmw_take_with_info, _dart_rmw_take_with_info>(
            'rmw_take_with_info'))(
      subscription,
      ros_message,
      taken,
      message_info,
      allocation,
    );
  }

  _dart_rmw_take_with_info? _rmw_take_with_info;

  /// /// Take multiple incoming ROS messages with their metadata.
  ///
  /// Take a sequence of consecutive ROS messages already received by the given
  /// subscription, removing them from internal queues.
  /// While `count` ROS messages may be requested, fewer messages may have been
  /// received by the subscription.
  /// This function will only take what has been already received, and it will
  /// succeed even if fewer (or zero) messages were received.
  /// In this case, only currently available messages will be returned.
  /// The `taken` flag indicates the number of ROS messages actually taken.
  ///
  /// \remarks Once taken, ROS messages in the sequence cannot be taken again.
  /// Callers do not have to deal with duplicates.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To take a sequence of ROS messages is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  /// but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations that deserialize ROS messages received over
  /// the wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  /// A subscription allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when taking ROS messages with and without subscription allocations.
  ///
  /// \par Thread-safety
  /// Subscriptions are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take from the same subscription concurrently.
  /// Moreover, the sequence of ROS messages taken is guaranteed to be consecutive and to
  /// preserve the order in the subscription queues, despite any concurrent takes.
  /// However, when taking a sequence of ROS messages with metadata:
  /// - Access to the given ROS message sequence is not synchronized.
  /// It is not safe to read or write `message_sequence` while rmw_take_sequence() uses it.
  /// - Access to the given ROS message metadata sequence is not synchronized.
  /// It is not safe to read or write `message_info_sequence` while rmw_take_sequence() uses it.
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` while rmw_take_sequence() uses it.
  /// - Access to the given subscription allocation is not synchronized,
  /// unless specifically stated otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while rmw_take_sequence()
  /// uses it.
  /// Check the implementation documentation to learn about subscription allocations'
  /// thread-safety.
  ///
  /// \pre Given `subscription` must be a valid subscription, as returned
  /// by rmw_create_subscription().
  /// \pre Given `message_sequence` must be a valid message sequence, initialized
  /// by rmw_message_sequence_init() and populated with ROS messages whose
  /// type matches the message type support registered with the `subscription`
  /// on creation.
  /// \pre Given `message_info_sequence` must be a valid message metadata sequence,
  /// initialized by rmw_message_info_sequence_init().
  /// \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  /// with rmw_subscription_allocation_init() with a message type support that matches the
  /// one registered with `subscription` on creation.
  /// \post Given `message_sequence` will remain a valid message sequence, and
  /// `message_info_sequence`, a valid message metadata sequence.
  /// Both will be left unchanged if this function fails early due to a logical error, such as
  /// an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  /// Both will also be left unchanged if this function succeeds but `taken` is false.
  ///
  /// \param[in] subscription Subscription to take ROS message from.
  /// \param[in] count Number of messages to attempt to take.
  /// \param[out] message_sequence Sequence of type erase ROS messages to write to.
  /// Message sequence capacity has to be enough to hold all requested messages
  /// i.e. capacity has to be equal or greater than `count`.
  /// It does not have to match that of `message_info_sequence`.
  /// \param[out] message_info_sequence Sequence of additional message metadata.
  /// Message info sequence capacity has to be enough to hold all requested messages
  /// metadata i.e. capacity has to be equal or greater than `count`.
  /// It does not have to match that of `message_sequence`.
  /// \param[out] taken Number of messages actually taken from subscription.
  /// \param[in] allocation Pre-allocated memory to use. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `count` is 0, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `message_sequence` capacity is less than `count`, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` capacity is less than `count`, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take_sequence(
    ffi.Pointer<rmw_subscription_t> subscription,
    int count,
    ffi.Pointer<rmw_message_sequence_t> message_sequence,
    ffi.Pointer<rmw_message_info_sequence_t> message_info_sequence,
    ffi.Pointer<ffi.Uint64> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_take_sequence ??=
        _dylib.lookupFunction<_c_rmw_take_sequence, _dart_rmw_take_sequence>(
            'rmw_take_sequence'))(
      subscription,
      count,
      message_sequence,
      message_info_sequence,
      taken,
      allocation,
    );
  }

  _dart_rmw_take_sequence? _rmw_take_sequence;

  /// /// Take an incoming ROS message as a byte stream.
  ///
  /// Take a ROS message already received by the given subscription, removing it from internal queues.
  /// This function will succeed even if no ROS message was received, but `taken` will be false.
  /// Unlike rmw_take(), the ROS message is taken in its serialized form, as a byte stream.
  /// If needed, this byte stream can then be deserialized into a ROS message with rmw_deserialize().
  ///
  /// \remarks The same ROS message, serialized or not, cannot be taken twice.
  /// Callers do not have to deal with duplicates.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To take a ROS message a byte stream is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  /// but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations may have to perform additional memory allocations
  /// when dealing with ROS messages that contain unbounded (dynamically-sized) fields
  /// i.e. these implementations may have to resize the given byte stream.
  /// A subscription allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation guarantees
  /// when taking serialized ROS messages with and without subscription allocations.
  /// \par
  /// For ROS messages that only contain bounded (fixed-size) fields, callers can query
  /// their size using rmw_get_serialized_message_size() and resize `serialized_message`
  /// using rmw_serialized_message_resize() accordingly to prevent byte stream resizing
  /// on take.
  /// Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.
  ///
  /// \par Thread-safety
  /// Subscriptions are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take from the same subscription concurrently.
  /// However, when taking serialized ROS messages:
  /// - Access to the given byte stream for serialized ROS messages is not synchronized.
  /// It is not safe to read or write `serialized_message` while
  /// rmw_take_serialized_message() uses it.
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` while rmw_take_serialized_message() uses it.
  /// - Access to the given subscription allocation is not synchronized,
  /// unless specifically stated otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while
  /// rmw_take_serialized_message() uses it.
  /// Check the implementation documentation to learn about subscription allocations'
  /// thread-safety.
  ///
  /// \pre Given `subscription` must be a valid subscription, as returned by
  /// rmw_create_subscription().
  /// \pre Given `serialized_message` must be a valid serialized message, initialized by
  /// rmw_serialized_message_init().
  /// \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  /// with rmw_subscription_allocation_init() with a message type support that matches the
  /// one registered with `subscription` on creation.
  /// \post Given `serialized_message` will remain a valid serialized message.
  /// It will be left unchanged if this function fails early due to a logical error,
  /// such as an invalid argument, or in an unknown yet valid state if it fails due to a
  /// runtime error.
  /// It will also be left unchanged if this function succeeds but `taken` is false.
  ///
  /// \param[in] subscription Subscription to take ROS message from.
  /// \param[out] serialized_message Byte stream to write to.
  /// \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  /// \param[in] allocation Pre-allocated memory to use. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take_serialized_message(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_take_serialized_message ??= _dylib.lookupFunction<
        _c_rmw_take_serialized_message,
        _dart_rmw_take_serialized_message>('rmw_take_serialized_message'))(
      subscription,
      serialized_message,
      taken,
      allocation,
    );
  }

  _dart_rmw_take_serialized_message? _rmw_take_serialized_message;

  /// /// Take an incoming ROS message as a byte stream with its metadata.
  ///
  /// Same as rmw_take_serialized_message(), except it also takes ROS message metadata.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To take a ROS message a byte stream with its metadata is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
  /// but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations may have to perform additional memory allocations
  /// when dealing with ROS messages that contain unbounded (dynamically-sized) fields
  /// i.e. these implementations may have to resize the given byte stream.
  /// A subscription allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation guarantees
  /// when taking serialized ROS messages with and without subscription allocations.
  /// \par
  /// For ROS messages that only contain bounded (fixed-size) fields, callers can query
  /// their size using rmw_get_serialized_message_size() and resize `serialized_message`
  /// using rmw_serialized_message_resize() accordingly to prevent byte stream resizing
  /// on take.
  /// Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.
  ///
  /// \par Thread-safety
  /// Subscriptions are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take from the same subscription concurrently.
  /// However, when taking serialized ROS messages with metadata:
  /// - Access to the given byte stream for serialized ROS messages is not synchronized.
  /// It is not safe to read or write `serialized_message` while
  /// rmw_take_serialized_message_with_info() uses it.
  /// - Access to the given ROS message metadata is not synchronized.
  /// It is not safe to read or write `message_info` while
  /// rmw_take_serialized_message_with_info() uses it.
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` while rmw_take_serialized_message_with_info()
  /// uses it.
  /// - Access to the given subscription allocation is not synchronized,
  /// unless specifically stated otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while
  /// rmw_take_serialized_message_with_info() uses it.
  /// Check the implementation documentation to learn about subscription allocations'
  /// thread-safety.
  ///
  /// \pre Given `serialized_message` must be a valid serialized message, initialized by
  /// rmw_serialized_message_init().
  /// \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  /// with rmw_subscription_allocation_init() with a message type support that matches the
  /// one registered with `subscription` on creation.
  /// \post Given `serialized_message` will remain a valid serialized message, and `message_info`,
  /// valid message metadata.
  /// Both will be left unchanged if this function fails early due to a logical error,
  /// such as an invalid argument, or in an unknown yet valid state if it fails due to a
  /// runtime error.
  /// It will also be left unchanged if this function succeeds but `taken` is false.
  ///
  /// \param[in] subscription Subscription to take ROS message from.
  /// \param[out] serialized_message Byte stream to write to.
  /// \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  /// \param[out] message_info Taken ROS message metadata.
  /// \param[in] allocation Pre-allocated memory to use. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take_serialized_message_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<rcutils_uint8_array_t> serialized_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_take_serialized_message_with_info ??= _dylib.lookupFunction<
            _c_rmw_take_serialized_message_with_info,
            _dart_rmw_take_serialized_message_with_info>(
        'rmw_take_serialized_message_with_info'))(
      subscription,
      serialized_message,
      taken,
      message_info,
      allocation,
    );
  }

  _dart_rmw_take_serialized_message_with_info?
      _rmw_take_serialized_message_with_info;

  /// /// Take an incoming ROS message, loaned by the middleware.
  ///
  /// Take a ROS message already received by the given subscription, removing it from internal queues.
  /// This function will succeed even if no ROS message was received, but `taken` will be false.
  /// The loaned ROS message is owned by the middleware, which will keep it alive (i.e. in valid
  /// memory space) until the caller returns it using rmw_return_loaned_message_from_subscription().
  ///
  /// \remarks The same ROS message, loaned or not, cannot be taken twice.
  /// Callers do not have to deal with duplicates.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To take a loaned ROS message is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive
  /// nor for internal memory loaning pools, if any, to be replenished, but it is not
  /// guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations that deserialize ROS messages received over
  /// the wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  /// A subscription allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when taking loaned ROS messages with and without subscription allocations.
  ///
  /// \par Thread-safety
  /// Subscriptions are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take from the same subscription concurrently.
  /// However, when taking loaned ROS messages:
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` nor `loaned_message`
  /// while rmw_take_loaned_message() uses them.
  /// - Access to the given subscription allocation is not synchronized,
  /// unless specifically stated otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while
  /// rmw_take_loaned_message() uses it.
  /// Check the implementation documentation to learn about subscription allocations'
  /// thread-safety.
  ///
  /// \pre Given `subscription` must be a valid subscription, as returned
  /// by rmw_create_subscription().
  /// \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  /// with rmw_subscription_allocation_init() with a message type support that matches the
  /// one registered with `subscription` on creation.
  /// \post Given `loaned_message` will remain unchanged, or point to a valid message if
  /// this function was successful and `taken` is true.
  ///
  /// \param[in] subscription Subscription to take ROS message from.
  /// \param[inout] loaned_message Pointer to type erased ROS message taken
  /// and loaned by the middleware.
  /// \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  /// \param[in] allocation Pre-allocated memory to use. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL (to prevent leaks), or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take_loaned_message(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_take_loaned_message ??= _dylib.lookupFunction<
        _c_rmw_take_loaned_message,
        _dart_rmw_take_loaned_message>('rmw_take_loaned_message'))(
      subscription,
      loaned_message,
      taken,
      allocation,
    );
  }

  _dart_rmw_take_loaned_message? _rmw_take_loaned_message;

  /// /// Take a loaned message and with its additional message information.
  ///
  /// Same as rmw_take_loaned_message(), except it also takes ROS message metadata.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To take a loaned ROS message with its metadata is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive
  /// nor for internal memory loaning pools, if any, to be replenished, but it is not
  /// guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations that deserialize ROS messages received over
  /// the wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  /// A subscription allocation, if provided, may or may not be used.
  /// Check the implementation documentation to learn about memory allocation
  /// guarantees when taking loaned ROS messages with and without subscription allocations.
  ///
  /// \par Thread-safety
  /// Subscriptions are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take from the same subscription concurrently.
  /// However, when taking loaned ROS messages with metadata:
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` nor `loaned_message`
  /// while rmw_take_loaned_message_with_info() uses them.
  /// - Access to the given ROS message metadata is not synchronized.
  /// It is not safe to read or write `message_info` while
  /// rmw_take_loaned_message_with_info() uses it.
  /// - Access to the given subscription allocation is not synchronized,
  /// unless specifically stated otherwise by the implementation.
  /// Thus, it is generally not safe to read or write `allocation` while
  /// rmw_take_loaned_message_with_info() uses it.
  /// Check the implementation documentation to learn about subscription allocations'
  /// thread-safety.
  ///
  /// \pre Given `subscription` must be a valid subscription, as returned
  /// by rmw_create_subscription().
  /// \pre If not NULL, given `allocation` must be a valid subscription allocation initialized
  /// with rmw_subscription_allocation_init() with a message type support that matches the
  /// one registered with `subscription` on creation.
  /// \post Given `loaned_message` will remain unchanged, or point to a valid message if
  /// this function was successful and `taken` is true.
  /// \post Given `message_info` will remain valid message metadata.
  /// It will be left unchanged if this function fails early due to a logical error,
  /// such as an invalid argument, or in an unknown yet valid state if it fails due to a
  /// runtime error.
  /// It will also be left unchanged if this function succeeds but `taken` is false.
  ///
  /// \param[in] subscription Subscription to take ROS message from.
  /// \param[inout] loaned_message Pointer to type erased ROS message taken
  /// and loaned by the middleware.
  /// \param[out] taken Boolean flag indicating if a ROS message was taken or not.
  /// \param[out] message_info Taken ROS message metadata.
  /// \param[in] allocation Pre-allocated memory to use. May be NULL.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL to prevent leaks, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take_loaned_message_with_info(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
    ffi.Pointer<ffi.Uint8> taken,
    ffi.Pointer<rmw_message_info_t> message_info,
    ffi.Pointer<rmw_subscription_allocation_t> allocation,
  ) {
    return (_rmw_take_loaned_message_with_info ??= _dylib.lookupFunction<
            _c_rmw_take_loaned_message_with_info,
            _dart_rmw_take_loaned_message_with_info>(
        'rmw_take_loaned_message_with_info'))(
      subscription,
      loaned_message,
      taken,
      message_info,
      allocation,
    );
  }

  _dart_rmw_take_loaned_message_with_info? _rmw_take_loaned_message_with_info;

  /// /// Return a loaned ROS message previously taken from a subscription.
  ///
  /// Tells the middleware that previously loaned ROS message is no longer needed by the caller.
  /// If this function fails early due to a logical error, such as an invalid argument,
  /// the loaned ROS message will be left unchanged.
  /// Otherwise, ownership of the ROS message will be given back to the middleware.
  /// It is up to the middleware what will be made of the returned ROS message.
  /// It is undefined behavior to use a loaned ROS message after returning it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// To return a loaned ROS message is a synchronous operation.
  /// It is also non-blocking, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Thread-safety
  /// Subscriptions are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to return loaned ROS messages to the same subscription concurrently.
  /// However, since ownership of the loaned ROS message is given back to middleware and this
  /// transfer is not synchronized, it is not safe to return the same loaned ROS message
  /// concurrently.
  ///
  /// \pre Given `subscription` must be a valid subscription, as returned
  /// by rmw_create_subscription().
  /// \pre Given `loaned_message` must be a loaned ROS message, previously taken from
  /// `subscription` using rmw_take_loaned_message() or rmw_take_loaned_message_with_info().
  ///
  /// \param[in] subscription Subscription the ROS message was taken and loaned from.
  /// \param[in] loaned_message Loaned type erased ROS message to be returned to the middleware.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_return_loaned_message_from_subscription(
    ffi.Pointer<rmw_subscription_t> subscription,
    ffi.Pointer<ffi.Void> loaned_message,
  ) {
    return (_rmw_return_loaned_message_from_subscription ??=
        _dylib.lookupFunction<_c_rmw_return_loaned_message_from_subscription,
                _dart_rmw_return_loaned_message_from_subscription>(
            'rmw_return_loaned_message_from_subscription'))(
      subscription,
      loaned_message,
    );
  }

  _dart_rmw_return_loaned_message_from_subscription?
      _rmw_return_loaned_message_from_subscription;

  /// /// Create a service client that can send requests to and receive replies from a service server.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - `node` is `NULL`, or
  /// - `node` does not belong to this implementation
  /// i.e. it does not have a matching implementation identifier, or
  /// - `type_support` is `NULL`, or
  /// - `service_name` is `NULL`, or
  /// - `service_name` is an empty string, or
  /// - (if ROS namespace conventions apply) `service_name` is invalid by
  /// rmw_validate_full_topic_name() definition, or
  /// - `qos_profile` is `NULL`, or
  /// - `qos_profile` has invalid or unknown policies, or
  /// - memory allocation fails during service client creation, or
  /// - an unspecified error occurs.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \pre Given `node` must be a valid node, as returned by rmw_create_node().
  /// \pre Given `type_support` must be a valid `rosidl` service type support, as
  /// returned by ROSIDL_GET_SRV_TYPE_SUPPORT().
  ///
  /// \param[in] node Node with which to register this service client.
  /// \param[in] type_support Type support of the service to be used.
  /// \param[in] service_name Name of the service to be used, often a fully qualified
  /// service name unless `qos_profile` is configured to avoid ROS namespace conventions
  /// i.e. to create a native service client.
  /// \param[in] qos_profile QoS policies for this service client's connections.
  /// \return rmw service client handle, or `NULL` if there was an error.
  ffi.Pointer<rmw_client_t> rmw_create_client(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> service_name,
    ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ) {
    return (_rmw_create_client ??=
        _dylib.lookupFunction<_c_rmw_create_client, _dart_rmw_create_client>(
            'rmw_create_client'))(
      node,
      type_support,
      service_name,
      qos_policies,
    );
  }

  _dart_rmw_create_client? _rmw_create_client;

  /// /// Destroy and unregister a service client from its node.
  ///
  /// This function will reclaim all associated resources, including the service client itself.
  /// Use of a destroyed service client is undefined behavior.
  /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service client unchanged.
  /// Otherwise, it will proceed despite errors.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \pre Given `node` must be the one the service client was registered with.
  /// \pre Given `client` must be a valid service client, as returned by rmw_create_service().
  ///
  /// \param[in] node Node with which the given service client is registered.
  /// \param[in] client Service client to be destroyed.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `client` is `NULL`, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_destroy_client(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_client_t> client,
  ) {
    return (_rmw_destroy_client ??=
        _dylib.lookupFunction<_c_rmw_destroy_client, _dart_rmw_destroy_client>(
            'rmw_destroy_client'))(
      node,
      client,
    );
  }

  _dart_rmw_destroy_client? _rmw_destroy_client;

  /// /// Send a ROS service request.
  ///
  /// Send a ROS service request to one or more service servers, with matching QoS policies,
  /// using the given client.
  ///
  /// \note It is implementation defined how many service servers may get, and potentially react to,
  /// the same request, considering there may be more than one server for the same service
  /// in the ROS graph.
  ///
  /// On success, this function will return a sequence number.
  /// It is up to callers to save the returned sequence number to pair the ROS service request
  /// just sent with future ROS service responses (taken using rmw_take_response()).
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// It is implementation defined whether sending a ROS service request is a
  /// synchronous or asynchronous, and blocking or non-blocking, operation.
  /// However, asynchronous implementations are not allowed to access the
  /// given ROS service request after this function returns.
  /// Check the implementation documentation to learn about request behavior.
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on send or not.
  /// For instance, implementations that serialize ROS service requests may need to
  /// perform additional memory allocations when dealing with unbounded (dynamically-sized)
  /// fields.
  ///
  /// \par Thread-safety
  /// Service clients are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to send requests using the same service client concurrently.
  /// However:
  /// - Access to the given ROS service request is read-only but it is not synchronized.
  /// Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `sequence_id` while rmw_send_request() uses it.
  ///
  /// \pre Given `client` must be a valid client, as returned by rmw_create_client().
  /// \pre Given `ros_request` must be a valid service request, whose type matches the
  /// service type support registered with the `client` on creation.
  ///
  /// \param[in] client Service client to send a request with.
  /// \param[in] ros_request ROS service request to be sent.
  /// \param[out] sequence_id Sequence number for the `ros_request` just sent
  /// i.e. a unique identification number for it, populated on success.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `sequence_id` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_send_request(
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Int64> sequence_id,
  ) {
    return (_rmw_send_request ??=
        _dylib.lookupFunction<_c_rmw_send_request, _dart_rmw_send_request>(
            'rmw_send_request'))(
      client,
      ros_request,
      sequence_id,
    );
  }

  _dart_rmw_send_request? _rmw_send_request;

  /// /// Take an incoming ROS service response.
  ///
  /// Take a ROS service response already received by the given service server, removing
  /// it from internal queues.
  /// The response header (i.e. its metadata), containing at least the writer guid and
  /// sequence number, is also retrieved.
  /// Both writer guid and sequence number allow callers to pair, potentially for each
  /// remote service server, a ROS service response with its corresponding ROS service
  /// request, previously sent using rmw_send_request().
  ///
  /// \note It is implementation defined how many responses a given request may get,
  /// considering there may be more than one server for the same service in the ROS graph.
  ///
  /// This function will succeed even if no ROS service request was received,
  /// but `taken` will be false.
  ///
  /// \remarks The same ROS service response cannot be taken twice.
  /// Callers do not have to deal with duplicates.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// Taking a ROS service response is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS service responses
  /// to arrive, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations that deserialize ROS service responses received over
  /// the wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  ///
  /// \par Thread-safety
  /// Service clients are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take responses from the same service client concurrently.
  /// However:
  /// - Access to the given ROS service response is not synchronized.
  /// It is not safe to read or write `ros_response` while rmw_take_request() uses it.
  /// - Access to the given ROS service response header is not synchronized.
  /// It is not safe to read or write `response_header` while rmw_take_response() uses it.
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` while rmw_take_response() uses it.
  ///
  /// \pre Given `client` must be a valid client, as returned by rmw_create_client().
  /// \pre Given `ros_response` must be a valid service response, whose type matches the
  /// service type support registered with the `client` on creation.
  /// \post Given `ros_response` will remain a valid service response.
  /// It will be left unchanged if this function fails early due to a logical error, such as an
  /// invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  /// It will also be left unchanged if this function succeeds but `taken` is false.
  ///
  /// \param[in] client Service client to take response from.
  /// \param[out] response_header Service response header to write to.
  /// \param[out] ros_request Type erased ROS service response to write to.
  /// \param[out] taken Boolean flag indicating if a ROS service response was taken or not.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `response_header` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take_response(
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<rmw_service_info_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
    ffi.Pointer<ffi.Uint8> taken,
  ) {
    return (_rmw_take_response ??=
        _dylib.lookupFunction<_c_rmw_take_response, _dart_rmw_take_response>(
            'rmw_take_response'))(
      client,
      request_header,
      ros_response,
      taken,
    );
  }

  _dart_rmw_take_response? _rmw_take_response;

  /// /// Create a service server that can receive requests from and send replies to a service client.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - `node` is `NULL`, or
  /// - `node` does not belong to this implementation
  /// i.e. it does not have a matching implementation identifier, or
  /// - `type_support` is `NULL`, or
  /// - `service_name` is `NULL`, or
  /// - `service_name` is an empty string, or
  /// - (if ROS namespace conventions apply) `service_name` is invalid by
  /// rmw_validate_full_topic_name() definition, or
  /// - `qos_profile` is `NULL`, or
  /// - `qos_profile` has invalid or unknown policies, or
  /// - memory allocation fails during service server creation, or
  /// - an unspecified error occurs
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \pre Given `node` must be a valid node, as returned by rmw_create_node().
  /// \pre Given `type_support` must be a valid `rosidl` service type support, as
  /// returned by ROSIDL_GET_SRV_TYPE_SUPPORT().
  ///
  /// \param[in] node Node with which to register this service server.
  /// \param[in] type_support Type support of the service to be served.
  /// \param[in] service_name Name of the service to be served, often a fully qualified
  /// service name unless `qos_profile` is configured to avoid ROS namespace conventions
  /// i.e. to create a native service server.
  /// \param[in] qos_profile QoS policies for this service server's connections.
  /// \return rmw service handle, or `NULL` if there was an error.
  ffi.Pointer<rmw_service_t> rmw_create_service(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rosidl_service_type_support_t> type_support,
    ffi.Pointer<ffi.Int8> service_name,
    ffi.Pointer<rmw_qos_profile_t> qos_profile,
  ) {
    return (_rmw_create_service ??=
        _dylib.lookupFunction<_c_rmw_create_service, _dart_rmw_create_service>(
            'rmw_create_service'))(
      node,
      type_support,
      service_name,
      qos_profile,
    );
  }

  _dart_rmw_create_service? _rmw_create_service;

  /// /// Destroy and unregister a service server from its node.
  ///
  /// This function will reclaim all associated resources, including the service server itself.
  /// Use of a destroyed service server is undefined behavior.
  /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service server unchanged.
  /// Otherwise, it will proceed despite errors.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \pre Given `node` must be the one the service server was registered with.
  /// \pre Given `service` must be a valid service server, as returned by rmw_create_service().
  ///
  /// \param[in] node Node with which the given service server is registered.
  /// \param[in] service Service server to be destroyed.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `service` is `NULL`, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_destroy_service(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_service_t> service,
  ) {
    return (_rmw_destroy_service ??= _dylib.lookupFunction<
        _c_rmw_destroy_service,
        _dart_rmw_destroy_service>('rmw_destroy_service'))(
      node,
      service,
    );
  }

  _dart_rmw_destroy_service? _rmw_destroy_service;

  /// /// Take an incoming ROS service request.
  ///
  /// Take a ROS service request already received by the given service server, removing
  /// it from internal queues.
  /// The request header (i.e. its metadata), containing at least the writer guid and
  /// sequence number, is also retrieved.
  /// Both writer guid and sequence number allow callers to pair, for each remote service
  /// client, a ROS service request with its corresponding ROS service response, to be later
  /// sent using rmw_send_response().
  ///
  /// This function will succeed even if no ROS service request was received,
  /// but `taken` will be false.
  ///
  /// \remarks The same ROS service request cannot be taken twice.
  /// Callers do not have to deal with duplicates.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// Taking a ROS service request is a synchronous operation.
  /// It is also non-blocking, to the extent it will not wait for new ROS service requests
  /// to arrive, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on take or not.
  /// For instance, implementations that deserialize ROS service requests received over
  /// the wire may need to perform additional memory allocations when dealing with
  /// unbounded (dynamically-sized) fields.
  ///
  /// \par Thread-safety
  /// Service servers are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to take requests from the same service server concurrently.
  /// However:
  /// - Access to the given ROS service request is not synchronized.
  /// It is not safe to read or write `ros_request` while rmw_take_request() uses it.
  /// - Access to the given ROS service request header is not synchronized.
  /// It is not safe to read or write `request_header` while rmw_take_request() uses it.
  /// - Access to given primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `taken` while rmw_take_request() uses it.
  ///
  /// \pre Given `service` must be a valid service, as returned by rmw_create_service().
  /// \pre Given `ros_request` must be a valid service request, whose type matches the
  /// service type support registered with the `service` on creation.
  /// \post Given `ros_request` will remain a valid service request.
  /// It will be left unchanged if this function fails early due to a logical error, such as an
  /// invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
  /// It will also be left unchanged if this function succeeds but `taken` is false.
  ///
  /// \param[in] service Service server to take request from.
  /// \param[out] request_header Service request header to write to.
  /// \param[out] ros_request Type erased ROS service request to write to.
  /// \param[out] taken Boolean flag indicating if a ROS service request was taken or not.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_take_request(
    ffi.Pointer<rmw_service_t> service,
    ffi.Pointer<rmw_service_info_t> request_header,
    ffi.Pointer<ffi.Void> ros_request,
    ffi.Pointer<ffi.Uint8> taken,
  ) {
    return (_rmw_take_request ??=
        _dylib.lookupFunction<_c_rmw_take_request, _dart_rmw_take_request>(
            'rmw_take_request'))(
      service,
      request_header,
      ros_request,
      taken,
    );
  }

  _dart_rmw_take_request? _rmw_take_request;

  /// /// Send a ROS service response.
  ///
  /// Send a ROS service response to the service client, with matching QoS policies,
  /// from which the previously taken ROS service request was originally sent.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Runtime behavior
  /// It is implementation defined whether sending a ROS service response is a
  /// synchronous or asynchronous, and blocking or non-blocking, operation.
  /// However, asynchronous implementations are not allowed to access the
  /// given ROS service request after this function returns.
  /// Check the implementation documentation to learn about request behavior.
  ///
  /// \par Memory allocation
  /// It is implementation defined whether memory will be allocated on send or not.
  /// For instance, implementations that serialize ROS service responses may need to
  /// perform additional memory allocations when dealing with unbounded (dynamically-sized)
  /// fields.
  ///
  /// \par Thread-safety
  /// Service servers are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to send responses using the same service server concurrently.
  /// However:
  /// - Access to the given ROS service request header is read-only but it is not synchronized.
  /// Concurrent `request_header` reads are safe, but concurrent reads and writes are not.
  /// - Access to the given ROS service response is read-only but it is not synchronized.
  /// Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.
  ///
  /// \pre Given `service` must be a valid service server, as returned by rmw_create_service().
  /// \pre Given `request_header` must be the one previously taken along with the ROS service
  /// request to which we reply.
  /// \pre Given `ros_response` must be a valid service response, whose type matches the
  /// service type support registered with the `service` on creation.
  ///
  /// \param[in] client Service server to send a response with.
  /// \param[in] request_header Service response header, same as the one taken
  /// with the corresponding ROS service request.
  /// \param[in] ros_response ROS service response to be sent.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
  /// implementation identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_send_response(
    ffi.Pointer<rmw_service_t> service,
    ffi.Pointer<rmw_request_id_t> request_header,
    ffi.Pointer<ffi.Void> ros_response,
  ) {
    return (_rmw_send_response ??=
        _dylib.lookupFunction<_c_rmw_send_response, _dart_rmw_send_response>(
            'rmw_send_response'))(
      service,
      request_header,
      ros_response,
    );
  }

  _dart_rmw_send_response? _rmw_send_response;

  /// /// Create a guard condition and return a handle to that guard condition.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - context is `NULL`
  /// - context is invalid
  /// - memory allocation fails during guard condition creation
  /// - an unspecified error occurs
  ///
  /// The context must be non-null and valid, i.e. it has been initialized
  /// by `rmw_init()` and has not been finalized by `rmw_shutdown()`.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No [1]
  /// Lock-Free          | No [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// This should be defined by the rmw implementation.
  ///
  /// \param[in] context init context that this node should be associated with
  /// \return rmw guard condition handle or `NULL` if there was an error
  ffi.Pointer<rmw_guard_condition_t> rmw_create_guard_condition(
    ffi.Pointer<rmw_context_t> context,
  ) {
    return (_rmw_create_guard_condition ??= _dylib.lookupFunction<
        _c_rmw_create_guard_condition,
        _dart_rmw_create_guard_condition>('rmw_create_guard_condition'))(
      context,
    );
  }

  _dart_rmw_create_guard_condition? _rmw_create_guard_condition;

  /// /// Finalize a given guard condition handle, reclaim the resources, and deallocate the handle.
  ///
  /// \param[in] guard_condition the guard condition handle to be destroyed
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if guard_condition is null, or
  /// \return `RMW_RET_ERROR` if an unexpected error occurs.
  int rmw_destroy_guard_condition(
    ffi.Pointer<rmw_guard_condition_t> guard_condition,
  ) {
    return (_rmw_destroy_guard_condition ??= _dylib.lookupFunction<
        _c_rmw_destroy_guard_condition,
        _dart_rmw_destroy_guard_condition>('rmw_destroy_guard_condition'))(
      guard_condition,
    );
  }

  _dart_rmw_destroy_guard_condition? _rmw_destroy_guard_condition;

  int rmw_trigger_guard_condition(
    ffi.Pointer<rmw_guard_condition_t> guard_condition,
  ) {
    return (_rmw_trigger_guard_condition ??= _dylib.lookupFunction<
        _c_rmw_trigger_guard_condition,
        _dart_rmw_trigger_guard_condition>('rmw_trigger_guard_condition'))(
      guard_condition,
    );
  }

  _dart_rmw_trigger_guard_condition? _rmw_trigger_guard_condition;

  /// /// Create a wait set to store conditions that the middleware can wait on.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - context is `NULL`
  /// - context is zero initialized, as provided by rmw_get_zero_initialized_context()
  /// - context does not belong to this implementation i.e. does not have a matching
  /// implementation identifier
  /// - memory allocation fails during wait set creation
  /// - an unspecified error occurs
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \par Thread-safety
  /// Contexts are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is safe to create multiple wait sets in the same context concurrently.
  ///
  /// \pre Given `context` must be a valid context, initialized by rmw_init().
  ///
  /// \param[in] context Context to associate the wait set with.
  /// \param[in] max_conditions
  /// The maximum number of conditions that can be attached to, and stored by, the wait set.
  /// Can be set to zero (0) for the wait set to support an unbounded number of conditions.
  /// \return An rmw wait set, or `NULL` if an error occurred.
  ffi.Pointer<rmw_wait_set_t> rmw_create_wait_set(
    ffi.Pointer<rmw_context_t> context,
    int max_conditions,
  ) {
    return (_rmw_create_wait_set ??= _dylib.lookupFunction<
        _c_rmw_create_wait_set,
        _dart_rmw_create_wait_set>('rmw_create_wait_set'))(
      context,
      max_conditions,
    );
  }

  _dart_rmw_create_wait_set? _rmw_create_wait_set;

  /// /// Destroy a wait set.
  ///
  /// This function will reclaim all associated resources, including the wait set.
  /// Use of a wait set after destruction is undefined behavior.
  /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
  /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given wait set unchanged.
  /// Otherwise, it will proceed despite errors.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().
  ///
  /// \param[in] wait_set Wait set to be finalized.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_destroy_wait_set(
    ffi.Pointer<rmw_wait_set_t> wait_set,
  ) {
    return (_rmw_destroy_wait_set ??= _dylib.lookupFunction<
        _c_rmw_destroy_wait_set,
        _dart_rmw_destroy_wait_set>('rmw_destroy_wait_set'))(
      wait_set,
    );
  }

  _dart_rmw_destroy_wait_set? _rmw_destroy_wait_set;

  /// /// Waits on sets of different entities and returns when one is ready.
  ///
  /// This function adds middleware-specific conditions to the wait set and waits
  /// until one or more become ready, or until the timeout is reached.
  ///
  /// \remark Elapsed time is measured against the system clock.
  /// Timeout granularity is thus bound to that of the aforementioned clock and,
  /// depending on the underlying implementation, to that of platform-specific
  /// APIs to sleep and/or wait.
  ///
  /// \remark
  /// The amount of time this function actually waits may be either above or
  /// below the specified timeout.
  ///
  /// Arrays contain type-erased, middleware-specific conditions associated with
  /// waitable entities, which this function casts and adds to the wait set.
  /// `NULL` entries in arrays prior to wait are considered invalid.
  /// When the wait is over, entries in each array that correspond to
  /// conditions that were \b not triggered are set to `NULL`.
  ///
  /// \remark Arrays' memory management is external to this function.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Maybe [1]
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] rmw implementation defined, check the implementation documentation</i>
  ///
  /// \par Thread-safety
  /// To wait is a reentrant procedure, but:
  /// - It is not safe to use the same wait set to wait in two or more threads concurrently.
  /// - It is not safe to wait for the same entity using different wait sets in two or
  /// more threads concurrently.
  /// - Access to the given timeout is read-only but it is not synchronized.
  /// Concurrent `wait_timeout` reads are safe, but concurrent reads and writes are not.
  ///
  /// \pre Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().
  /// \pre All given entities must be associated with nodes that, in turn, were registered
  /// with the same context the given `wait_set` was registered with on creation.
  ///
  /// \param[inout] subscriptions Array of subscriptions to wait on.
  /// Can be `NULL` if there are no subscriptions to wait on.
  /// \param[inout] guard_conditions Array of guard conditions to wait on
  /// Can be `NULL` if there are no guard conditions to wait on.
  /// \param[inout] services Array of services to wait on.
  /// Can be `NULL` if there are no services to wait on.
  /// \param[inout] clients Array of clients to wait on.
  /// Can be `NULL` if there are no clients to wait on.
  /// \param[inout] events Array of events to wait on.
  /// Can be `NULL` if there are no events to wait on.
  /// \param[in] wait_set Wait set to use for waiting.
  /// \param[in] wait_timeout If `NULL`, block indefinitely until an entity becomes ready.
  /// If zero, do not block -- check only for immediately available entities.
  /// Else, this represents the maximum amount of time to wait for an entity to become ready.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_TIMEOUT` if wait timed out, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `wait_set` is `NULL`, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if an array entry is `NULL`, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_wait(
    ffi.Pointer<rmw_subscriptions_t> subscriptions,
    ffi.Pointer<rmw_guard_conditions_t> guard_conditions,
    ffi.Pointer<rmw_services_t> services,
    ffi.Pointer<rmw_clients_t> clients,
    ffi.Pointer<rmw_events_t> events,
    ffi.Pointer<rmw_wait_set_t> wait_set,
    ffi.Pointer<rmw_time_t> wait_timeout,
  ) {
    return (_rmw_wait ??=
        _dylib.lookupFunction<_c_rmw_wait, _dart_rmw_wait>('rmw_wait'))(
      subscriptions,
      guard_conditions,
      services,
      clients,
      events,
      wait_set,
      wait_timeout,
    );
  }

  _dart_rmw_wait? _rmw_wait;

  /// /// Return the name and namespace of all nodes in the ROS graph.
  ///
  /// This function will return an array of node names and an array of node namespaces,
  /// as discovered so far by the given node.
  /// The two arrays represent name and namespace pairs for each discovered node.
  /// Both arrays will be the same length and the same index will refer to the same node.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] implementation defined, check the implementation documentation</i>
  ///
  /// \par Runtime behavior
  /// To query the ROS graph is a synchronous operation.
  /// It is also non-blocking, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Thread-safety
  /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is safe to query the ROS graph using the same node concurrently.
  /// However, access to string arrays is not synchronized.
  /// It is not safe to read or write `node_names` nor `node_namespaces`
  /// while rmw_get_node_names() uses them.
  ///
  /// \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  /// \pre Given `node_names` must be a valid string array, zero-initialized
  /// as returned by rcutils_get_zero_initialized_string_array().
  /// \pre Given `node_namespaces` must be a valid string array, zero-initialized
  /// as returned by rcutils_get_zero_initialized_string_array().
  /// \post Given `node_names` and `node_namespaces` will remain valid arrays.
  /// These will be left unchanged if this function fails early due to a logical error,
  /// such as an invalid argument, or in an unknown yet valid state if it fails due to
  /// a runtime error.
  ///
  /// \param[in] node Node to query the ROS graph.
  /// \param[out] node_names Array of discovered node names, populated on success.
  /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  /// \param[out] node_namespaces Array of discovered node namespaces, populated on success.
  /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  /// \return `RMW_RET_OK` if the query was successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_get_node_names(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rcutils_string_array_t> node_names,
    ffi.Pointer<rcutils_string_array_t> node_namespaces,
  ) {
    return (_rmw_get_node_names ??=
        _dylib.lookupFunction<_c_rmw_get_node_names, _dart_rmw_get_node_names>(
            'rmw_get_node_names'))(
      node,
      node_names,
      node_namespaces,
    );
  }

  _dart_rmw_get_node_names? _rmw_get_node_names;

  /// /// Return the name, namespae, and enclave name of all nodes in the ROS graph.
  ///
  /// This is similar to rmw_get_node_names(), but it also provides enclave names.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] implementation defined, check the implementation documentation</i>
  ///
  /// \par Runtime behavior
  /// To query the ROS graph is a synchronous operation.
  /// It is also non-blocking, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Thread-safety
  /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is safe to query the ROS graph using the same node concurrently.
  /// However, access to string arrays is not synchronized.
  /// It is not safe to read or write `node_names`, `node_namespaces`, nor `enclaves`
  /// while rmw_get_node_names_with_enclaves() uses them.
  ///
  /// \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  /// \pre Given `node_names` must be a valid string array, zero-initialized
  /// as returned by rcutils_get_zero_initialized_string_array().
  /// \pre Given `node_namespaces` must be a valid string array, zero-initialized
  /// as returned by rcutils_get_zero_initialized_string_array().
  /// \pre Given `enclaves` must be a zero-initialized string array,
  /// as returned by rcutils_get_zero_initialized_string_array().
  /// \post Given `node_names`, `node_namespaces`, and `enclaves` will remain valid arrays.
  /// These will be left unchanged if this function fails early due to a logical error,
  /// such as an invalid argument, or in an unknown yet valid state if it fails due to
  /// a runtime error.
  ///
  /// \param[in] node Node to query the ROS graph.
  /// \param[out] node_names Array of discovered node names, populated on success.
  /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  /// \param[out] node_namespaces Array of discovered node namespaces, populated on success.
  /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  /// \param[out] enclaves Array of discovered node enclave names, populated on success.
  /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().
  /// \return `RMW_RET_OK` if the query was successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `enclaves` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `enclaves` is not a zero-initialized array, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_BAD_ALLOC` if memory allocation fails, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_get_node_names_with_enclaves(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rcutils_string_array_t> node_names,
    ffi.Pointer<rcutils_string_array_t> node_namespaces,
    ffi.Pointer<rcutils_string_array_t> enclaves,
  ) {
    return (_rmw_get_node_names_with_enclaves ??= _dylib.lookupFunction<
            _c_rmw_get_node_names_with_enclaves,
            _dart_rmw_get_node_names_with_enclaves>(
        'rmw_get_node_names_with_enclaves'))(
      node,
      node_names,
      node_namespaces,
      enclaves,
    );
  }

  _dart_rmw_get_node_names_with_enclaves? _rmw_get_node_names_with_enclaves;

  /// /// Count the number of known publishers matching a topic name.
  ///
  /// This function returns the numbers of publishers of a given topic in the ROS graph,
  /// as discovered so far by the given node.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] implementation defined, check the implementation documentation</i>
  ///
  /// \par Runtime behavior
  /// To query the ROS graph is a synchronous operation.
  /// It is also non-blocking, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Thread-safety
  /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is to query the ROS graph using the same node concurrently.
  /// However, access to primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `topic_name` or `count` while rmw_count_publishers()
  /// uses them.
  ///
  /// \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  ///
  /// \param[in] node Handle to node to use to query the ROS graph.
  /// \param[in] topic_name Fully qualified ROS topic name.
  /// \param[out] count Number of publishers matching the given topic name.
  /// \return `RMW_RET_OK` if the query was successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,
  /// by rmw_validate_full_topic_name() definition, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_count_publishers(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<ffi.Uint64> count,
  ) {
    return (_rmw_count_publishers ??= _dylib.lookupFunction<
        _c_rmw_count_publishers,
        _dart_rmw_count_publishers>('rmw_count_publishers'))(
      node,
      topic_name,
      count,
    );
  }

  _dart_rmw_count_publishers? _rmw_count_publishers;

  /// /// Count the number of known subscribers matching a topic name.
  ///
  /// This function returns the numbers of subscribers of a given topic in the ROS graph,
  /// as discovered so far by the given node.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  /// <i>[1] implementation defined, check the implementation documentation</i>
  ///
  /// \par Runtime behavior
  /// To query the ROS graph is a synchronous operation.
  /// It is also non-blocking, but it is not guaranteed to be lock-free.
  /// Generally speaking, implementations may synchronize access to internal resources using
  /// locks but are not allowed to wait for events with no guaranteed time bound (barring
  /// the effects of starvation due to OS scheduling).
  ///
  /// \par Thread-safety
  /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
  /// Therefore, it is to query the ROS graph using the same node concurrently.
  /// However, access to primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `topic_name` or `count` while rmw_count_subscribers()
  /// uses them.
  ///
  /// \pre Given `node` must be a valid node handle, as returned by rmw_create_node().
  ///
  /// \param[in] node Handle to node to use to query the ROS graph.
  /// \param[in] topic_name Fully qualified ROS topic name.
  /// \param[out] count Number of subscribers matching the given topic name.
  /// \return `RMW_RET_OK` if the query was successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,
  /// by rmw_validate_full_topic_name() definition, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_count_subscribers(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<ffi.Int8> topic_name,
    ffi.Pointer<ffi.Uint64> count,
  ) {
    return (_rmw_count_subscribers ??= _dylib.lookupFunction<
        _c_rmw_count_subscribers,
        _dart_rmw_count_subscribers>('rmw_count_subscribers'))(
      node,
      topic_name,
      count,
    );
  }

  _dart_rmw_count_subscribers? _rmw_count_subscribers;

  /// /// Get the unique identifier (gid) of a publisher.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Thread-safety
  /// Publishers are thread-safe objects, and so are all operations on them except for
  /// finalization.
  /// Therefore, it is safe to get the unique identifier from the same publisher concurrently.
  /// However, access to the gid is not synchronized.
  /// It is not safe to read or write `gid` while rmw_get_gid_for_publisher() uses it.
  ///
  /// \pre Given `publisher` must be a valid subscription, as returned by rmw_create_publisher().
  ///
  /// \param[in] publisher Publisher to get a gid from.
  /// \param[out] gid Publisher's unique identifier, populated on success
  /// but left unchanged on failure.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_get_gid_for_publisher(
    ffi.Pointer<rmw_publisher_t> publisher,
    ffi.Pointer<rmw_gid_t> gid,
  ) {
    return (_rmw_get_gid_for_publisher ??= _dylib.lookupFunction<
        _c_rmw_get_gid_for_publisher,
        _dart_rmw_get_gid_for_publisher>('rmw_get_gid_for_publisher'))(
      publisher,
      gid,
    );
  }

  _dart_rmw_get_gid_for_publisher? _rmw_get_gid_for_publisher;

  /// /// Check if two unique identifiers (gids) are equal.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Maybe [1]
  /// Lock-Free          | Maybe [1]
  ///
  /// <i>[1] implementation defined, check implementation documentation.</i>
  ///
  /// \par Thread-safety
  /// Unique identifier comparison is a reentrant function, but:
  /// - Access to both gids is read-only but it is not synchronized.
  /// Concurrent `gid1` and `gid2` reads are safe, but concurrent reads and writes are not.
  /// - Access to primitive data-type arguments is not synchronized.
  /// It is not safe to read or write `result` while rmw_compare_gids_equal() uses it.
  ///
  /// \param[in] gid1 First unique identifier to compare.
  /// \param[in] gid2 Second unique identifier to compare.
  /// \param[out] bool true if both gids are equal, false otherwise.
  /// \return `RMW_RET_OK` if successful, or
  /// \return `RMW_RET_INVALID_ARGUMENT` if `gid1` or `gid2` is NULL, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
  /// identifier of `gid1` or `gid2` does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_compare_gids_equal(
    ffi.Pointer<rmw_gid_t> gid1,
    ffi.Pointer<rmw_gid_t> gid2,
    ffi.Pointer<ffi.Uint8> result,
  ) {
    return (_rmw_compare_gids_equal ??= _dylib.lookupFunction<
        _c_rmw_compare_gids_equal,
        _dart_rmw_compare_gids_equal>('rmw_compare_gids_equal'))(
      gid1,
      gid2,
      result,
    );
  }

  _dart_rmw_compare_gids_equal? _rmw_compare_gids_equal;

  /// /// Check if a service server is available for the given service client.
  ///
  /// This function will return true for `is_available` if there is a service
  /// server available for the given client.
  ///
  /// The node parameter must not be `NULL`, and must point to a valid node.
  ///
  /// The client parameter must not be `NULL`, and must point to a valid client.
  ///
  /// The given client and node must match, i.e. the client must have been created
  /// using the given node.
  ///
  /// The is_available parameter must not be `NULL`, and must point to a bool
  /// variable.
  /// The result of the check will be stored in the is_available parameter.
  ///
  /// This function does manipulate heap memory.
  /// This function is not thread-safe.
  /// This function is lock-free.
  ///
  /// \param[in] node the handle to the node being used to query the ROS graph
  /// \param[in] client the handle to the service client being queried
  /// \param[out] is_available
  /// set to true if there is a service server available, else false
  /// \return `RMW_RET_OK` if node the check was made successfully, or
  /// \return `RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation
  /// identifier does not match this implementation, or
  /// \return `RMW_RET_ERROR` if an unspecified error occurs.
  int rmw_service_server_is_available(
    ffi.Pointer<rmw_node_t> node,
    ffi.Pointer<rmw_client_t> client,
    ffi.Pointer<ffi.Uint8> is_available,
  ) {
    return (_rmw_service_server_is_available ??= _dylib.lookupFunction<
            _c_rmw_service_server_is_available,
            _dart_rmw_service_server_is_available>(
        'rmw_service_server_is_available'))(
      node,
      client,
      is_available,
    );
  }

  _dart_rmw_service_server_is_available? _rmw_service_server_is_available;

  /// /// Set the current log severity
  ///
  /// \param[in] severity The log severity to set
  /// \return RMW_RET_OK if successful, otherwise an appropriate error code
  int rmw_set_log_severity(
    int severity,
  ) {
    return (_rmw_set_log_severity ??= _dylib.lookupFunction<
        _c_rmw_set_log_severity,
        _dart_rmw_set_log_severity>('rmw_set_log_severity'))(
      severity,
    );
  }

  _dart_rmw_set_log_severity? _rmw_set_log_severity;

  /// /// Return a zero initialized timer.
  rcl_timer_t rcl_get_zero_initialized_timer() {
    return (_rcl_get_zero_initialized_timer ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_timer,
            _dart_rcl_get_zero_initialized_timer>(
        'rcl_get_zero_initialized_timer'))();
  }

  _dart_rcl_get_zero_initialized_timer? _rcl_get_zero_initialized_timer;

  /// /// Initialize a timer.
  ///
  /// A timer consists of a clock, a callback function and a period.
  /// A timer can be added to a wait set and waited on, such that the wait set
  /// will wake up when a timer is ready to be executed.
  ///
  /// A timer simply holds state and does not automatically call callbacks.
  /// It does not create any threads, register interrupts, or consume signals.
  /// For blocking behavior it can be used in conjunction with a wait set and
  /// rcl_wait().
  /// When rcl_timer_is_ready() returns true, the timer must still be called
  /// explicitly using rcl_timer_call().
  ///
  /// The timer handle must be a pointer to an allocated and zero initialized
  /// rcl_timer_t struct.
  /// Calling this function on an already initialized timer will fail.
  /// Calling this function on a timer struct which has been allocated but not
  /// zero initialized is undefined behavior.
  ///
  /// The clock handle must be a pointer to an initialized rcl_clock_t struct.
  /// The life time of the clock must exceed the life time of the timer.
  ///
  /// The period is a non-negative duration (rather an absolute time in the
  /// future).
  /// If the period is `0` then it will always be ready.
  ///
  /// The callback is an optional argument.
  /// Valid inputs are either a pointer to the function callback, or `NULL` to
  /// indicate that no callback will be stored in rcl.
  /// If the callback is `NULL`, the caller client library is responsible for
  /// firing the timer callback.
  /// Else, it must be a function which returns void and takes two arguments,
  /// the first being a pointer to the associated timer, and the second a int64_t
  /// which is the time since the previous call, or since the timer was created
  /// if it is the first call to the callback.
  ///
  /// Expected usage:
  ///
  /// ```c
  /// #include <rcl/rcl.h>
  ///
  /// void my_timer_callback(rcl_timer_t * timer, int64_t last_call_time)
  /// {
  /// // Do timer work...
  /// // Optionally reconfigure, cancel, or reset the timer...
  /// }
  ///
  /// rcl_context_t * context;  // initialized previously by rcl_init()...
  /// rcl_clock_t clock;
  /// rcl_allocator_t allocator = rcl_get_default_allocator();
  /// rcl_ret_t ret = rcl_clock_init(RCL_STEADY_TIME, &clock, &allocator);
  /// // ... error handling
  ///
  /// rcl_timer_t timer = rcl_get_zero_initialized_timer();
  /// ret = rcl_timer_init(
  /// &timer, &clock, context, RCL_MS_TO_NS(100), my_timer_callback, allocator);
  /// // ... error handling, use the timer with a wait set, or poll it manually, then cleanup
  /// ret = rcl_timer_fini(&timer);
  /// // ... error handling
  /// ```
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1][2][3]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>
  ///
  /// <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///
  /// \param[inout] timer the timer handle to be initialized
  /// \param[in] clock the clock providing the current time
  /// \param[in] context the context that this timer is to be associated with
  /// \param[in] period the duration between calls to the callback in nanoseconds
  /// \param[in] callback the user defined function to be called every period
  /// \param[in] allocator the allocator to use for allocations
  /// \return `RCL_RET_OK` if the timer was initialized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ALREADY_INIT` if the timer was already initialized, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_init(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<rcl_clock_t> clock,
    ffi.Pointer<rcl_context_t> context,
    int period,
    ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> callback,
    rcutils_allocator_t allocator,
  ) {
    return (_rcl_timer_init ??=
        _dylib.lookupFunction<_c_rcl_timer_init, _dart_rcl_timer_init>(
            'rcl_timer_init'))(
      timer,
      clock,
      context,
      period,
      callback,
      allocator,
    );
  }

  _dart_rcl_timer_init? _rcl_timer_init;

  /// /// Finalize a timer.
  ///
  /// This function will deallocate any memory and make the timer invalid.
  ///
  /// A timer that is already invalid (zero initialized) or `NULL` will not fail.
  ///
  /// This function is not thread-safe with any rcl_timer_* functions used on the
  /// same timer object.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1][2][3]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`</i>
  ///
  /// <i>[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`</i>
  ///
  /// <i>[3] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///
  /// \param[inout] timer the handle to the timer to be finalized.
  /// \return `RCL_RET_OK` if the timer was finalized successfully, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_fini(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return (_rcl_timer_fini ??=
        _dylib.lookupFunction<_c_rcl_timer_fini, _dart_rcl_timer_fini>(
            'rcl_timer_fini'))(
      timer,
    );
  }

  _dart_rcl_timer_fini? _rcl_timer_fini;

  /// /// Call the timer's callback and set the last call time.
  ///
  /// This function will call the callback and change the last call time even if
  /// the timer's period has not yet elapsed.
  /// It is up to the calling code to make sure the period has elapsed by first
  /// calling rcl_timer_is_ready().
  /// If the callback pointer is `NULL` (either set in init or exchanged after
  /// initialized), no callback is fired.
  /// However, this function should still be called by the client library to
  /// update the state of the timer.
  /// The order of operations in this command are as follows:
  ///
  /// - Ensure the timer has not been canceled.
  /// - Get the current time into a temporary rcl_steady_time_point_t.
  /// - Exchange the current time with the last call time of the timer.
  /// - Call the callback, passing this timer and the time since the last call.
  /// - Return after the callback has completed.
  ///
  /// During the callback the timer can be canceled or have its period and/or
  /// callback modified.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes [1]
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [2]
  /// <i>[1] user callback might not be thread-safe</i>
  ///
  /// <i>[2] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[inout] timer the handle to the timer to call
  /// \return `RCL_RET_OK` if the timer was called successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  /// \return `RCL_RET_TIMER_CANCELED` if the timer has been canceled, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_call(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return (_rcl_timer_call ??=
        _dylib.lookupFunction<_c_rcl_timer_call, _dart_rcl_timer_call>(
            'rcl_timer_call'))(
      timer,
    );
  }

  _dart_rcl_timer_call? _rcl_timer_call;

  /// /// Retrieve the clock of the timer.
  ///
  /// This function retrieves the clock pointer and copies it into the given variable.
  ///
  /// The clock argument must be a pointer to an already allocated rcl_clock_t *.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] timer the handle to the timer which is being queried
  /// \param[out] clock the rcl_clock_t * in which the clock is stored
  /// \return `RCL_RET_OK` if the period was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_clock(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Pointer<rcl_clock_t>> clock,
  ) {
    return (_rcl_timer_clock ??=
        _dylib.lookupFunction<_c_rcl_timer_clock, _dart_rcl_timer_clock>(
            'rcl_timer_clock'))(
      timer,
      clock,
    );
  }

  _dart_rcl_timer_clock? _rcl_timer_clock;

  /// /// Calculates whether or not the timer should be called.
  ///
  /// The result is true if the time until next call is less than, or equal to, 0
  /// and the timer has not been canceled.
  /// Otherwise the result is false, indicating the timer should not be called.
  ///
  /// The is_ready argument must point to an allocated bool object, as the result
  /// is copied into it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[in] timer the handle to the timer which is being checked
  /// \param[out] is_ready the bool used to store the result of the calculation
  /// \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_is_ready(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Uint8> is_ready,
  ) {
    return (_rcl_timer_is_ready ??=
        _dylib.lookupFunction<_c_rcl_timer_is_ready, _dart_rcl_timer_is_ready>(
            'rcl_timer_is_ready'))(
      timer,
      is_ready,
    );
  }

  _dart_rcl_timer_is_ready? _rcl_timer_is_ready;

  /// /// Calculate and retrieve the time until the next call in nanoseconds.
  ///
  /// This function calculates the time until the next call by adding the timer's
  /// period to the last call time and subtracting that sum from the current time.
  /// The calculated time until the next call can be positive, indicating that it
  /// is not ready to be called as the period has not elapsed since the last call.
  /// The calculated time until the next call can also be 0 or negative,
  /// indicating that the period has elapsed since the last call and the timer
  /// should be called.
  /// A negative value indicates the timer call is overdue by that amount.
  ///
  /// The `time_until_next_call` argument must point to an allocated int64_t, as
  /// the time until is copied into that instance.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[in] timer the handle to the timer that is being queried
  /// \param[out] time_until_next_call the output variable for the result
  /// \return `RCL_RET_OK` if the timer until next call was successfully calculated, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_get_time_until_next_call(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> time_until_next_call,
  ) {
    return (_rcl_timer_get_time_until_next_call ??= _dylib.lookupFunction<
            _c_rcl_timer_get_time_until_next_call,
            _dart_rcl_timer_get_time_until_next_call>(
        'rcl_timer_get_time_until_next_call'))(
      timer,
      time_until_next_call,
    );
  }

  _dart_rcl_timer_get_time_until_next_call? _rcl_timer_get_time_until_next_call;

  /// /// Retrieve the time since the previous call to rcl_timer_call() occurred.
  ///
  /// This function calculates the time since the last call and copies it into
  /// the given int64_t variable.
  ///
  /// Calling this function within a callback will not return the time since the
  /// previous call but instead the time since the current callback was called.
  ///
  /// The time_since_last_call argument must be a pointer to an already allocated
  /// int64_t.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[in] timer the handle to the timer which is being queried
  /// \param[out] time_since_last_call the struct in which the time is stored
  /// \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_get_time_since_last_call(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> time_since_last_call,
  ) {
    return (_rcl_timer_get_time_since_last_call ??= _dylib.lookupFunction<
            _c_rcl_timer_get_time_since_last_call,
            _dart_rcl_timer_get_time_since_last_call>(
        'rcl_timer_get_time_since_last_call'))(
      timer,
      time_since_last_call,
    );
  }

  _dart_rcl_timer_get_time_since_last_call? _rcl_timer_get_time_since_last_call;

  /// /// Retrieve the period of the timer.
  ///
  /// This function retrieves the period and copies it into the given variable.
  ///
  /// The period argument must be a pointer to an already allocated int64_t.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[in] timer the handle to the timer which is being queried
  /// \param[out] period the int64_t in which the period is stored
  /// \return `RCL_RET_OK` if the period was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_get_period(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Int64> period,
  ) {
    return (_rcl_timer_get_period ??= _dylib.lookupFunction<
        _c_rcl_timer_get_period,
        _dart_rcl_timer_get_period>('rcl_timer_get_period'))(
      timer,
      period,
    );
  }

  _dart_rcl_timer_get_period? _rcl_timer_get_period;

  /// /// Exchange the period of the timer and return the previous period.
  ///
  /// This function exchanges the period in the timer and copies the old one into
  /// the given variable.
  ///
  /// Exchanging (changing) the period will not affect already waiting wait sets.
  ///
  /// The old_period argument must be a pointer to an already allocated int64_t.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[in] timer the handle to the timer which is being modified
  /// \param[out] new_period the int64_t to exchange into the timer
  /// \param[out] old_period the int64_t in which the previous period is stored
  /// \return `RCL_RET_OK` if the period was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_exchange_period(
    ffi.Pointer<rcl_timer_t> timer,
    int new_period,
    ffi.Pointer<ffi.Int64> old_period,
  ) {
    return (_rcl_timer_exchange_period ??= _dylib.lookupFunction<
        _c_rcl_timer_exchange_period,
        _dart_rcl_timer_exchange_period>('rcl_timer_exchange_period'))(
      timer,
      new_period,
      old_period,
    );
  }

  _dart_rcl_timer_exchange_period? _rcl_timer_exchange_period;

  /// /// Return the current timer callback.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - timer is `NULL`
  /// - timer has not been initialized (the implementation is invalid)
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[in] timer handle to the timer from the callback should be returned
  /// \return function pointer to the callback, or `NULL` if an error occurred
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> rcl_timer_get_callback(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return (_rcl_timer_get_callback ??= _dylib.lookupFunction<
        _c_rcl_timer_get_callback,
        _dart_rcl_timer_get_callback>('rcl_timer_get_callback'))(
      timer,
    );
  }

  _dart_rcl_timer_get_callback? _rcl_timer_get_callback;

  /// /// Exchange the current timer callback and return the current callback.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - timer is `NULL`
  /// - timer has not been initialized (the implementation is invalid)
  ///
  /// This function can set callback to `NULL`, in which case the callback is
  /// ignored when rcl_timer_call is called.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[inout] timer handle to the timer from the callback should be exchanged
  /// \param[in] new_callback the callback to be exchanged into the timer
  /// \return function pointer to the old callback, or `NULL` if an error occurred
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>>
      rcl_timer_exchange_callback(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> new_callback,
  ) {
    return (_rcl_timer_exchange_callback ??= _dylib.lookupFunction<
        _c_rcl_timer_exchange_callback,
        _dart_rcl_timer_exchange_callback>('rcl_timer_exchange_callback'))(
      timer,
      new_callback,
    );
  }

  _dart_rcl_timer_exchange_callback? _rcl_timer_exchange_callback;

  /// /// Cancel a timer.
  ///
  /// When a timer is canceled, rcl_timer_is_ready() will return false for that
  /// timer, and rcl_timer_call() will fail with RCL_RET_TIMER_CANCELED.
  ///
  /// A canceled timer can be reset with rcl_timer_reset(), and then used again.
  /// Calling this function on an already canceled timer will succeed.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[inout] timer the timer to be canceled
  /// \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_cancel(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return (_rcl_timer_cancel ??=
        _dylib.lookupFunction<_c_rcl_timer_cancel, _dart_rcl_timer_cancel>(
            'rcl_timer_cancel'))(
      timer,
    );
  }

  _dart_rcl_timer_cancel? _rcl_timer_cancel;

  /// /// Retrieve the canceled state of a timer.
  ///
  /// If the timer is canceled true will be stored in the is_canceled argument.
  /// Otherwise false will be stored in the is_canceled argument.
  ///
  /// The is_canceled argument must point to an allocated bool, as the result is
  /// copied into this variable.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_bool`</i>
  ///
  /// \param[in] timer the timer to be queried
  /// \param[out] is_canceled storage for the is canceled bool
  /// \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_is_canceled(
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Uint8> is_canceled,
  ) {
    return (_rcl_timer_is_canceled ??= _dylib.lookupFunction<
        _c_rcl_timer_is_canceled,
        _dart_rcl_timer_is_canceled>('rcl_timer_is_canceled'))(
      timer,
      is_canceled,
    );
  }

  _dart_rcl_timer_is_canceled? _rcl_timer_is_canceled;

  /// /// Reset a timer.
  ///
  /// This function can be called on a timer, canceled or not.
  /// For all timers it will reset the last call time to now.
  /// For canceled timers it will additionally make the timer not canceled.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | Yes
  /// Lock-Free          | Yes [1]
  /// <i>[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`</i>
  ///
  /// \param[inout] timer the timer to be reset
  /// \return `RCL_RET_OK` if the last call time was retrieved successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_TIMER_INVALID` if the timer is invalid, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_timer_reset(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return (_rcl_timer_reset ??=
        _dylib.lookupFunction<_c_rcl_timer_reset, _dart_rcl_timer_reset>(
            'rcl_timer_reset'))(
      timer,
    );
  }

  _dart_rcl_timer_reset? _rcl_timer_reset;

  /// /// Return the allocator for the timer.
  ///
  /// This function can fail, and therefore return `NULL`, if:
  /// - timer is `NULL`
  /// - timer has not been initialized (the implementation is invalid)
  ///
  /// The returned pointer is only valid as long as the timer object is valid.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | Yes
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] timer handle to the timer object
  /// \return pointer to the allocator, or `NULL` if an error occurred
  ffi.Pointer<rcutils_allocator_t> rcl_timer_get_allocator(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return (_rcl_timer_get_allocator ??= _dylib.lookupFunction<
        _c_rcl_timer_get_allocator,
        _dart_rcl_timer_get_allocator>('rcl_timer_get_allocator'))(
      timer,
    );
  }

  _dart_rcl_timer_get_allocator? _rcl_timer_get_allocator;

  /// /// Retrieve a guard condition used by the timer to wake the waitset when using ROSTime.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] timer the timer to be queried
  /// \return `NULL` if the timer is invalid or does not have a guard condition, or
  /// \return a guard condition pointer.
  ffi.Pointer<rcl_guard_condition_t> rcl_timer_get_guard_condition(
    ffi.Pointer<rcl_timer_t> timer,
  ) {
    return (_rcl_timer_get_guard_condition ??= _dylib.lookupFunction<
        _c_rcl_timer_get_guard_condition,
        _dart_rcl_timer_get_guard_condition>('rcl_timer_get_guard_condition'))(
      timer,
    );
  }

  _dart_rcl_timer_get_guard_condition? _rcl_timer_get_guard_condition;

  /// /// Return a rcl_event_t struct with members set to `NULL`.
  ///
  /// Should be called to get a null rcl_event_t before passing to
  /// rcl_event_init().
  rcl_event_t rcl_get_zero_initialized_event() {
    return (_rcl_get_zero_initialized_event ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_event,
            _dart_rcl_get_zero_initialized_event>(
        'rcl_get_zero_initialized_event'))();
  }

  _dart_rcl_get_zero_initialized_event? _rcl_get_zero_initialized_event;

  /// /// Initialize an rcl_event_t with a publisher.
  ///
  /// Fill the rcl_event_t with the publisher and desired event_type.
  ///
  /// \param[in,out] event pointer to fill
  /// \param[in] publisher to get events from
  /// \param[in] event_type to listen for
  /// \return `RCL_RET_OK` if the rcl_event_t is filled, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory fails, or
  /// \return `RCL_RET_UNSUPPORTED` if event_type is not supported, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_publisher_event_init(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<rcl_publisher_t> publisher,
    int event_type,
  ) {
    return (_rcl_publisher_event_init ??= _dylib.lookupFunction<
        _c_rcl_publisher_event_init,
        _dart_rcl_publisher_event_init>('rcl_publisher_event_init'))(
      event,
      publisher,
      event_type,
    );
  }

  _dart_rcl_publisher_event_init? _rcl_publisher_event_init;

  /// /// Initialize an rcl_event_t with a subscription.
  ///
  /// Fill the rcl_event_t with the subscription and desired event_type.
  ///
  /// \param[in,out] event pointer to fill
  /// \param[in] subscription to get events from
  /// \param[in] event_type to listen for
  /// \return `RCL_RET_OK` if the rcl_event_t is filled, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory fails, or
  /// \return `RCL_RET_UNSUPPORTED` if event_type is not supported, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_subscription_event_init(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<rcl_subscription_t> subscription,
    int event_type,
  ) {
    return (_rcl_subscription_event_init ??= _dylib.lookupFunction<
        _c_rcl_subscription_event_init,
        _dart_rcl_subscription_event_init>('rcl_subscription_event_init'))(
      event,
      subscription,
      event_type,
    );
  }

  _dart_rcl_subscription_event_init? _rcl_subscription_event_init;

  /// Take an event from the event handle.
  ///
  /// \param[in] event event object to take from
  /// \param[in, out] event_info event info object to write taken data into
  /// \return `RCL_RET_OK` if successful, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if memory allocation failed, or
  /// \return `RCL_RET_EVENT_TAKE_FAILED` if the take event failed, or
  /// \return `RCL_RET_ERROR` if an unexpected error occurs.
  int rcl_take_event(
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<ffi.Void> event_info,
  ) {
    return (_rcl_take_event ??=
        _dylib.lookupFunction<_c_rcl_take_event, _dart_rcl_take_event>(
            'rcl_take_event'))(
      event,
      event_info,
    );
  }

  _dart_rcl_take_event? _rcl_take_event;

  /// Finalize an event.
  ///
  /// \param[in] event to finalize
  /// \return `RCL_RET_OK` if successful, or
  /// \return `RCL_RET_EVENT_INVALID` if event is null, or
  /// \return `RCL_RET_ERROR` if an unexpected error occurs.
  int rcl_event_fini(
    ffi.Pointer<rcl_event_t> event,
  ) {
    return (_rcl_event_fini ??=
        _dylib.lookupFunction<_c_rcl_event_fini, _dart_rcl_event_fini>(
            'rcl_event_fini'))(
      event,
    );
  }

  _dart_rcl_event_fini? _rcl_event_fini;

  /// /// Return the rmw event handle.
  ///
  /// The handle returned is a pointer to the internally held rmw handle.
  /// This function can fail, and therefore return `NULL`, if the:
  /// - event is `NULL`
  /// - event is invalid (never called init, called fini, or invalid node)
  ///
  /// The returned handle is made invalid if the event is finalized or if
  /// rcl_shutdown() is called.
  /// The returned handle is not guaranteed to be valid for the life time of the
  /// event as it may be finalized and recreated itself.
  /// Therefore it is recommended to get the handle from the event using
  /// this function each time it is needed and avoid use of the handle
  /// concurrently with functions that might change it.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] event pointer to the rcl event
  /// \return rmw event handle if successful, otherwise `NULL`
  ffi.Pointer<rmw_event_t> rcl_event_get_rmw_handle(
    ffi.Pointer<rcl_event_t> event,
  ) {
    return (_rcl_event_get_rmw_handle ??= _dylib.lookupFunction<
        _c_rcl_event_get_rmw_handle,
        _dart_rcl_event_get_rmw_handle>('rcl_event_get_rmw_handle'))(
      event,
    );
  }

  _dart_rcl_event_get_rmw_handle? _rcl_event_get_rmw_handle;

  /// /// Return a rcl_wait_set_t struct with members set to `NULL`.
  rcl_wait_set_t rcl_get_zero_initialized_wait_set() {
    return (_rcl_get_zero_initialized_wait_set ??= _dylib.lookupFunction<
            _c_rcl_get_zero_initialized_wait_set,
            _dart_rcl_get_zero_initialized_wait_set>(
        'rcl_get_zero_initialized_wait_set'))();
  }

  _dart_rcl_get_zero_initialized_wait_set? _rcl_get_zero_initialized_wait_set;

  /// /// Initialize a rcl wait set with space for items to be waited on.
  ///
  /// This function allocates space for the subscriptions and other wait-able
  /// entities that can be stored in the wait set.
  /// It also sets the allocator to the given allocator and initializes the pruned
  /// member to be false.
  ///
  /// The wait_set struct should be allocated and initialized to `NULL`.
  /// If the wait_set is allocated but the memory is uninitialized the behavior is
  /// undefined.
  /// Calling this function on a wait set that has already been initialized will
  /// result in an error.
  /// A wait set can be reinitialized if rcl_wait_set_fini() was called on it.
  ///
  /// To use the default allocator use rcl_get_default_allocator().
  ///
  /// Expected usage:
  ///
  /// ```c
  /// #include <rcl/wait.h>
  ///
  /// rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
  /// rcl_ret_t ret =
  /// rcl_wait_set_init(&wait_set, 42, 42, 42, 42, 42, &context, rcl_get_default_allocator());
  /// // ... error handling, then use it, then call the matching fini:
  /// ret = rcl_wait_set_fini(&wait_set);
  /// // ... error handling
  /// ```
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] wait_set the wait set struct to be initialized
  /// \param[in] number_of_subscriptions non-zero size of the subscriptions set
  /// \param[in] number_of_guard_conditions non-zero size of the guard conditions set
  /// \param[in] number_of_timers non-zero size of the timers set
  /// \param[in] number_of_clients non-zero size of the clients set
  /// \param[in] number_of_services non-zero size of the services set
  /// \param[in] number_of_events non-zero size of the events set
  /// \param[in] context the context that the wait set should be associated with
  /// \param[in] allocator the allocator to use when allocating space in the sets
  /// \return `RCL_RET_OK` if the wait set is initialized successfully, or
  /// \return `RCL_RET_ALREADY_INIT` if the wait set is not zero initialized, or
  /// \return `RCL_RET_NOT_INIT` if the given context is invalid, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_WAIT_SET_INVALID` if the wait set is not destroyed properly, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_wait_set_init(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int number_of_subscriptions,
    int number_of_guard_conditions,
    int number_of_timers,
    int number_of_clients,
    int number_of_services,
    int number_of_events,
    ffi.Pointer<rcl_context_t> context,
    rcutils_allocator_t allocator,
  ) {
    return (_rcl_wait_set_init ??=
        _dylib.lookupFunction<_c_rcl_wait_set_init, _dart_rcl_wait_set_init>(
            'rcl_wait_set_init'))(
      wait_set,
      number_of_subscriptions,
      number_of_guard_conditions,
      number_of_timers,
      number_of_clients,
      number_of_services,
      number_of_events,
      context,
      allocator,
    );
  }

  _dart_rcl_wait_set_init? _rcl_wait_set_init;

  /// /// Finalize a rcl wait set.
  ///
  /// Deallocates any memory in the wait set that was allocated in
  /// rcl_wait_set_init() using the allocator given in the initialization.
  ///
  /// Calling this function on a zero initialized wait set will do nothing and
  /// return RCL_RET_OK.
  /// Calling this function on uninitialized memory results in undefined behavior.
  /// After calling this function the wait set will once again be zero initialized
  /// and so calling this function or rcl_wait_set_init() immediately after will
  /// succeed.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] wait_set the wait set struct to be finalized.
  /// \return `RCL_RET_OK` if the finalization was successful, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_WAIT_SET_INVALID` if the wait set is not destroyed properly, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_wait_set_fini(
    ffi.Pointer<rcl_wait_set_t> wait_set,
  ) {
    return (_rcl_wait_set_fini ??=
        _dylib.lookupFunction<_c_rcl_wait_set_fini, _dart_rcl_wait_set_fini>(
            'rcl_wait_set_fini'))(
      wait_set,
    );
  }

  _dart_rcl_wait_set_fini? _rcl_wait_set_fini;

  /// /// Retrieve the wait set's allocator.
  ///
  /// The allocator must be an allocated rcl_allocator_t struct, as the result is
  /// copied into this variable.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] wait_set the handle to the wait set
  /// \param[out] allocator the rcl_allocator_t struct to which the result is copied
  /// \return `RCL_RET_OK` if the allocator was successfully retrieved, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_WAIT_SET_INVALID` if the wait set is invalid, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_wait_set_get_allocator(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcutils_allocator_t> allocator,
  ) {
    return (_rcl_wait_set_get_allocator ??= _dylib.lookupFunction<
        _c_rcl_wait_set_get_allocator,
        _dart_rcl_wait_set_get_allocator>('rcl_wait_set_get_allocator'))(
      wait_set,
      allocator,
    );
  }

  _dart_rcl_wait_set_get_allocator? _rcl_wait_set_get_allocator;

  /// /// Store a pointer to the given subscription in the next empty spot in the set.
  ///
  /// This function does not guarantee that the subscription is not already in the
  /// wait set.
  ///
  /// Also add the rmw representation to the underlying rmw array and increment
  /// the rmw array count.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] wait_set struct in which the subscription is to be stored
  /// \param[in] subscription the subscription to be added to the wait set
  /// \param[out] index the index of the added subscription in the storage container.
  /// This parameter is optional and can be set to `NULL` to be ignored.
  /// \return `RCL_RET_OK` if added successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or
  /// \return `RCL_RET_WAIT_SET_FULL` if the subscription set is full, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_wait_set_add_subscription(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_subscription_t> subscription,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return (_rcl_wait_set_add_subscription ??= _dylib.lookupFunction<
        _c_rcl_wait_set_add_subscription,
        _dart_rcl_wait_set_add_subscription>('rcl_wait_set_add_subscription'))(
      wait_set,
      subscription,
      index,
    );
  }

  _dart_rcl_wait_set_add_subscription? _rcl_wait_set_add_subscription;

  /// /// Remove (sets to `NULL`) all entities in the wait set.
  ///
  /// This function should be used after passing using rcl_wait, but before
  /// adding new entities to the set.
  /// Sets all of the entries in the underlying rmw array to `NULL`, and sets the
  /// count in the rmw array to `0`.
  ///
  /// Calling this on an uninitialized (zero initialized) wait set will fail.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] wait_set struct to have its entities cleared
  /// \return `RCL_RET_OK` if cleared successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_wait_set_clear(
    ffi.Pointer<rcl_wait_set_t> wait_set,
  ) {
    return (_rcl_wait_set_clear ??=
        _dylib.lookupFunction<_c_rcl_wait_set_clear, _dart_rcl_wait_set_clear>(
            'rcl_wait_set_clear'))(
      wait_set,
    );
  }

  _dart_rcl_wait_set_clear? _rcl_wait_set_clear;

  /// /// Reallocate space for entities in the wait set.
  ///
  /// This function will deallocate and reallocate the memory for all entity sets.
  ///
  /// A size of 0 will just deallocate the memory and assign `NULL` to the array.
  ///
  /// Allocation and deallocation is done with the allocator given during the
  /// wait set's initialization.
  ///
  /// After calling this function all values in the set will be set to `NULL`,
  /// effectively the same as calling rcl_wait_set_clear().
  /// Similarly, the underlying rmw representation is reallocated and reset:
  /// all entries are set to `NULL` and the count is set to zero.
  ///
  /// If the requested size matches the current size, no allocation will be done.
  ///
  /// This can be called on an uninitialized (zero initialized) wait set.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | Yes
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[inout] wait_set struct to be resized
  /// \param[in] subscriptions_size a size for the new subscriptions set
  /// \param[in] guard_conditions_size a size for the new guard conditions set
  /// \param[in] timers_size a size for the new timers set
  /// \param[in] clients_size a size for the new clients set
  /// \param[in] services_size a size for the new services set
  /// \param[in] events_size a size for the new events set
  /// \return `RCL_RET_OK` if resized successfully, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_BAD_ALLOC` if allocating memory failed, or
  /// \return `RCL_RET_ERROR` if an unspecified error occurs.
  int rcl_wait_set_resize(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int subscriptions_size,
    int guard_conditions_size,
    int timers_size,
    int clients_size,
    int services_size,
    int events_size,
  ) {
    return (_rcl_wait_set_resize ??= _dylib.lookupFunction<
        _c_rcl_wait_set_resize,
        _dart_rcl_wait_set_resize>('rcl_wait_set_resize'))(
      wait_set,
      subscriptions_size,
      guard_conditions_size,
      timers_size,
      clients_size,
      services_size,
      events_size,
    );
  }

  _dart_rcl_wait_set_resize? _rcl_wait_set_resize;

  /// /// Store a pointer to the guard condition in the next empty spot in the set.
  ///
  /// This function behaves exactly the same as for subscriptions.
  /// \see rcl_wait_set_add_subscription
  int rcl_wait_set_add_guard_condition(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_guard_condition_t> guard_condition,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return (_rcl_wait_set_add_guard_condition ??= _dylib.lookupFunction<
            _c_rcl_wait_set_add_guard_condition,
            _dart_rcl_wait_set_add_guard_condition>(
        'rcl_wait_set_add_guard_condition'))(
      wait_set,
      guard_condition,
      index,
    );
  }

  _dart_rcl_wait_set_add_guard_condition? _rcl_wait_set_add_guard_condition;

  /// /// Store a pointer to the timer in the next empty spot in the set.
  ///
  /// This function behaves exactly the same as for subscriptions.
  /// \see rcl_wait_set_add_subscription
  int rcl_wait_set_add_timer(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_timer_t> timer,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return (_rcl_wait_set_add_timer ??= _dylib.lookupFunction<
        _c_rcl_wait_set_add_timer,
        _dart_rcl_wait_set_add_timer>('rcl_wait_set_add_timer'))(
      wait_set,
      timer,
      index,
    );
  }

  _dart_rcl_wait_set_add_timer? _rcl_wait_set_add_timer;

  /// /// Store a pointer to the client in the next empty spot in the set.
  ///
  /// This function behaves exactly the same as for subscriptions.
  /// \see rcl_wait_set_add_subscription
  int rcl_wait_set_add_client(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_client_t> client,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return (_rcl_wait_set_add_client ??= _dylib.lookupFunction<
        _c_rcl_wait_set_add_client,
        _dart_rcl_wait_set_add_client>('rcl_wait_set_add_client'))(
      wait_set,
      client,
      index,
    );
  }

  _dart_rcl_wait_set_add_client? _rcl_wait_set_add_client;

  /// /// Store a pointer to the service in the next empty spot in the set.
  ///
  /// This function behaves exactly the same as for subscriptions.
  /// \see rcl_wait_set_add_subscription
  int rcl_wait_set_add_service(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_service_t> service,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return (_rcl_wait_set_add_service ??= _dylib.lookupFunction<
        _c_rcl_wait_set_add_service,
        _dart_rcl_wait_set_add_service>('rcl_wait_set_add_service'))(
      wait_set,
      service,
      index,
    );
  }

  _dart_rcl_wait_set_add_service? _rcl_wait_set_add_service;

  /// /// Store a pointer to the event in the next empty spot in the set.
  ///
  /// This function behaves exactly the same as for subscriptions.
  /// \see rcl_wait_set_add_subscription
  int rcl_wait_set_add_event(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    ffi.Pointer<rcl_event_t> event,
    ffi.Pointer<ffi.Uint64> index,
  ) {
    return (_rcl_wait_set_add_event ??= _dylib.lookupFunction<
        _c_rcl_wait_set_add_event,
        _dart_rcl_wait_set_add_event>('rcl_wait_set_add_event'))(
      wait_set,
      event,
      index,
    );
  }

  _dart_rcl_wait_set_add_event? _rcl_wait_set_add_event;

  /// /// Block until the wait set is ready or until the timeout has been exceeded.
  ///
  /// This function will collect the items in the rcl_wait_set_t and pass them
  /// to the underlying rmw_wait function.
  ///
  /// The items in the wait set will be either left untouched or set to `NULL` after
  /// this function returns.
  /// Items that are not `NULL` are ready, where ready means different things based
  /// on the type of the item.
  /// For subscriptions this means there may be messages that can be taken, or
  /// perhaps that the state of the subscriptions has changed, in which case
  /// rcl_take may succeed but return with taken == false.
  /// For guard conditions this means the guard condition was triggered.
  ///
  /// Expected usage:
  ///
  /// ```c
  /// #include <rcl/rcl.h>
  ///
  /// // rcl_init() called successfully before here...
  /// rcl_node_t node;  // initialize this, see rcl_node_init()
  /// rcl_subscription_t sub1;  // initialize this, see rcl_subscription_init()
  /// rcl_subscription_t sub2;  // initialize this, see rcl_subscription_init()
  /// rcl_guard_condition_t gc1;  // initialize this, see rcl_guard_condition_init()
  /// rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
  /// rcl_ret_t ret = rcl_wait_set_init(&wait_set, 2, 1, 0, 0, 0, rcl_get_default_allocator());
  /// // ... error handling
  /// do {
  /// ret = rcl_wait_set_clear(&wait_set);
  /// // ... error handling
  /// ret = rcl_wait_set_add_subscription(&wait_set, &sub1);
  /// // ... error handling
  /// ret = rcl_wait_set_add_subscription(&wait_set, &sub2);
  /// // ... error handling
  /// ret = rcl_wait_set_add_guard_condition(&wait_set, &gc1);
  /// // ... error handling
  /// ret = rcl_wait(&wait_set, RCL_MS_TO_NS(1000));  // 1000ms == 1s, passed as ns
  /// if (ret == RCL_RET_TIMEOUT) {
  /// continue;
  /// }
  /// for (int i = 0; i < wait_set.size_of_subscriptions; ++i) {
  /// if (wait_set.subscriptions[i]) {
  /// // The subscription is ready...
  /// }
  /// }
  /// for (int i = 0; i < wait_set.size_of_guard_conditions; ++i) {
  /// if (wait_set.guard_conditions[i]) {
  /// // The subscription is ready...
  /// }
  /// }
  /// } while(check_some_condition());
  /// // ... fini node, and subscriptions and guard conditions...
  /// ret = rcl_wait_set_fini(&wait_set);
  /// // ... error handling
  /// ```
  ///
  /// The wait set struct must be allocated, initialized, and should have been
  /// cleared and then filled with items, e.g. subscriptions and guard conditions.
  /// Passing a wait set with no wait-able items in it will fail.
  /// `NULL` items in the sets are ignored, e.g. it is valid to have as input:
  /// - `subscriptions[0]` = valid pointer
  /// - `subscriptions[1]` = `NULL`
  /// - `subscriptions[2]` = valid pointer
  /// - `size_of_subscriptions` = 3
  /// Passing an uninitialized (zero initialized) wait set struct will fail.
  /// Passing a wait set struct with uninitialized memory is undefined behavior.
  ///
  /// The unit of timeout is nanoseconds.
  /// If the timeout is negative then this function will block indefinitely until
  /// something in the wait set is valid or it is interrupted.
  /// If the timeout is 0 then this function will be non-blocking; checking what's
  /// ready now, but not waiting if nothing is ready yet.
  /// If the timeout is greater than 0 then this function will return after
  /// that period of time has elapsed or the wait set becomes ready, which ever
  /// comes first.
  /// Passing a timeout struct with uninitialized memory is undefined behavior.
  ///
  /// This function is thread-safe for unique wait sets with unique contents.
  /// This function cannot operate on the same wait set in multiple threads, and
  /// the wait sets may not share content.
  /// For example, calling rcl_wait() in two threads on two different wait sets
  /// that both contain a single, shared guard condition is undefined behavior.
  ///
  /// \param[inout] wait_set the set of things to be waited on and to be pruned if not ready
  /// \param[in] timeout the duration to wait for the wait set to be ready, in nanoseconds
  /// \return `RCL_RET_OK` something in the wait set became ready, or
  /// \return `RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or
  /// \return `RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or
  /// \return `RCL_RET_WAIT_SET_EMPTY` if the wait set contains no items, or
  /// \return `RCL_RET_TIMEOUT` if the timeout expired before something was ready, or
  /// \return `RCL_RET_ERROR` an unspecified error occur.
  int rcl_wait(
    ffi.Pointer<rcl_wait_set_t> wait_set,
    int timeout,
  ) {
    return (_rcl_wait ??=
        _dylib.lookupFunction<_c_rcl_wait, _dart_rcl_wait>('rcl_wait'))(
      wait_set,
      timeout,
    );
  }

  _dart_rcl_wait? _rcl_wait;

  /// /// Return `true` if the wait set is valid, else `false`.
  ///
  /// A wait set is invalid if:
  /// - the implementation is `NULL` (rcl_wait_set_init not called or failed)
  /// - the wait set has been finalized with rcl_wait_set_fini
  ///
  /// Also return `false` if the wait set pointer is `NULL`.
  ///
  /// <hr>
  /// Attribute          | Adherence
  /// ------------------ | -------------
  /// Allocates Memory   | No
  /// Thread-Safe        | No
  /// Uses Atomics       | No
  /// Lock-Free          | Yes
  ///
  /// \param[in] wait_set the rcl_wait_set_t to be validated
  /// \return `true` if the wait_set is valid, otherwise `false`.
  bool rcl_wait_set_is_valid(
    ffi.Pointer<rcl_wait_set_t> wait_set,
  ) {
    return (_rcl_wait_set_is_valid ??= _dylib.lookupFunction<
            _c_rcl_wait_set_is_valid,
            _dart_rcl_wait_set_is_valid>('rcl_wait_set_is_valid'))(
          wait_set,
        ) !=
        0;
  }

  _dart_rcl_wait_set_is_valid? _rcl_wait_set_is_valid;
}

/// /// Encapsulation of an allocator.
///
/// The default allocator uses malloc(), free(), calloc(), and realloc().
/// It can be obtained using rcutils_get_default_allocator().
///
/// The allocator should be trivially copyable.
/// Meaning that the struct should continue to work after being assignment
/// copied into a new struct.
/// Specifically the object pointed to by the state pointer should remain valid
/// until all uses of the allocator have been made.
/// Particular care should be taken when giving an allocator to functions like
/// rcutils_*_init() where it is stored within another object and used later.
/// Developers should note that, while the fields of a const-qualified allocator
/// struct cannot be modified, the state of the allocator can be modified.
class rcutils_allocator_t extends ffi.Struct {
  /// /// Allocate memory, given a size and the `state` pointer.
  /// An error should be indicated by returning `NULL`.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_1>> allocate;

  /// /// Deallocate previously allocated memory, mimicking free().
  /// Also takes the `state` pointer.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_2>> deallocate;

  /// /// Reallocate if possible, otherwise it deallocates and allocates.
  ///
  /// Also takes the `state` pointer.
  ///
  /// If unsupported then do deallocate and then allocate.
  /// This should behave as realloc() does, as opposed to posix's
  /// [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given
  /// by pointer will not be free'd automatically if realloc() fails.
  /// For reallocf-like behavior use rcutils_reallocf().
  /// This function must be able to take an input pointer of `NULL` and succeed.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_3>> reallocate;

  /// /// Allocate memory with all elements set to zero, given a number of elements and their size.
  /// An error should be indicated by returning `NULL`.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_4>> zero_allocate;

  /// /// Implementation defined state storage.
  ///
  /// This is passed as the final parameter to other allocator functions.
  /// Note that the contents of the state can be modified even in const-qualified
  /// allocator objects.
  external ffi.Pointer<ffi.Void> state;
}

/// /// Used to specify if the context can only communicate through localhost.
abstract class rmw_localhost_only_t {
  /// /// Uses ROS_LOCALHOST_ONLY environment variable.
  static const int RMW_LOCALHOST_ONLY_DEFAULT = 0;

  /// /// Forces using only localhost.
  static const int RMW_LOCALHOST_ONLY_ENABLED = 1;

  /// /// Forces disabling localhost only.
  static const int RMW_LOCALHOST_ONLY_DISABLED = 2;
}

abstract class rmw_security_enforcement_policy_t {
  static const int RMW_SECURITY_ENFORCEMENT_PERMISSIVE = 0;
  static const int RMW_SECURITY_ENFORCEMENT_ENFORCE = 1;
}

class rmw_security_options_t extends ffi.Struct {
  @ffi.Int32()
  external int enforce_security;

  external ffi.Pointer<ffi.Int8> security_root_path;
}

class rmw_init_options_impl_t extends ffi.Struct {}

/// /// Options structure used during rmw_init().
class rmw_init_options_t extends ffi.Struct {
  /// /// Locally (process local) unique ID that represents this init/shutdown cycle.
  ///
  /// This should be set by the caller of `rmw_init()` to a number that is
  /// unique within this process.
  /// It is designed to be used with `rcl_init()` and `rcl_get_instance_id()`.
  @ffi.Uint64()
  external int instance_id;

  /// /// Implementation identifier, used to ensure two different implementations are not being mixed.
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// ROS domain id
  @ffi.Uint64()
  external int domain_id;

  /// /// Security options
  external rmw_security_options_t security_options;

  /// /// Enable localhost only
  @ffi.Int32()
  external int localhost_only;

  /// /// Enclave, name used to find security artifacts in a sros2 keystore.
  external ffi.Pointer<ffi.Int8> enclave;

  /// /// Allocator used during internal allocation of init options, if needed.
  external rcutils_allocator_t allocator;

  /// /// Implementation defined init options.
  /// May be NULL if there are no implementation defined options.
  external ffi.Pointer<rmw_init_options_impl_t> impl;
}

class rmw_context_impl_t extends ffi.Struct {}

/// /// Initialization context structure which is used to store init specific information.
class rmw_context_t extends ffi.Struct {
  /// /// Locally (process local) unique ID that represents this init/shutdown cycle.
  @ffi.Uint64()
  external int instance_id;

  /// /// Implementation identifier, used to ensure two different implementations are not being mixed.
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Options used to initialize the context.
  external rmw_init_options_t options;

  /// /// Implementation defined context information.
  /// May be NULL if there is no implementation defined context information.
  external ffi.Pointer<rmw_context_impl_t> impl;
}

class __va_list_tag extends ffi.Struct {
  @ffi.Uint32()
  external int gp_offset;

  @ffi.Uint32()
  external int fp_offset;

  external ffi.Pointer<ffi.Void> overflow_arg_area;

  external ffi.Pointer<ffi.Void> reg_save_area;
}

/// /// Struct wrapping a fixed-size c string used for returning the formatted error string.
class rcutils_error_string_t extends ffi.Struct {
  @ffi.Int8()
  external int _unique_str_item_0;
  @ffi.Int8()
  external int _unique_str_item_1;
  @ffi.Int8()
  external int _unique_str_item_2;
  @ffi.Int8()
  external int _unique_str_item_3;
  @ffi.Int8()
  external int _unique_str_item_4;
  @ffi.Int8()
  external int _unique_str_item_5;
  @ffi.Int8()
  external int _unique_str_item_6;
  @ffi.Int8()
  external int _unique_str_item_7;
  @ffi.Int8()
  external int _unique_str_item_8;
  @ffi.Int8()
  external int _unique_str_item_9;
  @ffi.Int8()
  external int _unique_str_item_10;
  @ffi.Int8()
  external int _unique_str_item_11;
  @ffi.Int8()
  external int _unique_str_item_12;
  @ffi.Int8()
  external int _unique_str_item_13;
  @ffi.Int8()
  external int _unique_str_item_14;
  @ffi.Int8()
  external int _unique_str_item_15;
  @ffi.Int8()
  external int _unique_str_item_16;
  @ffi.Int8()
  external int _unique_str_item_17;
  @ffi.Int8()
  external int _unique_str_item_18;
  @ffi.Int8()
  external int _unique_str_item_19;
  @ffi.Int8()
  external int _unique_str_item_20;
  @ffi.Int8()
  external int _unique_str_item_21;
  @ffi.Int8()
  external int _unique_str_item_22;
  @ffi.Int8()
  external int _unique_str_item_23;
  @ffi.Int8()
  external int _unique_str_item_24;
  @ffi.Int8()
  external int _unique_str_item_25;
  @ffi.Int8()
  external int _unique_str_item_26;
  @ffi.Int8()
  external int _unique_str_item_27;
  @ffi.Int8()
  external int _unique_str_item_28;
  @ffi.Int8()
  external int _unique_str_item_29;
  @ffi.Int8()
  external int _unique_str_item_30;
  @ffi.Int8()
  external int _unique_str_item_31;
  @ffi.Int8()
  external int _unique_str_item_32;
  @ffi.Int8()
  external int _unique_str_item_33;
  @ffi.Int8()
  external int _unique_str_item_34;
  @ffi.Int8()
  external int _unique_str_item_35;
  @ffi.Int8()
  external int _unique_str_item_36;
  @ffi.Int8()
  external int _unique_str_item_37;
  @ffi.Int8()
  external int _unique_str_item_38;
  @ffi.Int8()
  external int _unique_str_item_39;
  @ffi.Int8()
  external int _unique_str_item_40;
  @ffi.Int8()
  external int _unique_str_item_41;
  @ffi.Int8()
  external int _unique_str_item_42;
  @ffi.Int8()
  external int _unique_str_item_43;
  @ffi.Int8()
  external int _unique_str_item_44;
  @ffi.Int8()
  external int _unique_str_item_45;
  @ffi.Int8()
  external int _unique_str_item_46;
  @ffi.Int8()
  external int _unique_str_item_47;
  @ffi.Int8()
  external int _unique_str_item_48;
  @ffi.Int8()
  external int _unique_str_item_49;
  @ffi.Int8()
  external int _unique_str_item_50;
  @ffi.Int8()
  external int _unique_str_item_51;
  @ffi.Int8()
  external int _unique_str_item_52;
  @ffi.Int8()
  external int _unique_str_item_53;
  @ffi.Int8()
  external int _unique_str_item_54;
  @ffi.Int8()
  external int _unique_str_item_55;
  @ffi.Int8()
  external int _unique_str_item_56;
  @ffi.Int8()
  external int _unique_str_item_57;
  @ffi.Int8()
  external int _unique_str_item_58;
  @ffi.Int8()
  external int _unique_str_item_59;
  @ffi.Int8()
  external int _unique_str_item_60;
  @ffi.Int8()
  external int _unique_str_item_61;
  @ffi.Int8()
  external int _unique_str_item_62;
  @ffi.Int8()
  external int _unique_str_item_63;
  @ffi.Int8()
  external int _unique_str_item_64;
  @ffi.Int8()
  external int _unique_str_item_65;
  @ffi.Int8()
  external int _unique_str_item_66;
  @ffi.Int8()
  external int _unique_str_item_67;
  @ffi.Int8()
  external int _unique_str_item_68;
  @ffi.Int8()
  external int _unique_str_item_69;
  @ffi.Int8()
  external int _unique_str_item_70;
  @ffi.Int8()
  external int _unique_str_item_71;
  @ffi.Int8()
  external int _unique_str_item_72;
  @ffi.Int8()
  external int _unique_str_item_73;
  @ffi.Int8()
  external int _unique_str_item_74;
  @ffi.Int8()
  external int _unique_str_item_75;
  @ffi.Int8()
  external int _unique_str_item_76;
  @ffi.Int8()
  external int _unique_str_item_77;
  @ffi.Int8()
  external int _unique_str_item_78;
  @ffi.Int8()
  external int _unique_str_item_79;
  @ffi.Int8()
  external int _unique_str_item_80;
  @ffi.Int8()
  external int _unique_str_item_81;
  @ffi.Int8()
  external int _unique_str_item_82;
  @ffi.Int8()
  external int _unique_str_item_83;
  @ffi.Int8()
  external int _unique_str_item_84;
  @ffi.Int8()
  external int _unique_str_item_85;
  @ffi.Int8()
  external int _unique_str_item_86;
  @ffi.Int8()
  external int _unique_str_item_87;
  @ffi.Int8()
  external int _unique_str_item_88;
  @ffi.Int8()
  external int _unique_str_item_89;
  @ffi.Int8()
  external int _unique_str_item_90;
  @ffi.Int8()
  external int _unique_str_item_91;
  @ffi.Int8()
  external int _unique_str_item_92;
  @ffi.Int8()
  external int _unique_str_item_93;
  @ffi.Int8()
  external int _unique_str_item_94;
  @ffi.Int8()
  external int _unique_str_item_95;
  @ffi.Int8()
  external int _unique_str_item_96;
  @ffi.Int8()
  external int _unique_str_item_97;
  @ffi.Int8()
  external int _unique_str_item_98;
  @ffi.Int8()
  external int _unique_str_item_99;
  @ffi.Int8()
  external int _unique_str_item_100;
  @ffi.Int8()
  external int _unique_str_item_101;
  @ffi.Int8()
  external int _unique_str_item_102;
  @ffi.Int8()
  external int _unique_str_item_103;
  @ffi.Int8()
  external int _unique_str_item_104;
  @ffi.Int8()
  external int _unique_str_item_105;
  @ffi.Int8()
  external int _unique_str_item_106;
  @ffi.Int8()
  external int _unique_str_item_107;
  @ffi.Int8()
  external int _unique_str_item_108;
  @ffi.Int8()
  external int _unique_str_item_109;
  @ffi.Int8()
  external int _unique_str_item_110;
  @ffi.Int8()
  external int _unique_str_item_111;
  @ffi.Int8()
  external int _unique_str_item_112;
  @ffi.Int8()
  external int _unique_str_item_113;
  @ffi.Int8()
  external int _unique_str_item_114;
  @ffi.Int8()
  external int _unique_str_item_115;
  @ffi.Int8()
  external int _unique_str_item_116;
  @ffi.Int8()
  external int _unique_str_item_117;
  @ffi.Int8()
  external int _unique_str_item_118;
  @ffi.Int8()
  external int _unique_str_item_119;
  @ffi.Int8()
  external int _unique_str_item_120;
  @ffi.Int8()
  external int _unique_str_item_121;
  @ffi.Int8()
  external int _unique_str_item_122;
  @ffi.Int8()
  external int _unique_str_item_123;
  @ffi.Int8()
  external int _unique_str_item_124;
  @ffi.Int8()
  external int _unique_str_item_125;
  @ffi.Int8()
  external int _unique_str_item_126;
  @ffi.Int8()
  external int _unique_str_item_127;
  @ffi.Int8()
  external int _unique_str_item_128;
  @ffi.Int8()
  external int _unique_str_item_129;
  @ffi.Int8()
  external int _unique_str_item_130;
  @ffi.Int8()
  external int _unique_str_item_131;
  @ffi.Int8()
  external int _unique_str_item_132;
  @ffi.Int8()
  external int _unique_str_item_133;
  @ffi.Int8()
  external int _unique_str_item_134;
  @ffi.Int8()
  external int _unique_str_item_135;
  @ffi.Int8()
  external int _unique_str_item_136;
  @ffi.Int8()
  external int _unique_str_item_137;
  @ffi.Int8()
  external int _unique_str_item_138;
  @ffi.Int8()
  external int _unique_str_item_139;
  @ffi.Int8()
  external int _unique_str_item_140;
  @ffi.Int8()
  external int _unique_str_item_141;
  @ffi.Int8()
  external int _unique_str_item_142;
  @ffi.Int8()
  external int _unique_str_item_143;
  @ffi.Int8()
  external int _unique_str_item_144;
  @ffi.Int8()
  external int _unique_str_item_145;
  @ffi.Int8()
  external int _unique_str_item_146;
  @ffi.Int8()
  external int _unique_str_item_147;
  @ffi.Int8()
  external int _unique_str_item_148;
  @ffi.Int8()
  external int _unique_str_item_149;
  @ffi.Int8()
  external int _unique_str_item_150;
  @ffi.Int8()
  external int _unique_str_item_151;
  @ffi.Int8()
  external int _unique_str_item_152;
  @ffi.Int8()
  external int _unique_str_item_153;
  @ffi.Int8()
  external int _unique_str_item_154;
  @ffi.Int8()
  external int _unique_str_item_155;
  @ffi.Int8()
  external int _unique_str_item_156;
  @ffi.Int8()
  external int _unique_str_item_157;
  @ffi.Int8()
  external int _unique_str_item_158;
  @ffi.Int8()
  external int _unique_str_item_159;
  @ffi.Int8()
  external int _unique_str_item_160;
  @ffi.Int8()
  external int _unique_str_item_161;
  @ffi.Int8()
  external int _unique_str_item_162;
  @ffi.Int8()
  external int _unique_str_item_163;
  @ffi.Int8()
  external int _unique_str_item_164;
  @ffi.Int8()
  external int _unique_str_item_165;
  @ffi.Int8()
  external int _unique_str_item_166;
  @ffi.Int8()
  external int _unique_str_item_167;
  @ffi.Int8()
  external int _unique_str_item_168;
  @ffi.Int8()
  external int _unique_str_item_169;
  @ffi.Int8()
  external int _unique_str_item_170;
  @ffi.Int8()
  external int _unique_str_item_171;
  @ffi.Int8()
  external int _unique_str_item_172;
  @ffi.Int8()
  external int _unique_str_item_173;
  @ffi.Int8()
  external int _unique_str_item_174;
  @ffi.Int8()
  external int _unique_str_item_175;
  @ffi.Int8()
  external int _unique_str_item_176;
  @ffi.Int8()
  external int _unique_str_item_177;
  @ffi.Int8()
  external int _unique_str_item_178;
  @ffi.Int8()
  external int _unique_str_item_179;
  @ffi.Int8()
  external int _unique_str_item_180;
  @ffi.Int8()
  external int _unique_str_item_181;
  @ffi.Int8()
  external int _unique_str_item_182;
  @ffi.Int8()
  external int _unique_str_item_183;
  @ffi.Int8()
  external int _unique_str_item_184;
  @ffi.Int8()
  external int _unique_str_item_185;
  @ffi.Int8()
  external int _unique_str_item_186;
  @ffi.Int8()
  external int _unique_str_item_187;
  @ffi.Int8()
  external int _unique_str_item_188;
  @ffi.Int8()
  external int _unique_str_item_189;
  @ffi.Int8()
  external int _unique_str_item_190;
  @ffi.Int8()
  external int _unique_str_item_191;
  @ffi.Int8()
  external int _unique_str_item_192;
  @ffi.Int8()
  external int _unique_str_item_193;
  @ffi.Int8()
  external int _unique_str_item_194;
  @ffi.Int8()
  external int _unique_str_item_195;
  @ffi.Int8()
  external int _unique_str_item_196;
  @ffi.Int8()
  external int _unique_str_item_197;
  @ffi.Int8()
  external int _unique_str_item_198;
  @ffi.Int8()
  external int _unique_str_item_199;
  @ffi.Int8()
  external int _unique_str_item_200;
  @ffi.Int8()
  external int _unique_str_item_201;
  @ffi.Int8()
  external int _unique_str_item_202;
  @ffi.Int8()
  external int _unique_str_item_203;
  @ffi.Int8()
  external int _unique_str_item_204;
  @ffi.Int8()
  external int _unique_str_item_205;
  @ffi.Int8()
  external int _unique_str_item_206;
  @ffi.Int8()
  external int _unique_str_item_207;
  @ffi.Int8()
  external int _unique_str_item_208;
  @ffi.Int8()
  external int _unique_str_item_209;
  @ffi.Int8()
  external int _unique_str_item_210;
  @ffi.Int8()
  external int _unique_str_item_211;
  @ffi.Int8()
  external int _unique_str_item_212;
  @ffi.Int8()
  external int _unique_str_item_213;
  @ffi.Int8()
  external int _unique_str_item_214;
  @ffi.Int8()
  external int _unique_str_item_215;
  @ffi.Int8()
  external int _unique_str_item_216;
  @ffi.Int8()
  external int _unique_str_item_217;
  @ffi.Int8()
  external int _unique_str_item_218;
  @ffi.Int8()
  external int _unique_str_item_219;
  @ffi.Int8()
  external int _unique_str_item_220;
  @ffi.Int8()
  external int _unique_str_item_221;
  @ffi.Int8()
  external int _unique_str_item_222;
  @ffi.Int8()
  external int _unique_str_item_223;
  @ffi.Int8()
  external int _unique_str_item_224;
  @ffi.Int8()
  external int _unique_str_item_225;
  @ffi.Int8()
  external int _unique_str_item_226;
  @ffi.Int8()
  external int _unique_str_item_227;
  @ffi.Int8()
  external int _unique_str_item_228;
  @ffi.Int8()
  external int _unique_str_item_229;
  @ffi.Int8()
  external int _unique_str_item_230;
  @ffi.Int8()
  external int _unique_str_item_231;
  @ffi.Int8()
  external int _unique_str_item_232;
  @ffi.Int8()
  external int _unique_str_item_233;
  @ffi.Int8()
  external int _unique_str_item_234;
  @ffi.Int8()
  external int _unique_str_item_235;
  @ffi.Int8()
  external int _unique_str_item_236;
  @ffi.Int8()
  external int _unique_str_item_237;
  @ffi.Int8()
  external int _unique_str_item_238;
  @ffi.Int8()
  external int _unique_str_item_239;
  @ffi.Int8()
  external int _unique_str_item_240;
  @ffi.Int8()
  external int _unique_str_item_241;
  @ffi.Int8()
  external int _unique_str_item_242;
  @ffi.Int8()
  external int _unique_str_item_243;
  @ffi.Int8()
  external int _unique_str_item_244;
  @ffi.Int8()
  external int _unique_str_item_245;
  @ffi.Int8()
  external int _unique_str_item_246;
  @ffi.Int8()
  external int _unique_str_item_247;
  @ffi.Int8()
  external int _unique_str_item_248;
  @ffi.Int8()
  external int _unique_str_item_249;
  @ffi.Int8()
  external int _unique_str_item_250;
  @ffi.Int8()
  external int _unique_str_item_251;
  @ffi.Int8()
  external int _unique_str_item_252;
  @ffi.Int8()
  external int _unique_str_item_253;
  @ffi.Int8()
  external int _unique_str_item_254;
  @ffi.Int8()
  external int _unique_str_item_255;
  @ffi.Int8()
  external int _unique_str_item_256;
  @ffi.Int8()
  external int _unique_str_item_257;
  @ffi.Int8()
  external int _unique_str_item_258;
  @ffi.Int8()
  external int _unique_str_item_259;
  @ffi.Int8()
  external int _unique_str_item_260;
  @ffi.Int8()
  external int _unique_str_item_261;
  @ffi.Int8()
  external int _unique_str_item_262;
  @ffi.Int8()
  external int _unique_str_item_263;
  @ffi.Int8()
  external int _unique_str_item_264;
  @ffi.Int8()
  external int _unique_str_item_265;
  @ffi.Int8()
  external int _unique_str_item_266;
  @ffi.Int8()
  external int _unique_str_item_267;
  @ffi.Int8()
  external int _unique_str_item_268;
  @ffi.Int8()
  external int _unique_str_item_269;
  @ffi.Int8()
  external int _unique_str_item_270;
  @ffi.Int8()
  external int _unique_str_item_271;
  @ffi.Int8()
  external int _unique_str_item_272;
  @ffi.Int8()
  external int _unique_str_item_273;
  @ffi.Int8()
  external int _unique_str_item_274;
  @ffi.Int8()
  external int _unique_str_item_275;
  @ffi.Int8()
  external int _unique_str_item_276;
  @ffi.Int8()
  external int _unique_str_item_277;
  @ffi.Int8()
  external int _unique_str_item_278;
  @ffi.Int8()
  external int _unique_str_item_279;
  @ffi.Int8()
  external int _unique_str_item_280;
  @ffi.Int8()
  external int _unique_str_item_281;
  @ffi.Int8()
  external int _unique_str_item_282;
  @ffi.Int8()
  external int _unique_str_item_283;
  @ffi.Int8()
  external int _unique_str_item_284;
  @ffi.Int8()
  external int _unique_str_item_285;
  @ffi.Int8()
  external int _unique_str_item_286;
  @ffi.Int8()
  external int _unique_str_item_287;
  @ffi.Int8()
  external int _unique_str_item_288;
  @ffi.Int8()
  external int _unique_str_item_289;
  @ffi.Int8()
  external int _unique_str_item_290;
  @ffi.Int8()
  external int _unique_str_item_291;
  @ffi.Int8()
  external int _unique_str_item_292;
  @ffi.Int8()
  external int _unique_str_item_293;
  @ffi.Int8()
  external int _unique_str_item_294;
  @ffi.Int8()
  external int _unique_str_item_295;
  @ffi.Int8()
  external int _unique_str_item_296;
  @ffi.Int8()
  external int _unique_str_item_297;
  @ffi.Int8()
  external int _unique_str_item_298;
  @ffi.Int8()
  external int _unique_str_item_299;
  @ffi.Int8()
  external int _unique_str_item_300;
  @ffi.Int8()
  external int _unique_str_item_301;
  @ffi.Int8()
  external int _unique_str_item_302;
  @ffi.Int8()
  external int _unique_str_item_303;
  @ffi.Int8()
  external int _unique_str_item_304;
  @ffi.Int8()
  external int _unique_str_item_305;
  @ffi.Int8()
  external int _unique_str_item_306;
  @ffi.Int8()
  external int _unique_str_item_307;
  @ffi.Int8()
  external int _unique_str_item_308;
  @ffi.Int8()
  external int _unique_str_item_309;
  @ffi.Int8()
  external int _unique_str_item_310;
  @ffi.Int8()
  external int _unique_str_item_311;
  @ffi.Int8()
  external int _unique_str_item_312;
  @ffi.Int8()
  external int _unique_str_item_313;
  @ffi.Int8()
  external int _unique_str_item_314;
  @ffi.Int8()
  external int _unique_str_item_315;
  @ffi.Int8()
  external int _unique_str_item_316;
  @ffi.Int8()
  external int _unique_str_item_317;
  @ffi.Int8()
  external int _unique_str_item_318;
  @ffi.Int8()
  external int _unique_str_item_319;
  @ffi.Int8()
  external int _unique_str_item_320;
  @ffi.Int8()
  external int _unique_str_item_321;
  @ffi.Int8()
  external int _unique_str_item_322;
  @ffi.Int8()
  external int _unique_str_item_323;
  @ffi.Int8()
  external int _unique_str_item_324;
  @ffi.Int8()
  external int _unique_str_item_325;
  @ffi.Int8()
  external int _unique_str_item_326;
  @ffi.Int8()
  external int _unique_str_item_327;
  @ffi.Int8()
  external int _unique_str_item_328;
  @ffi.Int8()
  external int _unique_str_item_329;
  @ffi.Int8()
  external int _unique_str_item_330;
  @ffi.Int8()
  external int _unique_str_item_331;
  @ffi.Int8()
  external int _unique_str_item_332;
  @ffi.Int8()
  external int _unique_str_item_333;
  @ffi.Int8()
  external int _unique_str_item_334;
  @ffi.Int8()
  external int _unique_str_item_335;
  @ffi.Int8()
  external int _unique_str_item_336;
  @ffi.Int8()
  external int _unique_str_item_337;
  @ffi.Int8()
  external int _unique_str_item_338;
  @ffi.Int8()
  external int _unique_str_item_339;
  @ffi.Int8()
  external int _unique_str_item_340;
  @ffi.Int8()
  external int _unique_str_item_341;
  @ffi.Int8()
  external int _unique_str_item_342;
  @ffi.Int8()
  external int _unique_str_item_343;
  @ffi.Int8()
  external int _unique_str_item_344;
  @ffi.Int8()
  external int _unique_str_item_345;
  @ffi.Int8()
  external int _unique_str_item_346;
  @ffi.Int8()
  external int _unique_str_item_347;
  @ffi.Int8()
  external int _unique_str_item_348;
  @ffi.Int8()
  external int _unique_str_item_349;
  @ffi.Int8()
  external int _unique_str_item_350;
  @ffi.Int8()
  external int _unique_str_item_351;
  @ffi.Int8()
  external int _unique_str_item_352;
  @ffi.Int8()
  external int _unique_str_item_353;
  @ffi.Int8()
  external int _unique_str_item_354;
  @ffi.Int8()
  external int _unique_str_item_355;
  @ffi.Int8()
  external int _unique_str_item_356;
  @ffi.Int8()
  external int _unique_str_item_357;
  @ffi.Int8()
  external int _unique_str_item_358;
  @ffi.Int8()
  external int _unique_str_item_359;
  @ffi.Int8()
  external int _unique_str_item_360;
  @ffi.Int8()
  external int _unique_str_item_361;
  @ffi.Int8()
  external int _unique_str_item_362;
  @ffi.Int8()
  external int _unique_str_item_363;
  @ffi.Int8()
  external int _unique_str_item_364;
  @ffi.Int8()
  external int _unique_str_item_365;
  @ffi.Int8()
  external int _unique_str_item_366;
  @ffi.Int8()
  external int _unique_str_item_367;
  @ffi.Int8()
  external int _unique_str_item_368;
  @ffi.Int8()
  external int _unique_str_item_369;
  @ffi.Int8()
  external int _unique_str_item_370;
  @ffi.Int8()
  external int _unique_str_item_371;
  @ffi.Int8()
  external int _unique_str_item_372;
  @ffi.Int8()
  external int _unique_str_item_373;
  @ffi.Int8()
  external int _unique_str_item_374;
  @ffi.Int8()
  external int _unique_str_item_375;
  @ffi.Int8()
  external int _unique_str_item_376;
  @ffi.Int8()
  external int _unique_str_item_377;
  @ffi.Int8()
  external int _unique_str_item_378;
  @ffi.Int8()
  external int _unique_str_item_379;
  @ffi.Int8()
  external int _unique_str_item_380;
  @ffi.Int8()
  external int _unique_str_item_381;
  @ffi.Int8()
  external int _unique_str_item_382;
  @ffi.Int8()
  external int _unique_str_item_383;
  @ffi.Int8()
  external int _unique_str_item_384;
  @ffi.Int8()
  external int _unique_str_item_385;
  @ffi.Int8()
  external int _unique_str_item_386;
  @ffi.Int8()
  external int _unique_str_item_387;
  @ffi.Int8()
  external int _unique_str_item_388;
  @ffi.Int8()
  external int _unique_str_item_389;
  @ffi.Int8()
  external int _unique_str_item_390;
  @ffi.Int8()
  external int _unique_str_item_391;
  @ffi.Int8()
  external int _unique_str_item_392;
  @ffi.Int8()
  external int _unique_str_item_393;
  @ffi.Int8()
  external int _unique_str_item_394;
  @ffi.Int8()
  external int _unique_str_item_395;
  @ffi.Int8()
  external int _unique_str_item_396;
  @ffi.Int8()
  external int _unique_str_item_397;
  @ffi.Int8()
  external int _unique_str_item_398;
  @ffi.Int8()
  external int _unique_str_item_399;
  @ffi.Int8()
  external int _unique_str_item_400;
  @ffi.Int8()
  external int _unique_str_item_401;
  @ffi.Int8()
  external int _unique_str_item_402;
  @ffi.Int8()
  external int _unique_str_item_403;
  @ffi.Int8()
  external int _unique_str_item_404;
  @ffi.Int8()
  external int _unique_str_item_405;
  @ffi.Int8()
  external int _unique_str_item_406;
  @ffi.Int8()
  external int _unique_str_item_407;
  @ffi.Int8()
  external int _unique_str_item_408;
  @ffi.Int8()
  external int _unique_str_item_409;
  @ffi.Int8()
  external int _unique_str_item_410;
  @ffi.Int8()
  external int _unique_str_item_411;
  @ffi.Int8()
  external int _unique_str_item_412;
  @ffi.Int8()
  external int _unique_str_item_413;
  @ffi.Int8()
  external int _unique_str_item_414;
  @ffi.Int8()
  external int _unique_str_item_415;
  @ffi.Int8()
  external int _unique_str_item_416;
  @ffi.Int8()
  external int _unique_str_item_417;
  @ffi.Int8()
  external int _unique_str_item_418;
  @ffi.Int8()
  external int _unique_str_item_419;
  @ffi.Int8()
  external int _unique_str_item_420;
  @ffi.Int8()
  external int _unique_str_item_421;
  @ffi.Int8()
  external int _unique_str_item_422;
  @ffi.Int8()
  external int _unique_str_item_423;
  @ffi.Int8()
  external int _unique_str_item_424;
  @ffi.Int8()
  external int _unique_str_item_425;
  @ffi.Int8()
  external int _unique_str_item_426;
  @ffi.Int8()
  external int _unique_str_item_427;
  @ffi.Int8()
  external int _unique_str_item_428;
  @ffi.Int8()
  external int _unique_str_item_429;
  @ffi.Int8()
  external int _unique_str_item_430;
  @ffi.Int8()
  external int _unique_str_item_431;
  @ffi.Int8()
  external int _unique_str_item_432;
  @ffi.Int8()
  external int _unique_str_item_433;
  @ffi.Int8()
  external int _unique_str_item_434;
  @ffi.Int8()
  external int _unique_str_item_435;
  @ffi.Int8()
  external int _unique_str_item_436;
  @ffi.Int8()
  external int _unique_str_item_437;
  @ffi.Int8()
  external int _unique_str_item_438;
  @ffi.Int8()
  external int _unique_str_item_439;
  @ffi.Int8()
  external int _unique_str_item_440;
  @ffi.Int8()
  external int _unique_str_item_441;
  @ffi.Int8()
  external int _unique_str_item_442;
  @ffi.Int8()
  external int _unique_str_item_443;
  @ffi.Int8()
  external int _unique_str_item_444;
  @ffi.Int8()
  external int _unique_str_item_445;
  @ffi.Int8()
  external int _unique_str_item_446;
  @ffi.Int8()
  external int _unique_str_item_447;
  @ffi.Int8()
  external int _unique_str_item_448;
  @ffi.Int8()
  external int _unique_str_item_449;
  @ffi.Int8()
  external int _unique_str_item_450;
  @ffi.Int8()
  external int _unique_str_item_451;
  @ffi.Int8()
  external int _unique_str_item_452;
  @ffi.Int8()
  external int _unique_str_item_453;
  @ffi.Int8()
  external int _unique_str_item_454;
  @ffi.Int8()
  external int _unique_str_item_455;
  @ffi.Int8()
  external int _unique_str_item_456;
  @ffi.Int8()
  external int _unique_str_item_457;
  @ffi.Int8()
  external int _unique_str_item_458;
  @ffi.Int8()
  external int _unique_str_item_459;
  @ffi.Int8()
  external int _unique_str_item_460;
  @ffi.Int8()
  external int _unique_str_item_461;
  @ffi.Int8()
  external int _unique_str_item_462;
  @ffi.Int8()
  external int _unique_str_item_463;
  @ffi.Int8()
  external int _unique_str_item_464;
  @ffi.Int8()
  external int _unique_str_item_465;
  @ffi.Int8()
  external int _unique_str_item_466;
  @ffi.Int8()
  external int _unique_str_item_467;
  @ffi.Int8()
  external int _unique_str_item_468;
  @ffi.Int8()
  external int _unique_str_item_469;
  @ffi.Int8()
  external int _unique_str_item_470;
  @ffi.Int8()
  external int _unique_str_item_471;
  @ffi.Int8()
  external int _unique_str_item_472;
  @ffi.Int8()
  external int _unique_str_item_473;
  @ffi.Int8()
  external int _unique_str_item_474;
  @ffi.Int8()
  external int _unique_str_item_475;
  @ffi.Int8()
  external int _unique_str_item_476;
  @ffi.Int8()
  external int _unique_str_item_477;
  @ffi.Int8()
  external int _unique_str_item_478;
  @ffi.Int8()
  external int _unique_str_item_479;
  @ffi.Int8()
  external int _unique_str_item_480;
  @ffi.Int8()
  external int _unique_str_item_481;
  @ffi.Int8()
  external int _unique_str_item_482;
  @ffi.Int8()
  external int _unique_str_item_483;
  @ffi.Int8()
  external int _unique_str_item_484;
  @ffi.Int8()
  external int _unique_str_item_485;
  @ffi.Int8()
  external int _unique_str_item_486;
  @ffi.Int8()
  external int _unique_str_item_487;
  @ffi.Int8()
  external int _unique_str_item_488;
  @ffi.Int8()
  external int _unique_str_item_489;
  @ffi.Int8()
  external int _unique_str_item_490;
  @ffi.Int8()
  external int _unique_str_item_491;
  @ffi.Int8()
  external int _unique_str_item_492;
  @ffi.Int8()
  external int _unique_str_item_493;
  @ffi.Int8()
  external int _unique_str_item_494;
  @ffi.Int8()
  external int _unique_str_item_495;
  @ffi.Int8()
  external int _unique_str_item_496;
  @ffi.Int8()
  external int _unique_str_item_497;
  @ffi.Int8()
  external int _unique_str_item_498;
  @ffi.Int8()
  external int _unique_str_item_499;
  @ffi.Int8()
  external int _unique_str_item_500;
  @ffi.Int8()
  external int _unique_str_item_501;
  @ffi.Int8()
  external int _unique_str_item_502;
  @ffi.Int8()
  external int _unique_str_item_503;
  @ffi.Int8()
  external int _unique_str_item_504;
  @ffi.Int8()
  external int _unique_str_item_505;
  @ffi.Int8()
  external int _unique_str_item_506;
  @ffi.Int8()
  external int _unique_str_item_507;
  @ffi.Int8()
  external int _unique_str_item_508;
  @ffi.Int8()
  external int _unique_str_item_509;
  @ffi.Int8()
  external int _unique_str_item_510;
  @ffi.Int8()
  external int _unique_str_item_511;
  @ffi.Int8()
  external int _unique_str_item_512;
  @ffi.Int8()
  external int _unique_str_item_513;
  @ffi.Int8()
  external int _unique_str_item_514;
  @ffi.Int8()
  external int _unique_str_item_515;
  @ffi.Int8()
  external int _unique_str_item_516;
  @ffi.Int8()
  external int _unique_str_item_517;
  @ffi.Int8()
  external int _unique_str_item_518;
  @ffi.Int8()
  external int _unique_str_item_519;
  @ffi.Int8()
  external int _unique_str_item_520;
  @ffi.Int8()
  external int _unique_str_item_521;
  @ffi.Int8()
  external int _unique_str_item_522;
  @ffi.Int8()
  external int _unique_str_item_523;
  @ffi.Int8()
  external int _unique_str_item_524;
  @ffi.Int8()
  external int _unique_str_item_525;
  @ffi.Int8()
  external int _unique_str_item_526;
  @ffi.Int8()
  external int _unique_str_item_527;
  @ffi.Int8()
  external int _unique_str_item_528;
  @ffi.Int8()
  external int _unique_str_item_529;
  @ffi.Int8()
  external int _unique_str_item_530;
  @ffi.Int8()
  external int _unique_str_item_531;
  @ffi.Int8()
  external int _unique_str_item_532;
  @ffi.Int8()
  external int _unique_str_item_533;
  @ffi.Int8()
  external int _unique_str_item_534;
  @ffi.Int8()
  external int _unique_str_item_535;
  @ffi.Int8()
  external int _unique_str_item_536;
  @ffi.Int8()
  external int _unique_str_item_537;
  @ffi.Int8()
  external int _unique_str_item_538;
  @ffi.Int8()
  external int _unique_str_item_539;
  @ffi.Int8()
  external int _unique_str_item_540;
  @ffi.Int8()
  external int _unique_str_item_541;
  @ffi.Int8()
  external int _unique_str_item_542;
  @ffi.Int8()
  external int _unique_str_item_543;
  @ffi.Int8()
  external int _unique_str_item_544;
  @ffi.Int8()
  external int _unique_str_item_545;
  @ffi.Int8()
  external int _unique_str_item_546;
  @ffi.Int8()
  external int _unique_str_item_547;
  @ffi.Int8()
  external int _unique_str_item_548;
  @ffi.Int8()
  external int _unique_str_item_549;
  @ffi.Int8()
  external int _unique_str_item_550;
  @ffi.Int8()
  external int _unique_str_item_551;
  @ffi.Int8()
  external int _unique_str_item_552;
  @ffi.Int8()
  external int _unique_str_item_553;
  @ffi.Int8()
  external int _unique_str_item_554;
  @ffi.Int8()
  external int _unique_str_item_555;
  @ffi.Int8()
  external int _unique_str_item_556;
  @ffi.Int8()
  external int _unique_str_item_557;
  @ffi.Int8()
  external int _unique_str_item_558;
  @ffi.Int8()
  external int _unique_str_item_559;
  @ffi.Int8()
  external int _unique_str_item_560;
  @ffi.Int8()
  external int _unique_str_item_561;
  @ffi.Int8()
  external int _unique_str_item_562;
  @ffi.Int8()
  external int _unique_str_item_563;
  @ffi.Int8()
  external int _unique_str_item_564;
  @ffi.Int8()
  external int _unique_str_item_565;
  @ffi.Int8()
  external int _unique_str_item_566;
  @ffi.Int8()
  external int _unique_str_item_567;
  @ffi.Int8()
  external int _unique_str_item_568;
  @ffi.Int8()
  external int _unique_str_item_569;
  @ffi.Int8()
  external int _unique_str_item_570;
  @ffi.Int8()
  external int _unique_str_item_571;
  @ffi.Int8()
  external int _unique_str_item_572;
  @ffi.Int8()
  external int _unique_str_item_573;
  @ffi.Int8()
  external int _unique_str_item_574;
  @ffi.Int8()
  external int _unique_str_item_575;
  @ffi.Int8()
  external int _unique_str_item_576;
  @ffi.Int8()
  external int _unique_str_item_577;
  @ffi.Int8()
  external int _unique_str_item_578;
  @ffi.Int8()
  external int _unique_str_item_579;
  @ffi.Int8()
  external int _unique_str_item_580;
  @ffi.Int8()
  external int _unique_str_item_581;
  @ffi.Int8()
  external int _unique_str_item_582;
  @ffi.Int8()
  external int _unique_str_item_583;
  @ffi.Int8()
  external int _unique_str_item_584;
  @ffi.Int8()
  external int _unique_str_item_585;
  @ffi.Int8()
  external int _unique_str_item_586;
  @ffi.Int8()
  external int _unique_str_item_587;
  @ffi.Int8()
  external int _unique_str_item_588;
  @ffi.Int8()
  external int _unique_str_item_589;
  @ffi.Int8()
  external int _unique_str_item_590;
  @ffi.Int8()
  external int _unique_str_item_591;
  @ffi.Int8()
  external int _unique_str_item_592;
  @ffi.Int8()
  external int _unique_str_item_593;
  @ffi.Int8()
  external int _unique_str_item_594;
  @ffi.Int8()
  external int _unique_str_item_595;
  @ffi.Int8()
  external int _unique_str_item_596;
  @ffi.Int8()
  external int _unique_str_item_597;
  @ffi.Int8()
  external int _unique_str_item_598;
  @ffi.Int8()
  external int _unique_str_item_599;
  @ffi.Int8()
  external int _unique_str_item_600;
  @ffi.Int8()
  external int _unique_str_item_601;
  @ffi.Int8()
  external int _unique_str_item_602;
  @ffi.Int8()
  external int _unique_str_item_603;
  @ffi.Int8()
  external int _unique_str_item_604;
  @ffi.Int8()
  external int _unique_str_item_605;
  @ffi.Int8()
  external int _unique_str_item_606;
  @ffi.Int8()
  external int _unique_str_item_607;
  @ffi.Int8()
  external int _unique_str_item_608;
  @ffi.Int8()
  external int _unique_str_item_609;
  @ffi.Int8()
  external int _unique_str_item_610;
  @ffi.Int8()
  external int _unique_str_item_611;
  @ffi.Int8()
  external int _unique_str_item_612;
  @ffi.Int8()
  external int _unique_str_item_613;
  @ffi.Int8()
  external int _unique_str_item_614;
  @ffi.Int8()
  external int _unique_str_item_615;
  @ffi.Int8()
  external int _unique_str_item_616;
  @ffi.Int8()
  external int _unique_str_item_617;
  @ffi.Int8()
  external int _unique_str_item_618;
  @ffi.Int8()
  external int _unique_str_item_619;
  @ffi.Int8()
  external int _unique_str_item_620;
  @ffi.Int8()
  external int _unique_str_item_621;
  @ffi.Int8()
  external int _unique_str_item_622;
  @ffi.Int8()
  external int _unique_str_item_623;
  @ffi.Int8()
  external int _unique_str_item_624;
  @ffi.Int8()
  external int _unique_str_item_625;
  @ffi.Int8()
  external int _unique_str_item_626;
  @ffi.Int8()
  external int _unique_str_item_627;
  @ffi.Int8()
  external int _unique_str_item_628;
  @ffi.Int8()
  external int _unique_str_item_629;
  @ffi.Int8()
  external int _unique_str_item_630;
  @ffi.Int8()
  external int _unique_str_item_631;
  @ffi.Int8()
  external int _unique_str_item_632;
  @ffi.Int8()
  external int _unique_str_item_633;
  @ffi.Int8()
  external int _unique_str_item_634;
  @ffi.Int8()
  external int _unique_str_item_635;
  @ffi.Int8()
  external int _unique_str_item_636;
  @ffi.Int8()
  external int _unique_str_item_637;
  @ffi.Int8()
  external int _unique_str_item_638;
  @ffi.Int8()
  external int _unique_str_item_639;
  @ffi.Int8()
  external int _unique_str_item_640;
  @ffi.Int8()
  external int _unique_str_item_641;
  @ffi.Int8()
  external int _unique_str_item_642;
  @ffi.Int8()
  external int _unique_str_item_643;
  @ffi.Int8()
  external int _unique_str_item_644;
  @ffi.Int8()
  external int _unique_str_item_645;
  @ffi.Int8()
  external int _unique_str_item_646;
  @ffi.Int8()
  external int _unique_str_item_647;
  @ffi.Int8()
  external int _unique_str_item_648;
  @ffi.Int8()
  external int _unique_str_item_649;
  @ffi.Int8()
  external int _unique_str_item_650;
  @ffi.Int8()
  external int _unique_str_item_651;
  @ffi.Int8()
  external int _unique_str_item_652;
  @ffi.Int8()
  external int _unique_str_item_653;
  @ffi.Int8()
  external int _unique_str_item_654;
  @ffi.Int8()
  external int _unique_str_item_655;
  @ffi.Int8()
  external int _unique_str_item_656;
  @ffi.Int8()
  external int _unique_str_item_657;
  @ffi.Int8()
  external int _unique_str_item_658;
  @ffi.Int8()
  external int _unique_str_item_659;
  @ffi.Int8()
  external int _unique_str_item_660;
  @ffi.Int8()
  external int _unique_str_item_661;
  @ffi.Int8()
  external int _unique_str_item_662;
  @ffi.Int8()
  external int _unique_str_item_663;
  @ffi.Int8()
  external int _unique_str_item_664;
  @ffi.Int8()
  external int _unique_str_item_665;
  @ffi.Int8()
  external int _unique_str_item_666;
  @ffi.Int8()
  external int _unique_str_item_667;
  @ffi.Int8()
  external int _unique_str_item_668;
  @ffi.Int8()
  external int _unique_str_item_669;
  @ffi.Int8()
  external int _unique_str_item_670;
  @ffi.Int8()
  external int _unique_str_item_671;
  @ffi.Int8()
  external int _unique_str_item_672;
  @ffi.Int8()
  external int _unique_str_item_673;
  @ffi.Int8()
  external int _unique_str_item_674;
  @ffi.Int8()
  external int _unique_str_item_675;
  @ffi.Int8()
  external int _unique_str_item_676;
  @ffi.Int8()
  external int _unique_str_item_677;
  @ffi.Int8()
  external int _unique_str_item_678;
  @ffi.Int8()
  external int _unique_str_item_679;
  @ffi.Int8()
  external int _unique_str_item_680;
  @ffi.Int8()
  external int _unique_str_item_681;
  @ffi.Int8()
  external int _unique_str_item_682;
  @ffi.Int8()
  external int _unique_str_item_683;
  @ffi.Int8()
  external int _unique_str_item_684;
  @ffi.Int8()
  external int _unique_str_item_685;
  @ffi.Int8()
  external int _unique_str_item_686;
  @ffi.Int8()
  external int _unique_str_item_687;
  @ffi.Int8()
  external int _unique_str_item_688;
  @ffi.Int8()
  external int _unique_str_item_689;
  @ffi.Int8()
  external int _unique_str_item_690;
  @ffi.Int8()
  external int _unique_str_item_691;
  @ffi.Int8()
  external int _unique_str_item_692;
  @ffi.Int8()
  external int _unique_str_item_693;
  @ffi.Int8()
  external int _unique_str_item_694;
  @ffi.Int8()
  external int _unique_str_item_695;
  @ffi.Int8()
  external int _unique_str_item_696;
  @ffi.Int8()
  external int _unique_str_item_697;
  @ffi.Int8()
  external int _unique_str_item_698;
  @ffi.Int8()
  external int _unique_str_item_699;
  @ffi.Int8()
  external int _unique_str_item_700;
  @ffi.Int8()
  external int _unique_str_item_701;
  @ffi.Int8()
  external int _unique_str_item_702;
  @ffi.Int8()
  external int _unique_str_item_703;
  @ffi.Int8()
  external int _unique_str_item_704;
  @ffi.Int8()
  external int _unique_str_item_705;
  @ffi.Int8()
  external int _unique_str_item_706;
  @ffi.Int8()
  external int _unique_str_item_707;
  @ffi.Int8()
  external int _unique_str_item_708;
  @ffi.Int8()
  external int _unique_str_item_709;
  @ffi.Int8()
  external int _unique_str_item_710;
  @ffi.Int8()
  external int _unique_str_item_711;
  @ffi.Int8()
  external int _unique_str_item_712;
  @ffi.Int8()
  external int _unique_str_item_713;
  @ffi.Int8()
  external int _unique_str_item_714;
  @ffi.Int8()
  external int _unique_str_item_715;
  @ffi.Int8()
  external int _unique_str_item_716;
  @ffi.Int8()
  external int _unique_str_item_717;
  @ffi.Int8()
  external int _unique_str_item_718;
  @ffi.Int8()
  external int _unique_str_item_719;
  @ffi.Int8()
  external int _unique_str_item_720;
  @ffi.Int8()
  external int _unique_str_item_721;
  @ffi.Int8()
  external int _unique_str_item_722;
  @ffi.Int8()
  external int _unique_str_item_723;
  @ffi.Int8()
  external int _unique_str_item_724;
  @ffi.Int8()
  external int _unique_str_item_725;
  @ffi.Int8()
  external int _unique_str_item_726;
  @ffi.Int8()
  external int _unique_str_item_727;
  @ffi.Int8()
  external int _unique_str_item_728;
  @ffi.Int8()
  external int _unique_str_item_729;
  @ffi.Int8()
  external int _unique_str_item_730;
  @ffi.Int8()
  external int _unique_str_item_731;
  @ffi.Int8()
  external int _unique_str_item_732;
  @ffi.Int8()
  external int _unique_str_item_733;
  @ffi.Int8()
  external int _unique_str_item_734;
  @ffi.Int8()
  external int _unique_str_item_735;
  @ffi.Int8()
  external int _unique_str_item_736;
  @ffi.Int8()
  external int _unique_str_item_737;
  @ffi.Int8()
  external int _unique_str_item_738;
  @ffi.Int8()
  external int _unique_str_item_739;
  @ffi.Int8()
  external int _unique_str_item_740;
  @ffi.Int8()
  external int _unique_str_item_741;
  @ffi.Int8()
  external int _unique_str_item_742;
  @ffi.Int8()
  external int _unique_str_item_743;
  @ffi.Int8()
  external int _unique_str_item_744;
  @ffi.Int8()
  external int _unique_str_item_745;
  @ffi.Int8()
  external int _unique_str_item_746;
  @ffi.Int8()
  external int _unique_str_item_747;
  @ffi.Int8()
  external int _unique_str_item_748;
  @ffi.Int8()
  external int _unique_str_item_749;
  @ffi.Int8()
  external int _unique_str_item_750;
  @ffi.Int8()
  external int _unique_str_item_751;
  @ffi.Int8()
  external int _unique_str_item_752;
  @ffi.Int8()
  external int _unique_str_item_753;
  @ffi.Int8()
  external int _unique_str_item_754;
  @ffi.Int8()
  external int _unique_str_item_755;
  @ffi.Int8()
  external int _unique_str_item_756;
  @ffi.Int8()
  external int _unique_str_item_757;
  @ffi.Int8()
  external int _unique_str_item_758;
  @ffi.Int8()
  external int _unique_str_item_759;
  @ffi.Int8()
  external int _unique_str_item_760;
  @ffi.Int8()
  external int _unique_str_item_761;
  @ffi.Int8()
  external int _unique_str_item_762;
  @ffi.Int8()
  external int _unique_str_item_763;
  @ffi.Int8()
  external int _unique_str_item_764;
  @ffi.Int8()
  external int _unique_str_item_765;
  @ffi.Int8()
  external int _unique_str_item_766;
  @ffi.Int8()
  external int _unique_str_item_767;
  @ffi.Int8()
  external int _unique_str_item_768;
  @ffi.Int8()
  external int _unique_str_item_769;
  @ffi.Int8()
  external int _unique_str_item_770;
  @ffi.Int8()
  external int _unique_str_item_771;
  @ffi.Int8()
  external int _unique_str_item_772;
  @ffi.Int8()
  external int _unique_str_item_773;
  @ffi.Int8()
  external int _unique_str_item_774;
  @ffi.Int8()
  external int _unique_str_item_775;
  @ffi.Int8()
  external int _unique_str_item_776;
  @ffi.Int8()
  external int _unique_str_item_777;
  @ffi.Int8()
  external int _unique_str_item_778;
  @ffi.Int8()
  external int _unique_str_item_779;
  @ffi.Int8()
  external int _unique_str_item_780;
  @ffi.Int8()
  external int _unique_str_item_781;
  @ffi.Int8()
  external int _unique_str_item_782;
  @ffi.Int8()
  external int _unique_str_item_783;
  @ffi.Int8()
  external int _unique_str_item_784;
  @ffi.Int8()
  external int _unique_str_item_785;
  @ffi.Int8()
  external int _unique_str_item_786;
  @ffi.Int8()
  external int _unique_str_item_787;
  @ffi.Int8()
  external int _unique_str_item_788;
  @ffi.Int8()
  external int _unique_str_item_789;
  @ffi.Int8()
  external int _unique_str_item_790;
  @ffi.Int8()
  external int _unique_str_item_791;
  @ffi.Int8()
  external int _unique_str_item_792;
  @ffi.Int8()
  external int _unique_str_item_793;
  @ffi.Int8()
  external int _unique_str_item_794;
  @ffi.Int8()
  external int _unique_str_item_795;
  @ffi.Int8()
  external int _unique_str_item_796;
  @ffi.Int8()
  external int _unique_str_item_797;
  @ffi.Int8()
  external int _unique_str_item_798;
  @ffi.Int8()
  external int _unique_str_item_799;
  @ffi.Int8()
  external int _unique_str_item_800;
  @ffi.Int8()
  external int _unique_str_item_801;
  @ffi.Int8()
  external int _unique_str_item_802;
  @ffi.Int8()
  external int _unique_str_item_803;
  @ffi.Int8()
  external int _unique_str_item_804;
  @ffi.Int8()
  external int _unique_str_item_805;
  @ffi.Int8()
  external int _unique_str_item_806;
  @ffi.Int8()
  external int _unique_str_item_807;
  @ffi.Int8()
  external int _unique_str_item_808;
  @ffi.Int8()
  external int _unique_str_item_809;
  @ffi.Int8()
  external int _unique_str_item_810;
  @ffi.Int8()
  external int _unique_str_item_811;
  @ffi.Int8()
  external int _unique_str_item_812;
  @ffi.Int8()
  external int _unique_str_item_813;
  @ffi.Int8()
  external int _unique_str_item_814;
  @ffi.Int8()
  external int _unique_str_item_815;
  @ffi.Int8()
  external int _unique_str_item_816;
  @ffi.Int8()
  external int _unique_str_item_817;
  @ffi.Int8()
  external int _unique_str_item_818;
  @ffi.Int8()
  external int _unique_str_item_819;
  @ffi.Int8()
  external int _unique_str_item_820;
  @ffi.Int8()
  external int _unique_str_item_821;
  @ffi.Int8()
  external int _unique_str_item_822;
  @ffi.Int8()
  external int _unique_str_item_823;
  @ffi.Int8()
  external int _unique_str_item_824;
  @ffi.Int8()
  external int _unique_str_item_825;
  @ffi.Int8()
  external int _unique_str_item_826;
  @ffi.Int8()
  external int _unique_str_item_827;
  @ffi.Int8()
  external int _unique_str_item_828;
  @ffi.Int8()
  external int _unique_str_item_829;
  @ffi.Int8()
  external int _unique_str_item_830;
  @ffi.Int8()
  external int _unique_str_item_831;
  @ffi.Int8()
  external int _unique_str_item_832;
  @ffi.Int8()
  external int _unique_str_item_833;
  @ffi.Int8()
  external int _unique_str_item_834;
  @ffi.Int8()
  external int _unique_str_item_835;
  @ffi.Int8()
  external int _unique_str_item_836;
  @ffi.Int8()
  external int _unique_str_item_837;
  @ffi.Int8()
  external int _unique_str_item_838;
  @ffi.Int8()
  external int _unique_str_item_839;
  @ffi.Int8()
  external int _unique_str_item_840;
  @ffi.Int8()
  external int _unique_str_item_841;
  @ffi.Int8()
  external int _unique_str_item_842;
  @ffi.Int8()
  external int _unique_str_item_843;
  @ffi.Int8()
  external int _unique_str_item_844;
  @ffi.Int8()
  external int _unique_str_item_845;
  @ffi.Int8()
  external int _unique_str_item_846;
  @ffi.Int8()
  external int _unique_str_item_847;
  @ffi.Int8()
  external int _unique_str_item_848;
  @ffi.Int8()
  external int _unique_str_item_849;
  @ffi.Int8()
  external int _unique_str_item_850;
  @ffi.Int8()
  external int _unique_str_item_851;
  @ffi.Int8()
  external int _unique_str_item_852;
  @ffi.Int8()
  external int _unique_str_item_853;
  @ffi.Int8()
  external int _unique_str_item_854;
  @ffi.Int8()
  external int _unique_str_item_855;
  @ffi.Int8()
  external int _unique_str_item_856;
  @ffi.Int8()
  external int _unique_str_item_857;
  @ffi.Int8()
  external int _unique_str_item_858;
  @ffi.Int8()
  external int _unique_str_item_859;
  @ffi.Int8()
  external int _unique_str_item_860;
  @ffi.Int8()
  external int _unique_str_item_861;
  @ffi.Int8()
  external int _unique_str_item_862;
  @ffi.Int8()
  external int _unique_str_item_863;
  @ffi.Int8()
  external int _unique_str_item_864;
  @ffi.Int8()
  external int _unique_str_item_865;
  @ffi.Int8()
  external int _unique_str_item_866;
  @ffi.Int8()
  external int _unique_str_item_867;
  @ffi.Int8()
  external int _unique_str_item_868;
  @ffi.Int8()
  external int _unique_str_item_869;
  @ffi.Int8()
  external int _unique_str_item_870;
  @ffi.Int8()
  external int _unique_str_item_871;
  @ffi.Int8()
  external int _unique_str_item_872;
  @ffi.Int8()
  external int _unique_str_item_873;
  @ffi.Int8()
  external int _unique_str_item_874;
  @ffi.Int8()
  external int _unique_str_item_875;
  @ffi.Int8()
  external int _unique_str_item_876;
  @ffi.Int8()
  external int _unique_str_item_877;
  @ffi.Int8()
  external int _unique_str_item_878;
  @ffi.Int8()
  external int _unique_str_item_879;
  @ffi.Int8()
  external int _unique_str_item_880;
  @ffi.Int8()
  external int _unique_str_item_881;
  @ffi.Int8()
  external int _unique_str_item_882;
  @ffi.Int8()
  external int _unique_str_item_883;
  @ffi.Int8()
  external int _unique_str_item_884;
  @ffi.Int8()
  external int _unique_str_item_885;
  @ffi.Int8()
  external int _unique_str_item_886;
  @ffi.Int8()
  external int _unique_str_item_887;
  @ffi.Int8()
  external int _unique_str_item_888;
  @ffi.Int8()
  external int _unique_str_item_889;
  @ffi.Int8()
  external int _unique_str_item_890;
  @ffi.Int8()
  external int _unique_str_item_891;
  @ffi.Int8()
  external int _unique_str_item_892;
  @ffi.Int8()
  external int _unique_str_item_893;
  @ffi.Int8()
  external int _unique_str_item_894;
  @ffi.Int8()
  external int _unique_str_item_895;
  @ffi.Int8()
  external int _unique_str_item_896;
  @ffi.Int8()
  external int _unique_str_item_897;
  @ffi.Int8()
  external int _unique_str_item_898;
  @ffi.Int8()
  external int _unique_str_item_899;
  @ffi.Int8()
  external int _unique_str_item_900;
  @ffi.Int8()
  external int _unique_str_item_901;
  @ffi.Int8()
  external int _unique_str_item_902;
  @ffi.Int8()
  external int _unique_str_item_903;
  @ffi.Int8()
  external int _unique_str_item_904;
  @ffi.Int8()
  external int _unique_str_item_905;
  @ffi.Int8()
  external int _unique_str_item_906;
  @ffi.Int8()
  external int _unique_str_item_907;
  @ffi.Int8()
  external int _unique_str_item_908;
  @ffi.Int8()
  external int _unique_str_item_909;
  @ffi.Int8()
  external int _unique_str_item_910;
  @ffi.Int8()
  external int _unique_str_item_911;
  @ffi.Int8()
  external int _unique_str_item_912;
  @ffi.Int8()
  external int _unique_str_item_913;
  @ffi.Int8()
  external int _unique_str_item_914;
  @ffi.Int8()
  external int _unique_str_item_915;
  @ffi.Int8()
  external int _unique_str_item_916;
  @ffi.Int8()
  external int _unique_str_item_917;
  @ffi.Int8()
  external int _unique_str_item_918;
  @ffi.Int8()
  external int _unique_str_item_919;
  @ffi.Int8()
  external int _unique_str_item_920;
  @ffi.Int8()
  external int _unique_str_item_921;
  @ffi.Int8()
  external int _unique_str_item_922;
  @ffi.Int8()
  external int _unique_str_item_923;
  @ffi.Int8()
  external int _unique_str_item_924;
  @ffi.Int8()
  external int _unique_str_item_925;
  @ffi.Int8()
  external int _unique_str_item_926;
  @ffi.Int8()
  external int _unique_str_item_927;
  @ffi.Int8()
  external int _unique_str_item_928;
  @ffi.Int8()
  external int _unique_str_item_929;
  @ffi.Int8()
  external int _unique_str_item_930;
  @ffi.Int8()
  external int _unique_str_item_931;
  @ffi.Int8()
  external int _unique_str_item_932;
  @ffi.Int8()
  external int _unique_str_item_933;
  @ffi.Int8()
  external int _unique_str_item_934;
  @ffi.Int8()
  external int _unique_str_item_935;
  @ffi.Int8()
  external int _unique_str_item_936;
  @ffi.Int8()
  external int _unique_str_item_937;
  @ffi.Int8()
  external int _unique_str_item_938;
  @ffi.Int8()
  external int _unique_str_item_939;
  @ffi.Int8()
  external int _unique_str_item_940;
  @ffi.Int8()
  external int _unique_str_item_941;
  @ffi.Int8()
  external int _unique_str_item_942;
  @ffi.Int8()
  external int _unique_str_item_943;
  @ffi.Int8()
  external int _unique_str_item_944;
  @ffi.Int8()
  external int _unique_str_item_945;
  @ffi.Int8()
  external int _unique_str_item_946;
  @ffi.Int8()
  external int _unique_str_item_947;
  @ffi.Int8()
  external int _unique_str_item_948;
  @ffi.Int8()
  external int _unique_str_item_949;
  @ffi.Int8()
  external int _unique_str_item_950;
  @ffi.Int8()
  external int _unique_str_item_951;
  @ffi.Int8()
  external int _unique_str_item_952;
  @ffi.Int8()
  external int _unique_str_item_953;
  @ffi.Int8()
  external int _unique_str_item_954;
  @ffi.Int8()
  external int _unique_str_item_955;
  @ffi.Int8()
  external int _unique_str_item_956;
  @ffi.Int8()
  external int _unique_str_item_957;
  @ffi.Int8()
  external int _unique_str_item_958;
  @ffi.Int8()
  external int _unique_str_item_959;
  @ffi.Int8()
  external int _unique_str_item_960;
  @ffi.Int8()
  external int _unique_str_item_961;
  @ffi.Int8()
  external int _unique_str_item_962;
  @ffi.Int8()
  external int _unique_str_item_963;
  @ffi.Int8()
  external int _unique_str_item_964;
  @ffi.Int8()
  external int _unique_str_item_965;
  @ffi.Int8()
  external int _unique_str_item_966;
  @ffi.Int8()
  external int _unique_str_item_967;
  @ffi.Int8()
  external int _unique_str_item_968;
  @ffi.Int8()
  external int _unique_str_item_969;
  @ffi.Int8()
  external int _unique_str_item_970;
  @ffi.Int8()
  external int _unique_str_item_971;
  @ffi.Int8()
  external int _unique_str_item_972;
  @ffi.Int8()
  external int _unique_str_item_973;
  @ffi.Int8()
  external int _unique_str_item_974;
  @ffi.Int8()
  external int _unique_str_item_975;
  @ffi.Int8()
  external int _unique_str_item_976;
  @ffi.Int8()
  external int _unique_str_item_977;
  @ffi.Int8()
  external int _unique_str_item_978;
  @ffi.Int8()
  external int _unique_str_item_979;
  @ffi.Int8()
  external int _unique_str_item_980;
  @ffi.Int8()
  external int _unique_str_item_981;
  @ffi.Int8()
  external int _unique_str_item_982;
  @ffi.Int8()
  external int _unique_str_item_983;
  @ffi.Int8()
  external int _unique_str_item_984;
  @ffi.Int8()
  external int _unique_str_item_985;
  @ffi.Int8()
  external int _unique_str_item_986;
  @ffi.Int8()
  external int _unique_str_item_987;
  @ffi.Int8()
  external int _unique_str_item_988;
  @ffi.Int8()
  external int _unique_str_item_989;
  @ffi.Int8()
  external int _unique_str_item_990;
  @ffi.Int8()
  external int _unique_str_item_991;
  @ffi.Int8()
  external int _unique_str_item_992;
  @ffi.Int8()
  external int _unique_str_item_993;
  @ffi.Int8()
  external int _unique_str_item_994;
  @ffi.Int8()
  external int _unique_str_item_995;
  @ffi.Int8()
  external int _unique_str_item_996;
  @ffi.Int8()
  external int _unique_str_item_997;
  @ffi.Int8()
  external int _unique_str_item_998;
  @ffi.Int8()
  external int _unique_str_item_999;
  @ffi.Int8()
  external int _unique_str_item_1000;
  @ffi.Int8()
  external int _unique_str_item_1001;
  @ffi.Int8()
  external int _unique_str_item_1002;
  @ffi.Int8()
  external int _unique_str_item_1003;
  @ffi.Int8()
  external int _unique_str_item_1004;
  @ffi.Int8()
  external int _unique_str_item_1005;
  @ffi.Int8()
  external int _unique_str_item_1006;
  @ffi.Int8()
  external int _unique_str_item_1007;
  @ffi.Int8()
  external int _unique_str_item_1008;
  @ffi.Int8()
  external int _unique_str_item_1009;
  @ffi.Int8()
  external int _unique_str_item_1010;
  @ffi.Int8()
  external int _unique_str_item_1011;
  @ffi.Int8()
  external int _unique_str_item_1012;
  @ffi.Int8()
  external int _unique_str_item_1013;
  @ffi.Int8()
  external int _unique_str_item_1014;
  @ffi.Int8()
  external int _unique_str_item_1015;
  @ffi.Int8()
  external int _unique_str_item_1016;
  @ffi.Int8()
  external int _unique_str_item_1017;
  @ffi.Int8()
  external int _unique_str_item_1018;
  @ffi.Int8()
  external int _unique_str_item_1019;
  @ffi.Int8()
  external int _unique_str_item_1020;
  @ffi.Int8()
  external int _unique_str_item_1021;
  @ffi.Int8()
  external int _unique_str_item_1022;
  @ffi.Int8()
  external int _unique_str_item_1023;

  /// Helper for array `str`.
  ArrayHelper_rcutils_error_string_t_str_level0 get str =>
      ArrayHelper_rcutils_error_string_t_str_level0(this, [1024], 0, 0);
}

/// Helper for array `str` in struct `rcutils_error_string_t`.
class ArrayHelper_rcutils_error_string_t_str_level0 {
  final rcutils_error_string_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_rcutils_error_string_t_str_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_str_item_0;
      case 1:
        return _struct._unique_str_item_1;
      case 2:
        return _struct._unique_str_item_2;
      case 3:
        return _struct._unique_str_item_3;
      case 4:
        return _struct._unique_str_item_4;
      case 5:
        return _struct._unique_str_item_5;
      case 6:
        return _struct._unique_str_item_6;
      case 7:
        return _struct._unique_str_item_7;
      case 8:
        return _struct._unique_str_item_8;
      case 9:
        return _struct._unique_str_item_9;
      case 10:
        return _struct._unique_str_item_10;
      case 11:
        return _struct._unique_str_item_11;
      case 12:
        return _struct._unique_str_item_12;
      case 13:
        return _struct._unique_str_item_13;
      case 14:
        return _struct._unique_str_item_14;
      case 15:
        return _struct._unique_str_item_15;
      case 16:
        return _struct._unique_str_item_16;
      case 17:
        return _struct._unique_str_item_17;
      case 18:
        return _struct._unique_str_item_18;
      case 19:
        return _struct._unique_str_item_19;
      case 20:
        return _struct._unique_str_item_20;
      case 21:
        return _struct._unique_str_item_21;
      case 22:
        return _struct._unique_str_item_22;
      case 23:
        return _struct._unique_str_item_23;
      case 24:
        return _struct._unique_str_item_24;
      case 25:
        return _struct._unique_str_item_25;
      case 26:
        return _struct._unique_str_item_26;
      case 27:
        return _struct._unique_str_item_27;
      case 28:
        return _struct._unique_str_item_28;
      case 29:
        return _struct._unique_str_item_29;
      case 30:
        return _struct._unique_str_item_30;
      case 31:
        return _struct._unique_str_item_31;
      case 32:
        return _struct._unique_str_item_32;
      case 33:
        return _struct._unique_str_item_33;
      case 34:
        return _struct._unique_str_item_34;
      case 35:
        return _struct._unique_str_item_35;
      case 36:
        return _struct._unique_str_item_36;
      case 37:
        return _struct._unique_str_item_37;
      case 38:
        return _struct._unique_str_item_38;
      case 39:
        return _struct._unique_str_item_39;
      case 40:
        return _struct._unique_str_item_40;
      case 41:
        return _struct._unique_str_item_41;
      case 42:
        return _struct._unique_str_item_42;
      case 43:
        return _struct._unique_str_item_43;
      case 44:
        return _struct._unique_str_item_44;
      case 45:
        return _struct._unique_str_item_45;
      case 46:
        return _struct._unique_str_item_46;
      case 47:
        return _struct._unique_str_item_47;
      case 48:
        return _struct._unique_str_item_48;
      case 49:
        return _struct._unique_str_item_49;
      case 50:
        return _struct._unique_str_item_50;
      case 51:
        return _struct._unique_str_item_51;
      case 52:
        return _struct._unique_str_item_52;
      case 53:
        return _struct._unique_str_item_53;
      case 54:
        return _struct._unique_str_item_54;
      case 55:
        return _struct._unique_str_item_55;
      case 56:
        return _struct._unique_str_item_56;
      case 57:
        return _struct._unique_str_item_57;
      case 58:
        return _struct._unique_str_item_58;
      case 59:
        return _struct._unique_str_item_59;
      case 60:
        return _struct._unique_str_item_60;
      case 61:
        return _struct._unique_str_item_61;
      case 62:
        return _struct._unique_str_item_62;
      case 63:
        return _struct._unique_str_item_63;
      case 64:
        return _struct._unique_str_item_64;
      case 65:
        return _struct._unique_str_item_65;
      case 66:
        return _struct._unique_str_item_66;
      case 67:
        return _struct._unique_str_item_67;
      case 68:
        return _struct._unique_str_item_68;
      case 69:
        return _struct._unique_str_item_69;
      case 70:
        return _struct._unique_str_item_70;
      case 71:
        return _struct._unique_str_item_71;
      case 72:
        return _struct._unique_str_item_72;
      case 73:
        return _struct._unique_str_item_73;
      case 74:
        return _struct._unique_str_item_74;
      case 75:
        return _struct._unique_str_item_75;
      case 76:
        return _struct._unique_str_item_76;
      case 77:
        return _struct._unique_str_item_77;
      case 78:
        return _struct._unique_str_item_78;
      case 79:
        return _struct._unique_str_item_79;
      case 80:
        return _struct._unique_str_item_80;
      case 81:
        return _struct._unique_str_item_81;
      case 82:
        return _struct._unique_str_item_82;
      case 83:
        return _struct._unique_str_item_83;
      case 84:
        return _struct._unique_str_item_84;
      case 85:
        return _struct._unique_str_item_85;
      case 86:
        return _struct._unique_str_item_86;
      case 87:
        return _struct._unique_str_item_87;
      case 88:
        return _struct._unique_str_item_88;
      case 89:
        return _struct._unique_str_item_89;
      case 90:
        return _struct._unique_str_item_90;
      case 91:
        return _struct._unique_str_item_91;
      case 92:
        return _struct._unique_str_item_92;
      case 93:
        return _struct._unique_str_item_93;
      case 94:
        return _struct._unique_str_item_94;
      case 95:
        return _struct._unique_str_item_95;
      case 96:
        return _struct._unique_str_item_96;
      case 97:
        return _struct._unique_str_item_97;
      case 98:
        return _struct._unique_str_item_98;
      case 99:
        return _struct._unique_str_item_99;
      case 100:
        return _struct._unique_str_item_100;
      case 101:
        return _struct._unique_str_item_101;
      case 102:
        return _struct._unique_str_item_102;
      case 103:
        return _struct._unique_str_item_103;
      case 104:
        return _struct._unique_str_item_104;
      case 105:
        return _struct._unique_str_item_105;
      case 106:
        return _struct._unique_str_item_106;
      case 107:
        return _struct._unique_str_item_107;
      case 108:
        return _struct._unique_str_item_108;
      case 109:
        return _struct._unique_str_item_109;
      case 110:
        return _struct._unique_str_item_110;
      case 111:
        return _struct._unique_str_item_111;
      case 112:
        return _struct._unique_str_item_112;
      case 113:
        return _struct._unique_str_item_113;
      case 114:
        return _struct._unique_str_item_114;
      case 115:
        return _struct._unique_str_item_115;
      case 116:
        return _struct._unique_str_item_116;
      case 117:
        return _struct._unique_str_item_117;
      case 118:
        return _struct._unique_str_item_118;
      case 119:
        return _struct._unique_str_item_119;
      case 120:
        return _struct._unique_str_item_120;
      case 121:
        return _struct._unique_str_item_121;
      case 122:
        return _struct._unique_str_item_122;
      case 123:
        return _struct._unique_str_item_123;
      case 124:
        return _struct._unique_str_item_124;
      case 125:
        return _struct._unique_str_item_125;
      case 126:
        return _struct._unique_str_item_126;
      case 127:
        return _struct._unique_str_item_127;
      case 128:
        return _struct._unique_str_item_128;
      case 129:
        return _struct._unique_str_item_129;
      case 130:
        return _struct._unique_str_item_130;
      case 131:
        return _struct._unique_str_item_131;
      case 132:
        return _struct._unique_str_item_132;
      case 133:
        return _struct._unique_str_item_133;
      case 134:
        return _struct._unique_str_item_134;
      case 135:
        return _struct._unique_str_item_135;
      case 136:
        return _struct._unique_str_item_136;
      case 137:
        return _struct._unique_str_item_137;
      case 138:
        return _struct._unique_str_item_138;
      case 139:
        return _struct._unique_str_item_139;
      case 140:
        return _struct._unique_str_item_140;
      case 141:
        return _struct._unique_str_item_141;
      case 142:
        return _struct._unique_str_item_142;
      case 143:
        return _struct._unique_str_item_143;
      case 144:
        return _struct._unique_str_item_144;
      case 145:
        return _struct._unique_str_item_145;
      case 146:
        return _struct._unique_str_item_146;
      case 147:
        return _struct._unique_str_item_147;
      case 148:
        return _struct._unique_str_item_148;
      case 149:
        return _struct._unique_str_item_149;
      case 150:
        return _struct._unique_str_item_150;
      case 151:
        return _struct._unique_str_item_151;
      case 152:
        return _struct._unique_str_item_152;
      case 153:
        return _struct._unique_str_item_153;
      case 154:
        return _struct._unique_str_item_154;
      case 155:
        return _struct._unique_str_item_155;
      case 156:
        return _struct._unique_str_item_156;
      case 157:
        return _struct._unique_str_item_157;
      case 158:
        return _struct._unique_str_item_158;
      case 159:
        return _struct._unique_str_item_159;
      case 160:
        return _struct._unique_str_item_160;
      case 161:
        return _struct._unique_str_item_161;
      case 162:
        return _struct._unique_str_item_162;
      case 163:
        return _struct._unique_str_item_163;
      case 164:
        return _struct._unique_str_item_164;
      case 165:
        return _struct._unique_str_item_165;
      case 166:
        return _struct._unique_str_item_166;
      case 167:
        return _struct._unique_str_item_167;
      case 168:
        return _struct._unique_str_item_168;
      case 169:
        return _struct._unique_str_item_169;
      case 170:
        return _struct._unique_str_item_170;
      case 171:
        return _struct._unique_str_item_171;
      case 172:
        return _struct._unique_str_item_172;
      case 173:
        return _struct._unique_str_item_173;
      case 174:
        return _struct._unique_str_item_174;
      case 175:
        return _struct._unique_str_item_175;
      case 176:
        return _struct._unique_str_item_176;
      case 177:
        return _struct._unique_str_item_177;
      case 178:
        return _struct._unique_str_item_178;
      case 179:
        return _struct._unique_str_item_179;
      case 180:
        return _struct._unique_str_item_180;
      case 181:
        return _struct._unique_str_item_181;
      case 182:
        return _struct._unique_str_item_182;
      case 183:
        return _struct._unique_str_item_183;
      case 184:
        return _struct._unique_str_item_184;
      case 185:
        return _struct._unique_str_item_185;
      case 186:
        return _struct._unique_str_item_186;
      case 187:
        return _struct._unique_str_item_187;
      case 188:
        return _struct._unique_str_item_188;
      case 189:
        return _struct._unique_str_item_189;
      case 190:
        return _struct._unique_str_item_190;
      case 191:
        return _struct._unique_str_item_191;
      case 192:
        return _struct._unique_str_item_192;
      case 193:
        return _struct._unique_str_item_193;
      case 194:
        return _struct._unique_str_item_194;
      case 195:
        return _struct._unique_str_item_195;
      case 196:
        return _struct._unique_str_item_196;
      case 197:
        return _struct._unique_str_item_197;
      case 198:
        return _struct._unique_str_item_198;
      case 199:
        return _struct._unique_str_item_199;
      case 200:
        return _struct._unique_str_item_200;
      case 201:
        return _struct._unique_str_item_201;
      case 202:
        return _struct._unique_str_item_202;
      case 203:
        return _struct._unique_str_item_203;
      case 204:
        return _struct._unique_str_item_204;
      case 205:
        return _struct._unique_str_item_205;
      case 206:
        return _struct._unique_str_item_206;
      case 207:
        return _struct._unique_str_item_207;
      case 208:
        return _struct._unique_str_item_208;
      case 209:
        return _struct._unique_str_item_209;
      case 210:
        return _struct._unique_str_item_210;
      case 211:
        return _struct._unique_str_item_211;
      case 212:
        return _struct._unique_str_item_212;
      case 213:
        return _struct._unique_str_item_213;
      case 214:
        return _struct._unique_str_item_214;
      case 215:
        return _struct._unique_str_item_215;
      case 216:
        return _struct._unique_str_item_216;
      case 217:
        return _struct._unique_str_item_217;
      case 218:
        return _struct._unique_str_item_218;
      case 219:
        return _struct._unique_str_item_219;
      case 220:
        return _struct._unique_str_item_220;
      case 221:
        return _struct._unique_str_item_221;
      case 222:
        return _struct._unique_str_item_222;
      case 223:
        return _struct._unique_str_item_223;
      case 224:
        return _struct._unique_str_item_224;
      case 225:
        return _struct._unique_str_item_225;
      case 226:
        return _struct._unique_str_item_226;
      case 227:
        return _struct._unique_str_item_227;
      case 228:
        return _struct._unique_str_item_228;
      case 229:
        return _struct._unique_str_item_229;
      case 230:
        return _struct._unique_str_item_230;
      case 231:
        return _struct._unique_str_item_231;
      case 232:
        return _struct._unique_str_item_232;
      case 233:
        return _struct._unique_str_item_233;
      case 234:
        return _struct._unique_str_item_234;
      case 235:
        return _struct._unique_str_item_235;
      case 236:
        return _struct._unique_str_item_236;
      case 237:
        return _struct._unique_str_item_237;
      case 238:
        return _struct._unique_str_item_238;
      case 239:
        return _struct._unique_str_item_239;
      case 240:
        return _struct._unique_str_item_240;
      case 241:
        return _struct._unique_str_item_241;
      case 242:
        return _struct._unique_str_item_242;
      case 243:
        return _struct._unique_str_item_243;
      case 244:
        return _struct._unique_str_item_244;
      case 245:
        return _struct._unique_str_item_245;
      case 246:
        return _struct._unique_str_item_246;
      case 247:
        return _struct._unique_str_item_247;
      case 248:
        return _struct._unique_str_item_248;
      case 249:
        return _struct._unique_str_item_249;
      case 250:
        return _struct._unique_str_item_250;
      case 251:
        return _struct._unique_str_item_251;
      case 252:
        return _struct._unique_str_item_252;
      case 253:
        return _struct._unique_str_item_253;
      case 254:
        return _struct._unique_str_item_254;
      case 255:
        return _struct._unique_str_item_255;
      case 256:
        return _struct._unique_str_item_256;
      case 257:
        return _struct._unique_str_item_257;
      case 258:
        return _struct._unique_str_item_258;
      case 259:
        return _struct._unique_str_item_259;
      case 260:
        return _struct._unique_str_item_260;
      case 261:
        return _struct._unique_str_item_261;
      case 262:
        return _struct._unique_str_item_262;
      case 263:
        return _struct._unique_str_item_263;
      case 264:
        return _struct._unique_str_item_264;
      case 265:
        return _struct._unique_str_item_265;
      case 266:
        return _struct._unique_str_item_266;
      case 267:
        return _struct._unique_str_item_267;
      case 268:
        return _struct._unique_str_item_268;
      case 269:
        return _struct._unique_str_item_269;
      case 270:
        return _struct._unique_str_item_270;
      case 271:
        return _struct._unique_str_item_271;
      case 272:
        return _struct._unique_str_item_272;
      case 273:
        return _struct._unique_str_item_273;
      case 274:
        return _struct._unique_str_item_274;
      case 275:
        return _struct._unique_str_item_275;
      case 276:
        return _struct._unique_str_item_276;
      case 277:
        return _struct._unique_str_item_277;
      case 278:
        return _struct._unique_str_item_278;
      case 279:
        return _struct._unique_str_item_279;
      case 280:
        return _struct._unique_str_item_280;
      case 281:
        return _struct._unique_str_item_281;
      case 282:
        return _struct._unique_str_item_282;
      case 283:
        return _struct._unique_str_item_283;
      case 284:
        return _struct._unique_str_item_284;
      case 285:
        return _struct._unique_str_item_285;
      case 286:
        return _struct._unique_str_item_286;
      case 287:
        return _struct._unique_str_item_287;
      case 288:
        return _struct._unique_str_item_288;
      case 289:
        return _struct._unique_str_item_289;
      case 290:
        return _struct._unique_str_item_290;
      case 291:
        return _struct._unique_str_item_291;
      case 292:
        return _struct._unique_str_item_292;
      case 293:
        return _struct._unique_str_item_293;
      case 294:
        return _struct._unique_str_item_294;
      case 295:
        return _struct._unique_str_item_295;
      case 296:
        return _struct._unique_str_item_296;
      case 297:
        return _struct._unique_str_item_297;
      case 298:
        return _struct._unique_str_item_298;
      case 299:
        return _struct._unique_str_item_299;
      case 300:
        return _struct._unique_str_item_300;
      case 301:
        return _struct._unique_str_item_301;
      case 302:
        return _struct._unique_str_item_302;
      case 303:
        return _struct._unique_str_item_303;
      case 304:
        return _struct._unique_str_item_304;
      case 305:
        return _struct._unique_str_item_305;
      case 306:
        return _struct._unique_str_item_306;
      case 307:
        return _struct._unique_str_item_307;
      case 308:
        return _struct._unique_str_item_308;
      case 309:
        return _struct._unique_str_item_309;
      case 310:
        return _struct._unique_str_item_310;
      case 311:
        return _struct._unique_str_item_311;
      case 312:
        return _struct._unique_str_item_312;
      case 313:
        return _struct._unique_str_item_313;
      case 314:
        return _struct._unique_str_item_314;
      case 315:
        return _struct._unique_str_item_315;
      case 316:
        return _struct._unique_str_item_316;
      case 317:
        return _struct._unique_str_item_317;
      case 318:
        return _struct._unique_str_item_318;
      case 319:
        return _struct._unique_str_item_319;
      case 320:
        return _struct._unique_str_item_320;
      case 321:
        return _struct._unique_str_item_321;
      case 322:
        return _struct._unique_str_item_322;
      case 323:
        return _struct._unique_str_item_323;
      case 324:
        return _struct._unique_str_item_324;
      case 325:
        return _struct._unique_str_item_325;
      case 326:
        return _struct._unique_str_item_326;
      case 327:
        return _struct._unique_str_item_327;
      case 328:
        return _struct._unique_str_item_328;
      case 329:
        return _struct._unique_str_item_329;
      case 330:
        return _struct._unique_str_item_330;
      case 331:
        return _struct._unique_str_item_331;
      case 332:
        return _struct._unique_str_item_332;
      case 333:
        return _struct._unique_str_item_333;
      case 334:
        return _struct._unique_str_item_334;
      case 335:
        return _struct._unique_str_item_335;
      case 336:
        return _struct._unique_str_item_336;
      case 337:
        return _struct._unique_str_item_337;
      case 338:
        return _struct._unique_str_item_338;
      case 339:
        return _struct._unique_str_item_339;
      case 340:
        return _struct._unique_str_item_340;
      case 341:
        return _struct._unique_str_item_341;
      case 342:
        return _struct._unique_str_item_342;
      case 343:
        return _struct._unique_str_item_343;
      case 344:
        return _struct._unique_str_item_344;
      case 345:
        return _struct._unique_str_item_345;
      case 346:
        return _struct._unique_str_item_346;
      case 347:
        return _struct._unique_str_item_347;
      case 348:
        return _struct._unique_str_item_348;
      case 349:
        return _struct._unique_str_item_349;
      case 350:
        return _struct._unique_str_item_350;
      case 351:
        return _struct._unique_str_item_351;
      case 352:
        return _struct._unique_str_item_352;
      case 353:
        return _struct._unique_str_item_353;
      case 354:
        return _struct._unique_str_item_354;
      case 355:
        return _struct._unique_str_item_355;
      case 356:
        return _struct._unique_str_item_356;
      case 357:
        return _struct._unique_str_item_357;
      case 358:
        return _struct._unique_str_item_358;
      case 359:
        return _struct._unique_str_item_359;
      case 360:
        return _struct._unique_str_item_360;
      case 361:
        return _struct._unique_str_item_361;
      case 362:
        return _struct._unique_str_item_362;
      case 363:
        return _struct._unique_str_item_363;
      case 364:
        return _struct._unique_str_item_364;
      case 365:
        return _struct._unique_str_item_365;
      case 366:
        return _struct._unique_str_item_366;
      case 367:
        return _struct._unique_str_item_367;
      case 368:
        return _struct._unique_str_item_368;
      case 369:
        return _struct._unique_str_item_369;
      case 370:
        return _struct._unique_str_item_370;
      case 371:
        return _struct._unique_str_item_371;
      case 372:
        return _struct._unique_str_item_372;
      case 373:
        return _struct._unique_str_item_373;
      case 374:
        return _struct._unique_str_item_374;
      case 375:
        return _struct._unique_str_item_375;
      case 376:
        return _struct._unique_str_item_376;
      case 377:
        return _struct._unique_str_item_377;
      case 378:
        return _struct._unique_str_item_378;
      case 379:
        return _struct._unique_str_item_379;
      case 380:
        return _struct._unique_str_item_380;
      case 381:
        return _struct._unique_str_item_381;
      case 382:
        return _struct._unique_str_item_382;
      case 383:
        return _struct._unique_str_item_383;
      case 384:
        return _struct._unique_str_item_384;
      case 385:
        return _struct._unique_str_item_385;
      case 386:
        return _struct._unique_str_item_386;
      case 387:
        return _struct._unique_str_item_387;
      case 388:
        return _struct._unique_str_item_388;
      case 389:
        return _struct._unique_str_item_389;
      case 390:
        return _struct._unique_str_item_390;
      case 391:
        return _struct._unique_str_item_391;
      case 392:
        return _struct._unique_str_item_392;
      case 393:
        return _struct._unique_str_item_393;
      case 394:
        return _struct._unique_str_item_394;
      case 395:
        return _struct._unique_str_item_395;
      case 396:
        return _struct._unique_str_item_396;
      case 397:
        return _struct._unique_str_item_397;
      case 398:
        return _struct._unique_str_item_398;
      case 399:
        return _struct._unique_str_item_399;
      case 400:
        return _struct._unique_str_item_400;
      case 401:
        return _struct._unique_str_item_401;
      case 402:
        return _struct._unique_str_item_402;
      case 403:
        return _struct._unique_str_item_403;
      case 404:
        return _struct._unique_str_item_404;
      case 405:
        return _struct._unique_str_item_405;
      case 406:
        return _struct._unique_str_item_406;
      case 407:
        return _struct._unique_str_item_407;
      case 408:
        return _struct._unique_str_item_408;
      case 409:
        return _struct._unique_str_item_409;
      case 410:
        return _struct._unique_str_item_410;
      case 411:
        return _struct._unique_str_item_411;
      case 412:
        return _struct._unique_str_item_412;
      case 413:
        return _struct._unique_str_item_413;
      case 414:
        return _struct._unique_str_item_414;
      case 415:
        return _struct._unique_str_item_415;
      case 416:
        return _struct._unique_str_item_416;
      case 417:
        return _struct._unique_str_item_417;
      case 418:
        return _struct._unique_str_item_418;
      case 419:
        return _struct._unique_str_item_419;
      case 420:
        return _struct._unique_str_item_420;
      case 421:
        return _struct._unique_str_item_421;
      case 422:
        return _struct._unique_str_item_422;
      case 423:
        return _struct._unique_str_item_423;
      case 424:
        return _struct._unique_str_item_424;
      case 425:
        return _struct._unique_str_item_425;
      case 426:
        return _struct._unique_str_item_426;
      case 427:
        return _struct._unique_str_item_427;
      case 428:
        return _struct._unique_str_item_428;
      case 429:
        return _struct._unique_str_item_429;
      case 430:
        return _struct._unique_str_item_430;
      case 431:
        return _struct._unique_str_item_431;
      case 432:
        return _struct._unique_str_item_432;
      case 433:
        return _struct._unique_str_item_433;
      case 434:
        return _struct._unique_str_item_434;
      case 435:
        return _struct._unique_str_item_435;
      case 436:
        return _struct._unique_str_item_436;
      case 437:
        return _struct._unique_str_item_437;
      case 438:
        return _struct._unique_str_item_438;
      case 439:
        return _struct._unique_str_item_439;
      case 440:
        return _struct._unique_str_item_440;
      case 441:
        return _struct._unique_str_item_441;
      case 442:
        return _struct._unique_str_item_442;
      case 443:
        return _struct._unique_str_item_443;
      case 444:
        return _struct._unique_str_item_444;
      case 445:
        return _struct._unique_str_item_445;
      case 446:
        return _struct._unique_str_item_446;
      case 447:
        return _struct._unique_str_item_447;
      case 448:
        return _struct._unique_str_item_448;
      case 449:
        return _struct._unique_str_item_449;
      case 450:
        return _struct._unique_str_item_450;
      case 451:
        return _struct._unique_str_item_451;
      case 452:
        return _struct._unique_str_item_452;
      case 453:
        return _struct._unique_str_item_453;
      case 454:
        return _struct._unique_str_item_454;
      case 455:
        return _struct._unique_str_item_455;
      case 456:
        return _struct._unique_str_item_456;
      case 457:
        return _struct._unique_str_item_457;
      case 458:
        return _struct._unique_str_item_458;
      case 459:
        return _struct._unique_str_item_459;
      case 460:
        return _struct._unique_str_item_460;
      case 461:
        return _struct._unique_str_item_461;
      case 462:
        return _struct._unique_str_item_462;
      case 463:
        return _struct._unique_str_item_463;
      case 464:
        return _struct._unique_str_item_464;
      case 465:
        return _struct._unique_str_item_465;
      case 466:
        return _struct._unique_str_item_466;
      case 467:
        return _struct._unique_str_item_467;
      case 468:
        return _struct._unique_str_item_468;
      case 469:
        return _struct._unique_str_item_469;
      case 470:
        return _struct._unique_str_item_470;
      case 471:
        return _struct._unique_str_item_471;
      case 472:
        return _struct._unique_str_item_472;
      case 473:
        return _struct._unique_str_item_473;
      case 474:
        return _struct._unique_str_item_474;
      case 475:
        return _struct._unique_str_item_475;
      case 476:
        return _struct._unique_str_item_476;
      case 477:
        return _struct._unique_str_item_477;
      case 478:
        return _struct._unique_str_item_478;
      case 479:
        return _struct._unique_str_item_479;
      case 480:
        return _struct._unique_str_item_480;
      case 481:
        return _struct._unique_str_item_481;
      case 482:
        return _struct._unique_str_item_482;
      case 483:
        return _struct._unique_str_item_483;
      case 484:
        return _struct._unique_str_item_484;
      case 485:
        return _struct._unique_str_item_485;
      case 486:
        return _struct._unique_str_item_486;
      case 487:
        return _struct._unique_str_item_487;
      case 488:
        return _struct._unique_str_item_488;
      case 489:
        return _struct._unique_str_item_489;
      case 490:
        return _struct._unique_str_item_490;
      case 491:
        return _struct._unique_str_item_491;
      case 492:
        return _struct._unique_str_item_492;
      case 493:
        return _struct._unique_str_item_493;
      case 494:
        return _struct._unique_str_item_494;
      case 495:
        return _struct._unique_str_item_495;
      case 496:
        return _struct._unique_str_item_496;
      case 497:
        return _struct._unique_str_item_497;
      case 498:
        return _struct._unique_str_item_498;
      case 499:
        return _struct._unique_str_item_499;
      case 500:
        return _struct._unique_str_item_500;
      case 501:
        return _struct._unique_str_item_501;
      case 502:
        return _struct._unique_str_item_502;
      case 503:
        return _struct._unique_str_item_503;
      case 504:
        return _struct._unique_str_item_504;
      case 505:
        return _struct._unique_str_item_505;
      case 506:
        return _struct._unique_str_item_506;
      case 507:
        return _struct._unique_str_item_507;
      case 508:
        return _struct._unique_str_item_508;
      case 509:
        return _struct._unique_str_item_509;
      case 510:
        return _struct._unique_str_item_510;
      case 511:
        return _struct._unique_str_item_511;
      case 512:
        return _struct._unique_str_item_512;
      case 513:
        return _struct._unique_str_item_513;
      case 514:
        return _struct._unique_str_item_514;
      case 515:
        return _struct._unique_str_item_515;
      case 516:
        return _struct._unique_str_item_516;
      case 517:
        return _struct._unique_str_item_517;
      case 518:
        return _struct._unique_str_item_518;
      case 519:
        return _struct._unique_str_item_519;
      case 520:
        return _struct._unique_str_item_520;
      case 521:
        return _struct._unique_str_item_521;
      case 522:
        return _struct._unique_str_item_522;
      case 523:
        return _struct._unique_str_item_523;
      case 524:
        return _struct._unique_str_item_524;
      case 525:
        return _struct._unique_str_item_525;
      case 526:
        return _struct._unique_str_item_526;
      case 527:
        return _struct._unique_str_item_527;
      case 528:
        return _struct._unique_str_item_528;
      case 529:
        return _struct._unique_str_item_529;
      case 530:
        return _struct._unique_str_item_530;
      case 531:
        return _struct._unique_str_item_531;
      case 532:
        return _struct._unique_str_item_532;
      case 533:
        return _struct._unique_str_item_533;
      case 534:
        return _struct._unique_str_item_534;
      case 535:
        return _struct._unique_str_item_535;
      case 536:
        return _struct._unique_str_item_536;
      case 537:
        return _struct._unique_str_item_537;
      case 538:
        return _struct._unique_str_item_538;
      case 539:
        return _struct._unique_str_item_539;
      case 540:
        return _struct._unique_str_item_540;
      case 541:
        return _struct._unique_str_item_541;
      case 542:
        return _struct._unique_str_item_542;
      case 543:
        return _struct._unique_str_item_543;
      case 544:
        return _struct._unique_str_item_544;
      case 545:
        return _struct._unique_str_item_545;
      case 546:
        return _struct._unique_str_item_546;
      case 547:
        return _struct._unique_str_item_547;
      case 548:
        return _struct._unique_str_item_548;
      case 549:
        return _struct._unique_str_item_549;
      case 550:
        return _struct._unique_str_item_550;
      case 551:
        return _struct._unique_str_item_551;
      case 552:
        return _struct._unique_str_item_552;
      case 553:
        return _struct._unique_str_item_553;
      case 554:
        return _struct._unique_str_item_554;
      case 555:
        return _struct._unique_str_item_555;
      case 556:
        return _struct._unique_str_item_556;
      case 557:
        return _struct._unique_str_item_557;
      case 558:
        return _struct._unique_str_item_558;
      case 559:
        return _struct._unique_str_item_559;
      case 560:
        return _struct._unique_str_item_560;
      case 561:
        return _struct._unique_str_item_561;
      case 562:
        return _struct._unique_str_item_562;
      case 563:
        return _struct._unique_str_item_563;
      case 564:
        return _struct._unique_str_item_564;
      case 565:
        return _struct._unique_str_item_565;
      case 566:
        return _struct._unique_str_item_566;
      case 567:
        return _struct._unique_str_item_567;
      case 568:
        return _struct._unique_str_item_568;
      case 569:
        return _struct._unique_str_item_569;
      case 570:
        return _struct._unique_str_item_570;
      case 571:
        return _struct._unique_str_item_571;
      case 572:
        return _struct._unique_str_item_572;
      case 573:
        return _struct._unique_str_item_573;
      case 574:
        return _struct._unique_str_item_574;
      case 575:
        return _struct._unique_str_item_575;
      case 576:
        return _struct._unique_str_item_576;
      case 577:
        return _struct._unique_str_item_577;
      case 578:
        return _struct._unique_str_item_578;
      case 579:
        return _struct._unique_str_item_579;
      case 580:
        return _struct._unique_str_item_580;
      case 581:
        return _struct._unique_str_item_581;
      case 582:
        return _struct._unique_str_item_582;
      case 583:
        return _struct._unique_str_item_583;
      case 584:
        return _struct._unique_str_item_584;
      case 585:
        return _struct._unique_str_item_585;
      case 586:
        return _struct._unique_str_item_586;
      case 587:
        return _struct._unique_str_item_587;
      case 588:
        return _struct._unique_str_item_588;
      case 589:
        return _struct._unique_str_item_589;
      case 590:
        return _struct._unique_str_item_590;
      case 591:
        return _struct._unique_str_item_591;
      case 592:
        return _struct._unique_str_item_592;
      case 593:
        return _struct._unique_str_item_593;
      case 594:
        return _struct._unique_str_item_594;
      case 595:
        return _struct._unique_str_item_595;
      case 596:
        return _struct._unique_str_item_596;
      case 597:
        return _struct._unique_str_item_597;
      case 598:
        return _struct._unique_str_item_598;
      case 599:
        return _struct._unique_str_item_599;
      case 600:
        return _struct._unique_str_item_600;
      case 601:
        return _struct._unique_str_item_601;
      case 602:
        return _struct._unique_str_item_602;
      case 603:
        return _struct._unique_str_item_603;
      case 604:
        return _struct._unique_str_item_604;
      case 605:
        return _struct._unique_str_item_605;
      case 606:
        return _struct._unique_str_item_606;
      case 607:
        return _struct._unique_str_item_607;
      case 608:
        return _struct._unique_str_item_608;
      case 609:
        return _struct._unique_str_item_609;
      case 610:
        return _struct._unique_str_item_610;
      case 611:
        return _struct._unique_str_item_611;
      case 612:
        return _struct._unique_str_item_612;
      case 613:
        return _struct._unique_str_item_613;
      case 614:
        return _struct._unique_str_item_614;
      case 615:
        return _struct._unique_str_item_615;
      case 616:
        return _struct._unique_str_item_616;
      case 617:
        return _struct._unique_str_item_617;
      case 618:
        return _struct._unique_str_item_618;
      case 619:
        return _struct._unique_str_item_619;
      case 620:
        return _struct._unique_str_item_620;
      case 621:
        return _struct._unique_str_item_621;
      case 622:
        return _struct._unique_str_item_622;
      case 623:
        return _struct._unique_str_item_623;
      case 624:
        return _struct._unique_str_item_624;
      case 625:
        return _struct._unique_str_item_625;
      case 626:
        return _struct._unique_str_item_626;
      case 627:
        return _struct._unique_str_item_627;
      case 628:
        return _struct._unique_str_item_628;
      case 629:
        return _struct._unique_str_item_629;
      case 630:
        return _struct._unique_str_item_630;
      case 631:
        return _struct._unique_str_item_631;
      case 632:
        return _struct._unique_str_item_632;
      case 633:
        return _struct._unique_str_item_633;
      case 634:
        return _struct._unique_str_item_634;
      case 635:
        return _struct._unique_str_item_635;
      case 636:
        return _struct._unique_str_item_636;
      case 637:
        return _struct._unique_str_item_637;
      case 638:
        return _struct._unique_str_item_638;
      case 639:
        return _struct._unique_str_item_639;
      case 640:
        return _struct._unique_str_item_640;
      case 641:
        return _struct._unique_str_item_641;
      case 642:
        return _struct._unique_str_item_642;
      case 643:
        return _struct._unique_str_item_643;
      case 644:
        return _struct._unique_str_item_644;
      case 645:
        return _struct._unique_str_item_645;
      case 646:
        return _struct._unique_str_item_646;
      case 647:
        return _struct._unique_str_item_647;
      case 648:
        return _struct._unique_str_item_648;
      case 649:
        return _struct._unique_str_item_649;
      case 650:
        return _struct._unique_str_item_650;
      case 651:
        return _struct._unique_str_item_651;
      case 652:
        return _struct._unique_str_item_652;
      case 653:
        return _struct._unique_str_item_653;
      case 654:
        return _struct._unique_str_item_654;
      case 655:
        return _struct._unique_str_item_655;
      case 656:
        return _struct._unique_str_item_656;
      case 657:
        return _struct._unique_str_item_657;
      case 658:
        return _struct._unique_str_item_658;
      case 659:
        return _struct._unique_str_item_659;
      case 660:
        return _struct._unique_str_item_660;
      case 661:
        return _struct._unique_str_item_661;
      case 662:
        return _struct._unique_str_item_662;
      case 663:
        return _struct._unique_str_item_663;
      case 664:
        return _struct._unique_str_item_664;
      case 665:
        return _struct._unique_str_item_665;
      case 666:
        return _struct._unique_str_item_666;
      case 667:
        return _struct._unique_str_item_667;
      case 668:
        return _struct._unique_str_item_668;
      case 669:
        return _struct._unique_str_item_669;
      case 670:
        return _struct._unique_str_item_670;
      case 671:
        return _struct._unique_str_item_671;
      case 672:
        return _struct._unique_str_item_672;
      case 673:
        return _struct._unique_str_item_673;
      case 674:
        return _struct._unique_str_item_674;
      case 675:
        return _struct._unique_str_item_675;
      case 676:
        return _struct._unique_str_item_676;
      case 677:
        return _struct._unique_str_item_677;
      case 678:
        return _struct._unique_str_item_678;
      case 679:
        return _struct._unique_str_item_679;
      case 680:
        return _struct._unique_str_item_680;
      case 681:
        return _struct._unique_str_item_681;
      case 682:
        return _struct._unique_str_item_682;
      case 683:
        return _struct._unique_str_item_683;
      case 684:
        return _struct._unique_str_item_684;
      case 685:
        return _struct._unique_str_item_685;
      case 686:
        return _struct._unique_str_item_686;
      case 687:
        return _struct._unique_str_item_687;
      case 688:
        return _struct._unique_str_item_688;
      case 689:
        return _struct._unique_str_item_689;
      case 690:
        return _struct._unique_str_item_690;
      case 691:
        return _struct._unique_str_item_691;
      case 692:
        return _struct._unique_str_item_692;
      case 693:
        return _struct._unique_str_item_693;
      case 694:
        return _struct._unique_str_item_694;
      case 695:
        return _struct._unique_str_item_695;
      case 696:
        return _struct._unique_str_item_696;
      case 697:
        return _struct._unique_str_item_697;
      case 698:
        return _struct._unique_str_item_698;
      case 699:
        return _struct._unique_str_item_699;
      case 700:
        return _struct._unique_str_item_700;
      case 701:
        return _struct._unique_str_item_701;
      case 702:
        return _struct._unique_str_item_702;
      case 703:
        return _struct._unique_str_item_703;
      case 704:
        return _struct._unique_str_item_704;
      case 705:
        return _struct._unique_str_item_705;
      case 706:
        return _struct._unique_str_item_706;
      case 707:
        return _struct._unique_str_item_707;
      case 708:
        return _struct._unique_str_item_708;
      case 709:
        return _struct._unique_str_item_709;
      case 710:
        return _struct._unique_str_item_710;
      case 711:
        return _struct._unique_str_item_711;
      case 712:
        return _struct._unique_str_item_712;
      case 713:
        return _struct._unique_str_item_713;
      case 714:
        return _struct._unique_str_item_714;
      case 715:
        return _struct._unique_str_item_715;
      case 716:
        return _struct._unique_str_item_716;
      case 717:
        return _struct._unique_str_item_717;
      case 718:
        return _struct._unique_str_item_718;
      case 719:
        return _struct._unique_str_item_719;
      case 720:
        return _struct._unique_str_item_720;
      case 721:
        return _struct._unique_str_item_721;
      case 722:
        return _struct._unique_str_item_722;
      case 723:
        return _struct._unique_str_item_723;
      case 724:
        return _struct._unique_str_item_724;
      case 725:
        return _struct._unique_str_item_725;
      case 726:
        return _struct._unique_str_item_726;
      case 727:
        return _struct._unique_str_item_727;
      case 728:
        return _struct._unique_str_item_728;
      case 729:
        return _struct._unique_str_item_729;
      case 730:
        return _struct._unique_str_item_730;
      case 731:
        return _struct._unique_str_item_731;
      case 732:
        return _struct._unique_str_item_732;
      case 733:
        return _struct._unique_str_item_733;
      case 734:
        return _struct._unique_str_item_734;
      case 735:
        return _struct._unique_str_item_735;
      case 736:
        return _struct._unique_str_item_736;
      case 737:
        return _struct._unique_str_item_737;
      case 738:
        return _struct._unique_str_item_738;
      case 739:
        return _struct._unique_str_item_739;
      case 740:
        return _struct._unique_str_item_740;
      case 741:
        return _struct._unique_str_item_741;
      case 742:
        return _struct._unique_str_item_742;
      case 743:
        return _struct._unique_str_item_743;
      case 744:
        return _struct._unique_str_item_744;
      case 745:
        return _struct._unique_str_item_745;
      case 746:
        return _struct._unique_str_item_746;
      case 747:
        return _struct._unique_str_item_747;
      case 748:
        return _struct._unique_str_item_748;
      case 749:
        return _struct._unique_str_item_749;
      case 750:
        return _struct._unique_str_item_750;
      case 751:
        return _struct._unique_str_item_751;
      case 752:
        return _struct._unique_str_item_752;
      case 753:
        return _struct._unique_str_item_753;
      case 754:
        return _struct._unique_str_item_754;
      case 755:
        return _struct._unique_str_item_755;
      case 756:
        return _struct._unique_str_item_756;
      case 757:
        return _struct._unique_str_item_757;
      case 758:
        return _struct._unique_str_item_758;
      case 759:
        return _struct._unique_str_item_759;
      case 760:
        return _struct._unique_str_item_760;
      case 761:
        return _struct._unique_str_item_761;
      case 762:
        return _struct._unique_str_item_762;
      case 763:
        return _struct._unique_str_item_763;
      case 764:
        return _struct._unique_str_item_764;
      case 765:
        return _struct._unique_str_item_765;
      case 766:
        return _struct._unique_str_item_766;
      case 767:
        return _struct._unique_str_item_767;
      case 768:
        return _struct._unique_str_item_768;
      case 769:
        return _struct._unique_str_item_769;
      case 770:
        return _struct._unique_str_item_770;
      case 771:
        return _struct._unique_str_item_771;
      case 772:
        return _struct._unique_str_item_772;
      case 773:
        return _struct._unique_str_item_773;
      case 774:
        return _struct._unique_str_item_774;
      case 775:
        return _struct._unique_str_item_775;
      case 776:
        return _struct._unique_str_item_776;
      case 777:
        return _struct._unique_str_item_777;
      case 778:
        return _struct._unique_str_item_778;
      case 779:
        return _struct._unique_str_item_779;
      case 780:
        return _struct._unique_str_item_780;
      case 781:
        return _struct._unique_str_item_781;
      case 782:
        return _struct._unique_str_item_782;
      case 783:
        return _struct._unique_str_item_783;
      case 784:
        return _struct._unique_str_item_784;
      case 785:
        return _struct._unique_str_item_785;
      case 786:
        return _struct._unique_str_item_786;
      case 787:
        return _struct._unique_str_item_787;
      case 788:
        return _struct._unique_str_item_788;
      case 789:
        return _struct._unique_str_item_789;
      case 790:
        return _struct._unique_str_item_790;
      case 791:
        return _struct._unique_str_item_791;
      case 792:
        return _struct._unique_str_item_792;
      case 793:
        return _struct._unique_str_item_793;
      case 794:
        return _struct._unique_str_item_794;
      case 795:
        return _struct._unique_str_item_795;
      case 796:
        return _struct._unique_str_item_796;
      case 797:
        return _struct._unique_str_item_797;
      case 798:
        return _struct._unique_str_item_798;
      case 799:
        return _struct._unique_str_item_799;
      case 800:
        return _struct._unique_str_item_800;
      case 801:
        return _struct._unique_str_item_801;
      case 802:
        return _struct._unique_str_item_802;
      case 803:
        return _struct._unique_str_item_803;
      case 804:
        return _struct._unique_str_item_804;
      case 805:
        return _struct._unique_str_item_805;
      case 806:
        return _struct._unique_str_item_806;
      case 807:
        return _struct._unique_str_item_807;
      case 808:
        return _struct._unique_str_item_808;
      case 809:
        return _struct._unique_str_item_809;
      case 810:
        return _struct._unique_str_item_810;
      case 811:
        return _struct._unique_str_item_811;
      case 812:
        return _struct._unique_str_item_812;
      case 813:
        return _struct._unique_str_item_813;
      case 814:
        return _struct._unique_str_item_814;
      case 815:
        return _struct._unique_str_item_815;
      case 816:
        return _struct._unique_str_item_816;
      case 817:
        return _struct._unique_str_item_817;
      case 818:
        return _struct._unique_str_item_818;
      case 819:
        return _struct._unique_str_item_819;
      case 820:
        return _struct._unique_str_item_820;
      case 821:
        return _struct._unique_str_item_821;
      case 822:
        return _struct._unique_str_item_822;
      case 823:
        return _struct._unique_str_item_823;
      case 824:
        return _struct._unique_str_item_824;
      case 825:
        return _struct._unique_str_item_825;
      case 826:
        return _struct._unique_str_item_826;
      case 827:
        return _struct._unique_str_item_827;
      case 828:
        return _struct._unique_str_item_828;
      case 829:
        return _struct._unique_str_item_829;
      case 830:
        return _struct._unique_str_item_830;
      case 831:
        return _struct._unique_str_item_831;
      case 832:
        return _struct._unique_str_item_832;
      case 833:
        return _struct._unique_str_item_833;
      case 834:
        return _struct._unique_str_item_834;
      case 835:
        return _struct._unique_str_item_835;
      case 836:
        return _struct._unique_str_item_836;
      case 837:
        return _struct._unique_str_item_837;
      case 838:
        return _struct._unique_str_item_838;
      case 839:
        return _struct._unique_str_item_839;
      case 840:
        return _struct._unique_str_item_840;
      case 841:
        return _struct._unique_str_item_841;
      case 842:
        return _struct._unique_str_item_842;
      case 843:
        return _struct._unique_str_item_843;
      case 844:
        return _struct._unique_str_item_844;
      case 845:
        return _struct._unique_str_item_845;
      case 846:
        return _struct._unique_str_item_846;
      case 847:
        return _struct._unique_str_item_847;
      case 848:
        return _struct._unique_str_item_848;
      case 849:
        return _struct._unique_str_item_849;
      case 850:
        return _struct._unique_str_item_850;
      case 851:
        return _struct._unique_str_item_851;
      case 852:
        return _struct._unique_str_item_852;
      case 853:
        return _struct._unique_str_item_853;
      case 854:
        return _struct._unique_str_item_854;
      case 855:
        return _struct._unique_str_item_855;
      case 856:
        return _struct._unique_str_item_856;
      case 857:
        return _struct._unique_str_item_857;
      case 858:
        return _struct._unique_str_item_858;
      case 859:
        return _struct._unique_str_item_859;
      case 860:
        return _struct._unique_str_item_860;
      case 861:
        return _struct._unique_str_item_861;
      case 862:
        return _struct._unique_str_item_862;
      case 863:
        return _struct._unique_str_item_863;
      case 864:
        return _struct._unique_str_item_864;
      case 865:
        return _struct._unique_str_item_865;
      case 866:
        return _struct._unique_str_item_866;
      case 867:
        return _struct._unique_str_item_867;
      case 868:
        return _struct._unique_str_item_868;
      case 869:
        return _struct._unique_str_item_869;
      case 870:
        return _struct._unique_str_item_870;
      case 871:
        return _struct._unique_str_item_871;
      case 872:
        return _struct._unique_str_item_872;
      case 873:
        return _struct._unique_str_item_873;
      case 874:
        return _struct._unique_str_item_874;
      case 875:
        return _struct._unique_str_item_875;
      case 876:
        return _struct._unique_str_item_876;
      case 877:
        return _struct._unique_str_item_877;
      case 878:
        return _struct._unique_str_item_878;
      case 879:
        return _struct._unique_str_item_879;
      case 880:
        return _struct._unique_str_item_880;
      case 881:
        return _struct._unique_str_item_881;
      case 882:
        return _struct._unique_str_item_882;
      case 883:
        return _struct._unique_str_item_883;
      case 884:
        return _struct._unique_str_item_884;
      case 885:
        return _struct._unique_str_item_885;
      case 886:
        return _struct._unique_str_item_886;
      case 887:
        return _struct._unique_str_item_887;
      case 888:
        return _struct._unique_str_item_888;
      case 889:
        return _struct._unique_str_item_889;
      case 890:
        return _struct._unique_str_item_890;
      case 891:
        return _struct._unique_str_item_891;
      case 892:
        return _struct._unique_str_item_892;
      case 893:
        return _struct._unique_str_item_893;
      case 894:
        return _struct._unique_str_item_894;
      case 895:
        return _struct._unique_str_item_895;
      case 896:
        return _struct._unique_str_item_896;
      case 897:
        return _struct._unique_str_item_897;
      case 898:
        return _struct._unique_str_item_898;
      case 899:
        return _struct._unique_str_item_899;
      case 900:
        return _struct._unique_str_item_900;
      case 901:
        return _struct._unique_str_item_901;
      case 902:
        return _struct._unique_str_item_902;
      case 903:
        return _struct._unique_str_item_903;
      case 904:
        return _struct._unique_str_item_904;
      case 905:
        return _struct._unique_str_item_905;
      case 906:
        return _struct._unique_str_item_906;
      case 907:
        return _struct._unique_str_item_907;
      case 908:
        return _struct._unique_str_item_908;
      case 909:
        return _struct._unique_str_item_909;
      case 910:
        return _struct._unique_str_item_910;
      case 911:
        return _struct._unique_str_item_911;
      case 912:
        return _struct._unique_str_item_912;
      case 913:
        return _struct._unique_str_item_913;
      case 914:
        return _struct._unique_str_item_914;
      case 915:
        return _struct._unique_str_item_915;
      case 916:
        return _struct._unique_str_item_916;
      case 917:
        return _struct._unique_str_item_917;
      case 918:
        return _struct._unique_str_item_918;
      case 919:
        return _struct._unique_str_item_919;
      case 920:
        return _struct._unique_str_item_920;
      case 921:
        return _struct._unique_str_item_921;
      case 922:
        return _struct._unique_str_item_922;
      case 923:
        return _struct._unique_str_item_923;
      case 924:
        return _struct._unique_str_item_924;
      case 925:
        return _struct._unique_str_item_925;
      case 926:
        return _struct._unique_str_item_926;
      case 927:
        return _struct._unique_str_item_927;
      case 928:
        return _struct._unique_str_item_928;
      case 929:
        return _struct._unique_str_item_929;
      case 930:
        return _struct._unique_str_item_930;
      case 931:
        return _struct._unique_str_item_931;
      case 932:
        return _struct._unique_str_item_932;
      case 933:
        return _struct._unique_str_item_933;
      case 934:
        return _struct._unique_str_item_934;
      case 935:
        return _struct._unique_str_item_935;
      case 936:
        return _struct._unique_str_item_936;
      case 937:
        return _struct._unique_str_item_937;
      case 938:
        return _struct._unique_str_item_938;
      case 939:
        return _struct._unique_str_item_939;
      case 940:
        return _struct._unique_str_item_940;
      case 941:
        return _struct._unique_str_item_941;
      case 942:
        return _struct._unique_str_item_942;
      case 943:
        return _struct._unique_str_item_943;
      case 944:
        return _struct._unique_str_item_944;
      case 945:
        return _struct._unique_str_item_945;
      case 946:
        return _struct._unique_str_item_946;
      case 947:
        return _struct._unique_str_item_947;
      case 948:
        return _struct._unique_str_item_948;
      case 949:
        return _struct._unique_str_item_949;
      case 950:
        return _struct._unique_str_item_950;
      case 951:
        return _struct._unique_str_item_951;
      case 952:
        return _struct._unique_str_item_952;
      case 953:
        return _struct._unique_str_item_953;
      case 954:
        return _struct._unique_str_item_954;
      case 955:
        return _struct._unique_str_item_955;
      case 956:
        return _struct._unique_str_item_956;
      case 957:
        return _struct._unique_str_item_957;
      case 958:
        return _struct._unique_str_item_958;
      case 959:
        return _struct._unique_str_item_959;
      case 960:
        return _struct._unique_str_item_960;
      case 961:
        return _struct._unique_str_item_961;
      case 962:
        return _struct._unique_str_item_962;
      case 963:
        return _struct._unique_str_item_963;
      case 964:
        return _struct._unique_str_item_964;
      case 965:
        return _struct._unique_str_item_965;
      case 966:
        return _struct._unique_str_item_966;
      case 967:
        return _struct._unique_str_item_967;
      case 968:
        return _struct._unique_str_item_968;
      case 969:
        return _struct._unique_str_item_969;
      case 970:
        return _struct._unique_str_item_970;
      case 971:
        return _struct._unique_str_item_971;
      case 972:
        return _struct._unique_str_item_972;
      case 973:
        return _struct._unique_str_item_973;
      case 974:
        return _struct._unique_str_item_974;
      case 975:
        return _struct._unique_str_item_975;
      case 976:
        return _struct._unique_str_item_976;
      case 977:
        return _struct._unique_str_item_977;
      case 978:
        return _struct._unique_str_item_978;
      case 979:
        return _struct._unique_str_item_979;
      case 980:
        return _struct._unique_str_item_980;
      case 981:
        return _struct._unique_str_item_981;
      case 982:
        return _struct._unique_str_item_982;
      case 983:
        return _struct._unique_str_item_983;
      case 984:
        return _struct._unique_str_item_984;
      case 985:
        return _struct._unique_str_item_985;
      case 986:
        return _struct._unique_str_item_986;
      case 987:
        return _struct._unique_str_item_987;
      case 988:
        return _struct._unique_str_item_988;
      case 989:
        return _struct._unique_str_item_989;
      case 990:
        return _struct._unique_str_item_990;
      case 991:
        return _struct._unique_str_item_991;
      case 992:
        return _struct._unique_str_item_992;
      case 993:
        return _struct._unique_str_item_993;
      case 994:
        return _struct._unique_str_item_994;
      case 995:
        return _struct._unique_str_item_995;
      case 996:
        return _struct._unique_str_item_996;
      case 997:
        return _struct._unique_str_item_997;
      case 998:
        return _struct._unique_str_item_998;
      case 999:
        return _struct._unique_str_item_999;
      case 1000:
        return _struct._unique_str_item_1000;
      case 1001:
        return _struct._unique_str_item_1001;
      case 1002:
        return _struct._unique_str_item_1002;
      case 1003:
        return _struct._unique_str_item_1003;
      case 1004:
        return _struct._unique_str_item_1004;
      case 1005:
        return _struct._unique_str_item_1005;
      case 1006:
        return _struct._unique_str_item_1006;
      case 1007:
        return _struct._unique_str_item_1007;
      case 1008:
        return _struct._unique_str_item_1008;
      case 1009:
        return _struct._unique_str_item_1009;
      case 1010:
        return _struct._unique_str_item_1010;
      case 1011:
        return _struct._unique_str_item_1011;
      case 1012:
        return _struct._unique_str_item_1012;
      case 1013:
        return _struct._unique_str_item_1013;
      case 1014:
        return _struct._unique_str_item_1014;
      case 1015:
        return _struct._unique_str_item_1015;
      case 1016:
        return _struct._unique_str_item_1016;
      case 1017:
        return _struct._unique_str_item_1017;
      case 1018:
        return _struct._unique_str_item_1018;
      case 1019:
        return _struct._unique_str_item_1019;
      case 1020:
        return _struct._unique_str_item_1020;
      case 1021:
        return _struct._unique_str_item_1021;
      case 1022:
        return _struct._unique_str_item_1022;
      case 1023:
        return _struct._unique_str_item_1023;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_str_item_0 = value;
        break;
      case 1:
        _struct._unique_str_item_1 = value;
        break;
      case 2:
        _struct._unique_str_item_2 = value;
        break;
      case 3:
        _struct._unique_str_item_3 = value;
        break;
      case 4:
        _struct._unique_str_item_4 = value;
        break;
      case 5:
        _struct._unique_str_item_5 = value;
        break;
      case 6:
        _struct._unique_str_item_6 = value;
        break;
      case 7:
        _struct._unique_str_item_7 = value;
        break;
      case 8:
        _struct._unique_str_item_8 = value;
        break;
      case 9:
        _struct._unique_str_item_9 = value;
        break;
      case 10:
        _struct._unique_str_item_10 = value;
        break;
      case 11:
        _struct._unique_str_item_11 = value;
        break;
      case 12:
        _struct._unique_str_item_12 = value;
        break;
      case 13:
        _struct._unique_str_item_13 = value;
        break;
      case 14:
        _struct._unique_str_item_14 = value;
        break;
      case 15:
        _struct._unique_str_item_15 = value;
        break;
      case 16:
        _struct._unique_str_item_16 = value;
        break;
      case 17:
        _struct._unique_str_item_17 = value;
        break;
      case 18:
        _struct._unique_str_item_18 = value;
        break;
      case 19:
        _struct._unique_str_item_19 = value;
        break;
      case 20:
        _struct._unique_str_item_20 = value;
        break;
      case 21:
        _struct._unique_str_item_21 = value;
        break;
      case 22:
        _struct._unique_str_item_22 = value;
        break;
      case 23:
        _struct._unique_str_item_23 = value;
        break;
      case 24:
        _struct._unique_str_item_24 = value;
        break;
      case 25:
        _struct._unique_str_item_25 = value;
        break;
      case 26:
        _struct._unique_str_item_26 = value;
        break;
      case 27:
        _struct._unique_str_item_27 = value;
        break;
      case 28:
        _struct._unique_str_item_28 = value;
        break;
      case 29:
        _struct._unique_str_item_29 = value;
        break;
      case 30:
        _struct._unique_str_item_30 = value;
        break;
      case 31:
        _struct._unique_str_item_31 = value;
        break;
      case 32:
        _struct._unique_str_item_32 = value;
        break;
      case 33:
        _struct._unique_str_item_33 = value;
        break;
      case 34:
        _struct._unique_str_item_34 = value;
        break;
      case 35:
        _struct._unique_str_item_35 = value;
        break;
      case 36:
        _struct._unique_str_item_36 = value;
        break;
      case 37:
        _struct._unique_str_item_37 = value;
        break;
      case 38:
        _struct._unique_str_item_38 = value;
        break;
      case 39:
        _struct._unique_str_item_39 = value;
        break;
      case 40:
        _struct._unique_str_item_40 = value;
        break;
      case 41:
        _struct._unique_str_item_41 = value;
        break;
      case 42:
        _struct._unique_str_item_42 = value;
        break;
      case 43:
        _struct._unique_str_item_43 = value;
        break;
      case 44:
        _struct._unique_str_item_44 = value;
        break;
      case 45:
        _struct._unique_str_item_45 = value;
        break;
      case 46:
        _struct._unique_str_item_46 = value;
        break;
      case 47:
        _struct._unique_str_item_47 = value;
        break;
      case 48:
        _struct._unique_str_item_48 = value;
        break;
      case 49:
        _struct._unique_str_item_49 = value;
        break;
      case 50:
        _struct._unique_str_item_50 = value;
        break;
      case 51:
        _struct._unique_str_item_51 = value;
        break;
      case 52:
        _struct._unique_str_item_52 = value;
        break;
      case 53:
        _struct._unique_str_item_53 = value;
        break;
      case 54:
        _struct._unique_str_item_54 = value;
        break;
      case 55:
        _struct._unique_str_item_55 = value;
        break;
      case 56:
        _struct._unique_str_item_56 = value;
        break;
      case 57:
        _struct._unique_str_item_57 = value;
        break;
      case 58:
        _struct._unique_str_item_58 = value;
        break;
      case 59:
        _struct._unique_str_item_59 = value;
        break;
      case 60:
        _struct._unique_str_item_60 = value;
        break;
      case 61:
        _struct._unique_str_item_61 = value;
        break;
      case 62:
        _struct._unique_str_item_62 = value;
        break;
      case 63:
        _struct._unique_str_item_63 = value;
        break;
      case 64:
        _struct._unique_str_item_64 = value;
        break;
      case 65:
        _struct._unique_str_item_65 = value;
        break;
      case 66:
        _struct._unique_str_item_66 = value;
        break;
      case 67:
        _struct._unique_str_item_67 = value;
        break;
      case 68:
        _struct._unique_str_item_68 = value;
        break;
      case 69:
        _struct._unique_str_item_69 = value;
        break;
      case 70:
        _struct._unique_str_item_70 = value;
        break;
      case 71:
        _struct._unique_str_item_71 = value;
        break;
      case 72:
        _struct._unique_str_item_72 = value;
        break;
      case 73:
        _struct._unique_str_item_73 = value;
        break;
      case 74:
        _struct._unique_str_item_74 = value;
        break;
      case 75:
        _struct._unique_str_item_75 = value;
        break;
      case 76:
        _struct._unique_str_item_76 = value;
        break;
      case 77:
        _struct._unique_str_item_77 = value;
        break;
      case 78:
        _struct._unique_str_item_78 = value;
        break;
      case 79:
        _struct._unique_str_item_79 = value;
        break;
      case 80:
        _struct._unique_str_item_80 = value;
        break;
      case 81:
        _struct._unique_str_item_81 = value;
        break;
      case 82:
        _struct._unique_str_item_82 = value;
        break;
      case 83:
        _struct._unique_str_item_83 = value;
        break;
      case 84:
        _struct._unique_str_item_84 = value;
        break;
      case 85:
        _struct._unique_str_item_85 = value;
        break;
      case 86:
        _struct._unique_str_item_86 = value;
        break;
      case 87:
        _struct._unique_str_item_87 = value;
        break;
      case 88:
        _struct._unique_str_item_88 = value;
        break;
      case 89:
        _struct._unique_str_item_89 = value;
        break;
      case 90:
        _struct._unique_str_item_90 = value;
        break;
      case 91:
        _struct._unique_str_item_91 = value;
        break;
      case 92:
        _struct._unique_str_item_92 = value;
        break;
      case 93:
        _struct._unique_str_item_93 = value;
        break;
      case 94:
        _struct._unique_str_item_94 = value;
        break;
      case 95:
        _struct._unique_str_item_95 = value;
        break;
      case 96:
        _struct._unique_str_item_96 = value;
        break;
      case 97:
        _struct._unique_str_item_97 = value;
        break;
      case 98:
        _struct._unique_str_item_98 = value;
        break;
      case 99:
        _struct._unique_str_item_99 = value;
        break;
      case 100:
        _struct._unique_str_item_100 = value;
        break;
      case 101:
        _struct._unique_str_item_101 = value;
        break;
      case 102:
        _struct._unique_str_item_102 = value;
        break;
      case 103:
        _struct._unique_str_item_103 = value;
        break;
      case 104:
        _struct._unique_str_item_104 = value;
        break;
      case 105:
        _struct._unique_str_item_105 = value;
        break;
      case 106:
        _struct._unique_str_item_106 = value;
        break;
      case 107:
        _struct._unique_str_item_107 = value;
        break;
      case 108:
        _struct._unique_str_item_108 = value;
        break;
      case 109:
        _struct._unique_str_item_109 = value;
        break;
      case 110:
        _struct._unique_str_item_110 = value;
        break;
      case 111:
        _struct._unique_str_item_111 = value;
        break;
      case 112:
        _struct._unique_str_item_112 = value;
        break;
      case 113:
        _struct._unique_str_item_113 = value;
        break;
      case 114:
        _struct._unique_str_item_114 = value;
        break;
      case 115:
        _struct._unique_str_item_115 = value;
        break;
      case 116:
        _struct._unique_str_item_116 = value;
        break;
      case 117:
        _struct._unique_str_item_117 = value;
        break;
      case 118:
        _struct._unique_str_item_118 = value;
        break;
      case 119:
        _struct._unique_str_item_119 = value;
        break;
      case 120:
        _struct._unique_str_item_120 = value;
        break;
      case 121:
        _struct._unique_str_item_121 = value;
        break;
      case 122:
        _struct._unique_str_item_122 = value;
        break;
      case 123:
        _struct._unique_str_item_123 = value;
        break;
      case 124:
        _struct._unique_str_item_124 = value;
        break;
      case 125:
        _struct._unique_str_item_125 = value;
        break;
      case 126:
        _struct._unique_str_item_126 = value;
        break;
      case 127:
        _struct._unique_str_item_127 = value;
        break;
      case 128:
        _struct._unique_str_item_128 = value;
        break;
      case 129:
        _struct._unique_str_item_129 = value;
        break;
      case 130:
        _struct._unique_str_item_130 = value;
        break;
      case 131:
        _struct._unique_str_item_131 = value;
        break;
      case 132:
        _struct._unique_str_item_132 = value;
        break;
      case 133:
        _struct._unique_str_item_133 = value;
        break;
      case 134:
        _struct._unique_str_item_134 = value;
        break;
      case 135:
        _struct._unique_str_item_135 = value;
        break;
      case 136:
        _struct._unique_str_item_136 = value;
        break;
      case 137:
        _struct._unique_str_item_137 = value;
        break;
      case 138:
        _struct._unique_str_item_138 = value;
        break;
      case 139:
        _struct._unique_str_item_139 = value;
        break;
      case 140:
        _struct._unique_str_item_140 = value;
        break;
      case 141:
        _struct._unique_str_item_141 = value;
        break;
      case 142:
        _struct._unique_str_item_142 = value;
        break;
      case 143:
        _struct._unique_str_item_143 = value;
        break;
      case 144:
        _struct._unique_str_item_144 = value;
        break;
      case 145:
        _struct._unique_str_item_145 = value;
        break;
      case 146:
        _struct._unique_str_item_146 = value;
        break;
      case 147:
        _struct._unique_str_item_147 = value;
        break;
      case 148:
        _struct._unique_str_item_148 = value;
        break;
      case 149:
        _struct._unique_str_item_149 = value;
        break;
      case 150:
        _struct._unique_str_item_150 = value;
        break;
      case 151:
        _struct._unique_str_item_151 = value;
        break;
      case 152:
        _struct._unique_str_item_152 = value;
        break;
      case 153:
        _struct._unique_str_item_153 = value;
        break;
      case 154:
        _struct._unique_str_item_154 = value;
        break;
      case 155:
        _struct._unique_str_item_155 = value;
        break;
      case 156:
        _struct._unique_str_item_156 = value;
        break;
      case 157:
        _struct._unique_str_item_157 = value;
        break;
      case 158:
        _struct._unique_str_item_158 = value;
        break;
      case 159:
        _struct._unique_str_item_159 = value;
        break;
      case 160:
        _struct._unique_str_item_160 = value;
        break;
      case 161:
        _struct._unique_str_item_161 = value;
        break;
      case 162:
        _struct._unique_str_item_162 = value;
        break;
      case 163:
        _struct._unique_str_item_163 = value;
        break;
      case 164:
        _struct._unique_str_item_164 = value;
        break;
      case 165:
        _struct._unique_str_item_165 = value;
        break;
      case 166:
        _struct._unique_str_item_166 = value;
        break;
      case 167:
        _struct._unique_str_item_167 = value;
        break;
      case 168:
        _struct._unique_str_item_168 = value;
        break;
      case 169:
        _struct._unique_str_item_169 = value;
        break;
      case 170:
        _struct._unique_str_item_170 = value;
        break;
      case 171:
        _struct._unique_str_item_171 = value;
        break;
      case 172:
        _struct._unique_str_item_172 = value;
        break;
      case 173:
        _struct._unique_str_item_173 = value;
        break;
      case 174:
        _struct._unique_str_item_174 = value;
        break;
      case 175:
        _struct._unique_str_item_175 = value;
        break;
      case 176:
        _struct._unique_str_item_176 = value;
        break;
      case 177:
        _struct._unique_str_item_177 = value;
        break;
      case 178:
        _struct._unique_str_item_178 = value;
        break;
      case 179:
        _struct._unique_str_item_179 = value;
        break;
      case 180:
        _struct._unique_str_item_180 = value;
        break;
      case 181:
        _struct._unique_str_item_181 = value;
        break;
      case 182:
        _struct._unique_str_item_182 = value;
        break;
      case 183:
        _struct._unique_str_item_183 = value;
        break;
      case 184:
        _struct._unique_str_item_184 = value;
        break;
      case 185:
        _struct._unique_str_item_185 = value;
        break;
      case 186:
        _struct._unique_str_item_186 = value;
        break;
      case 187:
        _struct._unique_str_item_187 = value;
        break;
      case 188:
        _struct._unique_str_item_188 = value;
        break;
      case 189:
        _struct._unique_str_item_189 = value;
        break;
      case 190:
        _struct._unique_str_item_190 = value;
        break;
      case 191:
        _struct._unique_str_item_191 = value;
        break;
      case 192:
        _struct._unique_str_item_192 = value;
        break;
      case 193:
        _struct._unique_str_item_193 = value;
        break;
      case 194:
        _struct._unique_str_item_194 = value;
        break;
      case 195:
        _struct._unique_str_item_195 = value;
        break;
      case 196:
        _struct._unique_str_item_196 = value;
        break;
      case 197:
        _struct._unique_str_item_197 = value;
        break;
      case 198:
        _struct._unique_str_item_198 = value;
        break;
      case 199:
        _struct._unique_str_item_199 = value;
        break;
      case 200:
        _struct._unique_str_item_200 = value;
        break;
      case 201:
        _struct._unique_str_item_201 = value;
        break;
      case 202:
        _struct._unique_str_item_202 = value;
        break;
      case 203:
        _struct._unique_str_item_203 = value;
        break;
      case 204:
        _struct._unique_str_item_204 = value;
        break;
      case 205:
        _struct._unique_str_item_205 = value;
        break;
      case 206:
        _struct._unique_str_item_206 = value;
        break;
      case 207:
        _struct._unique_str_item_207 = value;
        break;
      case 208:
        _struct._unique_str_item_208 = value;
        break;
      case 209:
        _struct._unique_str_item_209 = value;
        break;
      case 210:
        _struct._unique_str_item_210 = value;
        break;
      case 211:
        _struct._unique_str_item_211 = value;
        break;
      case 212:
        _struct._unique_str_item_212 = value;
        break;
      case 213:
        _struct._unique_str_item_213 = value;
        break;
      case 214:
        _struct._unique_str_item_214 = value;
        break;
      case 215:
        _struct._unique_str_item_215 = value;
        break;
      case 216:
        _struct._unique_str_item_216 = value;
        break;
      case 217:
        _struct._unique_str_item_217 = value;
        break;
      case 218:
        _struct._unique_str_item_218 = value;
        break;
      case 219:
        _struct._unique_str_item_219 = value;
        break;
      case 220:
        _struct._unique_str_item_220 = value;
        break;
      case 221:
        _struct._unique_str_item_221 = value;
        break;
      case 222:
        _struct._unique_str_item_222 = value;
        break;
      case 223:
        _struct._unique_str_item_223 = value;
        break;
      case 224:
        _struct._unique_str_item_224 = value;
        break;
      case 225:
        _struct._unique_str_item_225 = value;
        break;
      case 226:
        _struct._unique_str_item_226 = value;
        break;
      case 227:
        _struct._unique_str_item_227 = value;
        break;
      case 228:
        _struct._unique_str_item_228 = value;
        break;
      case 229:
        _struct._unique_str_item_229 = value;
        break;
      case 230:
        _struct._unique_str_item_230 = value;
        break;
      case 231:
        _struct._unique_str_item_231 = value;
        break;
      case 232:
        _struct._unique_str_item_232 = value;
        break;
      case 233:
        _struct._unique_str_item_233 = value;
        break;
      case 234:
        _struct._unique_str_item_234 = value;
        break;
      case 235:
        _struct._unique_str_item_235 = value;
        break;
      case 236:
        _struct._unique_str_item_236 = value;
        break;
      case 237:
        _struct._unique_str_item_237 = value;
        break;
      case 238:
        _struct._unique_str_item_238 = value;
        break;
      case 239:
        _struct._unique_str_item_239 = value;
        break;
      case 240:
        _struct._unique_str_item_240 = value;
        break;
      case 241:
        _struct._unique_str_item_241 = value;
        break;
      case 242:
        _struct._unique_str_item_242 = value;
        break;
      case 243:
        _struct._unique_str_item_243 = value;
        break;
      case 244:
        _struct._unique_str_item_244 = value;
        break;
      case 245:
        _struct._unique_str_item_245 = value;
        break;
      case 246:
        _struct._unique_str_item_246 = value;
        break;
      case 247:
        _struct._unique_str_item_247 = value;
        break;
      case 248:
        _struct._unique_str_item_248 = value;
        break;
      case 249:
        _struct._unique_str_item_249 = value;
        break;
      case 250:
        _struct._unique_str_item_250 = value;
        break;
      case 251:
        _struct._unique_str_item_251 = value;
        break;
      case 252:
        _struct._unique_str_item_252 = value;
        break;
      case 253:
        _struct._unique_str_item_253 = value;
        break;
      case 254:
        _struct._unique_str_item_254 = value;
        break;
      case 255:
        _struct._unique_str_item_255 = value;
        break;
      case 256:
        _struct._unique_str_item_256 = value;
        break;
      case 257:
        _struct._unique_str_item_257 = value;
        break;
      case 258:
        _struct._unique_str_item_258 = value;
        break;
      case 259:
        _struct._unique_str_item_259 = value;
        break;
      case 260:
        _struct._unique_str_item_260 = value;
        break;
      case 261:
        _struct._unique_str_item_261 = value;
        break;
      case 262:
        _struct._unique_str_item_262 = value;
        break;
      case 263:
        _struct._unique_str_item_263 = value;
        break;
      case 264:
        _struct._unique_str_item_264 = value;
        break;
      case 265:
        _struct._unique_str_item_265 = value;
        break;
      case 266:
        _struct._unique_str_item_266 = value;
        break;
      case 267:
        _struct._unique_str_item_267 = value;
        break;
      case 268:
        _struct._unique_str_item_268 = value;
        break;
      case 269:
        _struct._unique_str_item_269 = value;
        break;
      case 270:
        _struct._unique_str_item_270 = value;
        break;
      case 271:
        _struct._unique_str_item_271 = value;
        break;
      case 272:
        _struct._unique_str_item_272 = value;
        break;
      case 273:
        _struct._unique_str_item_273 = value;
        break;
      case 274:
        _struct._unique_str_item_274 = value;
        break;
      case 275:
        _struct._unique_str_item_275 = value;
        break;
      case 276:
        _struct._unique_str_item_276 = value;
        break;
      case 277:
        _struct._unique_str_item_277 = value;
        break;
      case 278:
        _struct._unique_str_item_278 = value;
        break;
      case 279:
        _struct._unique_str_item_279 = value;
        break;
      case 280:
        _struct._unique_str_item_280 = value;
        break;
      case 281:
        _struct._unique_str_item_281 = value;
        break;
      case 282:
        _struct._unique_str_item_282 = value;
        break;
      case 283:
        _struct._unique_str_item_283 = value;
        break;
      case 284:
        _struct._unique_str_item_284 = value;
        break;
      case 285:
        _struct._unique_str_item_285 = value;
        break;
      case 286:
        _struct._unique_str_item_286 = value;
        break;
      case 287:
        _struct._unique_str_item_287 = value;
        break;
      case 288:
        _struct._unique_str_item_288 = value;
        break;
      case 289:
        _struct._unique_str_item_289 = value;
        break;
      case 290:
        _struct._unique_str_item_290 = value;
        break;
      case 291:
        _struct._unique_str_item_291 = value;
        break;
      case 292:
        _struct._unique_str_item_292 = value;
        break;
      case 293:
        _struct._unique_str_item_293 = value;
        break;
      case 294:
        _struct._unique_str_item_294 = value;
        break;
      case 295:
        _struct._unique_str_item_295 = value;
        break;
      case 296:
        _struct._unique_str_item_296 = value;
        break;
      case 297:
        _struct._unique_str_item_297 = value;
        break;
      case 298:
        _struct._unique_str_item_298 = value;
        break;
      case 299:
        _struct._unique_str_item_299 = value;
        break;
      case 300:
        _struct._unique_str_item_300 = value;
        break;
      case 301:
        _struct._unique_str_item_301 = value;
        break;
      case 302:
        _struct._unique_str_item_302 = value;
        break;
      case 303:
        _struct._unique_str_item_303 = value;
        break;
      case 304:
        _struct._unique_str_item_304 = value;
        break;
      case 305:
        _struct._unique_str_item_305 = value;
        break;
      case 306:
        _struct._unique_str_item_306 = value;
        break;
      case 307:
        _struct._unique_str_item_307 = value;
        break;
      case 308:
        _struct._unique_str_item_308 = value;
        break;
      case 309:
        _struct._unique_str_item_309 = value;
        break;
      case 310:
        _struct._unique_str_item_310 = value;
        break;
      case 311:
        _struct._unique_str_item_311 = value;
        break;
      case 312:
        _struct._unique_str_item_312 = value;
        break;
      case 313:
        _struct._unique_str_item_313 = value;
        break;
      case 314:
        _struct._unique_str_item_314 = value;
        break;
      case 315:
        _struct._unique_str_item_315 = value;
        break;
      case 316:
        _struct._unique_str_item_316 = value;
        break;
      case 317:
        _struct._unique_str_item_317 = value;
        break;
      case 318:
        _struct._unique_str_item_318 = value;
        break;
      case 319:
        _struct._unique_str_item_319 = value;
        break;
      case 320:
        _struct._unique_str_item_320 = value;
        break;
      case 321:
        _struct._unique_str_item_321 = value;
        break;
      case 322:
        _struct._unique_str_item_322 = value;
        break;
      case 323:
        _struct._unique_str_item_323 = value;
        break;
      case 324:
        _struct._unique_str_item_324 = value;
        break;
      case 325:
        _struct._unique_str_item_325 = value;
        break;
      case 326:
        _struct._unique_str_item_326 = value;
        break;
      case 327:
        _struct._unique_str_item_327 = value;
        break;
      case 328:
        _struct._unique_str_item_328 = value;
        break;
      case 329:
        _struct._unique_str_item_329 = value;
        break;
      case 330:
        _struct._unique_str_item_330 = value;
        break;
      case 331:
        _struct._unique_str_item_331 = value;
        break;
      case 332:
        _struct._unique_str_item_332 = value;
        break;
      case 333:
        _struct._unique_str_item_333 = value;
        break;
      case 334:
        _struct._unique_str_item_334 = value;
        break;
      case 335:
        _struct._unique_str_item_335 = value;
        break;
      case 336:
        _struct._unique_str_item_336 = value;
        break;
      case 337:
        _struct._unique_str_item_337 = value;
        break;
      case 338:
        _struct._unique_str_item_338 = value;
        break;
      case 339:
        _struct._unique_str_item_339 = value;
        break;
      case 340:
        _struct._unique_str_item_340 = value;
        break;
      case 341:
        _struct._unique_str_item_341 = value;
        break;
      case 342:
        _struct._unique_str_item_342 = value;
        break;
      case 343:
        _struct._unique_str_item_343 = value;
        break;
      case 344:
        _struct._unique_str_item_344 = value;
        break;
      case 345:
        _struct._unique_str_item_345 = value;
        break;
      case 346:
        _struct._unique_str_item_346 = value;
        break;
      case 347:
        _struct._unique_str_item_347 = value;
        break;
      case 348:
        _struct._unique_str_item_348 = value;
        break;
      case 349:
        _struct._unique_str_item_349 = value;
        break;
      case 350:
        _struct._unique_str_item_350 = value;
        break;
      case 351:
        _struct._unique_str_item_351 = value;
        break;
      case 352:
        _struct._unique_str_item_352 = value;
        break;
      case 353:
        _struct._unique_str_item_353 = value;
        break;
      case 354:
        _struct._unique_str_item_354 = value;
        break;
      case 355:
        _struct._unique_str_item_355 = value;
        break;
      case 356:
        _struct._unique_str_item_356 = value;
        break;
      case 357:
        _struct._unique_str_item_357 = value;
        break;
      case 358:
        _struct._unique_str_item_358 = value;
        break;
      case 359:
        _struct._unique_str_item_359 = value;
        break;
      case 360:
        _struct._unique_str_item_360 = value;
        break;
      case 361:
        _struct._unique_str_item_361 = value;
        break;
      case 362:
        _struct._unique_str_item_362 = value;
        break;
      case 363:
        _struct._unique_str_item_363 = value;
        break;
      case 364:
        _struct._unique_str_item_364 = value;
        break;
      case 365:
        _struct._unique_str_item_365 = value;
        break;
      case 366:
        _struct._unique_str_item_366 = value;
        break;
      case 367:
        _struct._unique_str_item_367 = value;
        break;
      case 368:
        _struct._unique_str_item_368 = value;
        break;
      case 369:
        _struct._unique_str_item_369 = value;
        break;
      case 370:
        _struct._unique_str_item_370 = value;
        break;
      case 371:
        _struct._unique_str_item_371 = value;
        break;
      case 372:
        _struct._unique_str_item_372 = value;
        break;
      case 373:
        _struct._unique_str_item_373 = value;
        break;
      case 374:
        _struct._unique_str_item_374 = value;
        break;
      case 375:
        _struct._unique_str_item_375 = value;
        break;
      case 376:
        _struct._unique_str_item_376 = value;
        break;
      case 377:
        _struct._unique_str_item_377 = value;
        break;
      case 378:
        _struct._unique_str_item_378 = value;
        break;
      case 379:
        _struct._unique_str_item_379 = value;
        break;
      case 380:
        _struct._unique_str_item_380 = value;
        break;
      case 381:
        _struct._unique_str_item_381 = value;
        break;
      case 382:
        _struct._unique_str_item_382 = value;
        break;
      case 383:
        _struct._unique_str_item_383 = value;
        break;
      case 384:
        _struct._unique_str_item_384 = value;
        break;
      case 385:
        _struct._unique_str_item_385 = value;
        break;
      case 386:
        _struct._unique_str_item_386 = value;
        break;
      case 387:
        _struct._unique_str_item_387 = value;
        break;
      case 388:
        _struct._unique_str_item_388 = value;
        break;
      case 389:
        _struct._unique_str_item_389 = value;
        break;
      case 390:
        _struct._unique_str_item_390 = value;
        break;
      case 391:
        _struct._unique_str_item_391 = value;
        break;
      case 392:
        _struct._unique_str_item_392 = value;
        break;
      case 393:
        _struct._unique_str_item_393 = value;
        break;
      case 394:
        _struct._unique_str_item_394 = value;
        break;
      case 395:
        _struct._unique_str_item_395 = value;
        break;
      case 396:
        _struct._unique_str_item_396 = value;
        break;
      case 397:
        _struct._unique_str_item_397 = value;
        break;
      case 398:
        _struct._unique_str_item_398 = value;
        break;
      case 399:
        _struct._unique_str_item_399 = value;
        break;
      case 400:
        _struct._unique_str_item_400 = value;
        break;
      case 401:
        _struct._unique_str_item_401 = value;
        break;
      case 402:
        _struct._unique_str_item_402 = value;
        break;
      case 403:
        _struct._unique_str_item_403 = value;
        break;
      case 404:
        _struct._unique_str_item_404 = value;
        break;
      case 405:
        _struct._unique_str_item_405 = value;
        break;
      case 406:
        _struct._unique_str_item_406 = value;
        break;
      case 407:
        _struct._unique_str_item_407 = value;
        break;
      case 408:
        _struct._unique_str_item_408 = value;
        break;
      case 409:
        _struct._unique_str_item_409 = value;
        break;
      case 410:
        _struct._unique_str_item_410 = value;
        break;
      case 411:
        _struct._unique_str_item_411 = value;
        break;
      case 412:
        _struct._unique_str_item_412 = value;
        break;
      case 413:
        _struct._unique_str_item_413 = value;
        break;
      case 414:
        _struct._unique_str_item_414 = value;
        break;
      case 415:
        _struct._unique_str_item_415 = value;
        break;
      case 416:
        _struct._unique_str_item_416 = value;
        break;
      case 417:
        _struct._unique_str_item_417 = value;
        break;
      case 418:
        _struct._unique_str_item_418 = value;
        break;
      case 419:
        _struct._unique_str_item_419 = value;
        break;
      case 420:
        _struct._unique_str_item_420 = value;
        break;
      case 421:
        _struct._unique_str_item_421 = value;
        break;
      case 422:
        _struct._unique_str_item_422 = value;
        break;
      case 423:
        _struct._unique_str_item_423 = value;
        break;
      case 424:
        _struct._unique_str_item_424 = value;
        break;
      case 425:
        _struct._unique_str_item_425 = value;
        break;
      case 426:
        _struct._unique_str_item_426 = value;
        break;
      case 427:
        _struct._unique_str_item_427 = value;
        break;
      case 428:
        _struct._unique_str_item_428 = value;
        break;
      case 429:
        _struct._unique_str_item_429 = value;
        break;
      case 430:
        _struct._unique_str_item_430 = value;
        break;
      case 431:
        _struct._unique_str_item_431 = value;
        break;
      case 432:
        _struct._unique_str_item_432 = value;
        break;
      case 433:
        _struct._unique_str_item_433 = value;
        break;
      case 434:
        _struct._unique_str_item_434 = value;
        break;
      case 435:
        _struct._unique_str_item_435 = value;
        break;
      case 436:
        _struct._unique_str_item_436 = value;
        break;
      case 437:
        _struct._unique_str_item_437 = value;
        break;
      case 438:
        _struct._unique_str_item_438 = value;
        break;
      case 439:
        _struct._unique_str_item_439 = value;
        break;
      case 440:
        _struct._unique_str_item_440 = value;
        break;
      case 441:
        _struct._unique_str_item_441 = value;
        break;
      case 442:
        _struct._unique_str_item_442 = value;
        break;
      case 443:
        _struct._unique_str_item_443 = value;
        break;
      case 444:
        _struct._unique_str_item_444 = value;
        break;
      case 445:
        _struct._unique_str_item_445 = value;
        break;
      case 446:
        _struct._unique_str_item_446 = value;
        break;
      case 447:
        _struct._unique_str_item_447 = value;
        break;
      case 448:
        _struct._unique_str_item_448 = value;
        break;
      case 449:
        _struct._unique_str_item_449 = value;
        break;
      case 450:
        _struct._unique_str_item_450 = value;
        break;
      case 451:
        _struct._unique_str_item_451 = value;
        break;
      case 452:
        _struct._unique_str_item_452 = value;
        break;
      case 453:
        _struct._unique_str_item_453 = value;
        break;
      case 454:
        _struct._unique_str_item_454 = value;
        break;
      case 455:
        _struct._unique_str_item_455 = value;
        break;
      case 456:
        _struct._unique_str_item_456 = value;
        break;
      case 457:
        _struct._unique_str_item_457 = value;
        break;
      case 458:
        _struct._unique_str_item_458 = value;
        break;
      case 459:
        _struct._unique_str_item_459 = value;
        break;
      case 460:
        _struct._unique_str_item_460 = value;
        break;
      case 461:
        _struct._unique_str_item_461 = value;
        break;
      case 462:
        _struct._unique_str_item_462 = value;
        break;
      case 463:
        _struct._unique_str_item_463 = value;
        break;
      case 464:
        _struct._unique_str_item_464 = value;
        break;
      case 465:
        _struct._unique_str_item_465 = value;
        break;
      case 466:
        _struct._unique_str_item_466 = value;
        break;
      case 467:
        _struct._unique_str_item_467 = value;
        break;
      case 468:
        _struct._unique_str_item_468 = value;
        break;
      case 469:
        _struct._unique_str_item_469 = value;
        break;
      case 470:
        _struct._unique_str_item_470 = value;
        break;
      case 471:
        _struct._unique_str_item_471 = value;
        break;
      case 472:
        _struct._unique_str_item_472 = value;
        break;
      case 473:
        _struct._unique_str_item_473 = value;
        break;
      case 474:
        _struct._unique_str_item_474 = value;
        break;
      case 475:
        _struct._unique_str_item_475 = value;
        break;
      case 476:
        _struct._unique_str_item_476 = value;
        break;
      case 477:
        _struct._unique_str_item_477 = value;
        break;
      case 478:
        _struct._unique_str_item_478 = value;
        break;
      case 479:
        _struct._unique_str_item_479 = value;
        break;
      case 480:
        _struct._unique_str_item_480 = value;
        break;
      case 481:
        _struct._unique_str_item_481 = value;
        break;
      case 482:
        _struct._unique_str_item_482 = value;
        break;
      case 483:
        _struct._unique_str_item_483 = value;
        break;
      case 484:
        _struct._unique_str_item_484 = value;
        break;
      case 485:
        _struct._unique_str_item_485 = value;
        break;
      case 486:
        _struct._unique_str_item_486 = value;
        break;
      case 487:
        _struct._unique_str_item_487 = value;
        break;
      case 488:
        _struct._unique_str_item_488 = value;
        break;
      case 489:
        _struct._unique_str_item_489 = value;
        break;
      case 490:
        _struct._unique_str_item_490 = value;
        break;
      case 491:
        _struct._unique_str_item_491 = value;
        break;
      case 492:
        _struct._unique_str_item_492 = value;
        break;
      case 493:
        _struct._unique_str_item_493 = value;
        break;
      case 494:
        _struct._unique_str_item_494 = value;
        break;
      case 495:
        _struct._unique_str_item_495 = value;
        break;
      case 496:
        _struct._unique_str_item_496 = value;
        break;
      case 497:
        _struct._unique_str_item_497 = value;
        break;
      case 498:
        _struct._unique_str_item_498 = value;
        break;
      case 499:
        _struct._unique_str_item_499 = value;
        break;
      case 500:
        _struct._unique_str_item_500 = value;
        break;
      case 501:
        _struct._unique_str_item_501 = value;
        break;
      case 502:
        _struct._unique_str_item_502 = value;
        break;
      case 503:
        _struct._unique_str_item_503 = value;
        break;
      case 504:
        _struct._unique_str_item_504 = value;
        break;
      case 505:
        _struct._unique_str_item_505 = value;
        break;
      case 506:
        _struct._unique_str_item_506 = value;
        break;
      case 507:
        _struct._unique_str_item_507 = value;
        break;
      case 508:
        _struct._unique_str_item_508 = value;
        break;
      case 509:
        _struct._unique_str_item_509 = value;
        break;
      case 510:
        _struct._unique_str_item_510 = value;
        break;
      case 511:
        _struct._unique_str_item_511 = value;
        break;
      case 512:
        _struct._unique_str_item_512 = value;
        break;
      case 513:
        _struct._unique_str_item_513 = value;
        break;
      case 514:
        _struct._unique_str_item_514 = value;
        break;
      case 515:
        _struct._unique_str_item_515 = value;
        break;
      case 516:
        _struct._unique_str_item_516 = value;
        break;
      case 517:
        _struct._unique_str_item_517 = value;
        break;
      case 518:
        _struct._unique_str_item_518 = value;
        break;
      case 519:
        _struct._unique_str_item_519 = value;
        break;
      case 520:
        _struct._unique_str_item_520 = value;
        break;
      case 521:
        _struct._unique_str_item_521 = value;
        break;
      case 522:
        _struct._unique_str_item_522 = value;
        break;
      case 523:
        _struct._unique_str_item_523 = value;
        break;
      case 524:
        _struct._unique_str_item_524 = value;
        break;
      case 525:
        _struct._unique_str_item_525 = value;
        break;
      case 526:
        _struct._unique_str_item_526 = value;
        break;
      case 527:
        _struct._unique_str_item_527 = value;
        break;
      case 528:
        _struct._unique_str_item_528 = value;
        break;
      case 529:
        _struct._unique_str_item_529 = value;
        break;
      case 530:
        _struct._unique_str_item_530 = value;
        break;
      case 531:
        _struct._unique_str_item_531 = value;
        break;
      case 532:
        _struct._unique_str_item_532 = value;
        break;
      case 533:
        _struct._unique_str_item_533 = value;
        break;
      case 534:
        _struct._unique_str_item_534 = value;
        break;
      case 535:
        _struct._unique_str_item_535 = value;
        break;
      case 536:
        _struct._unique_str_item_536 = value;
        break;
      case 537:
        _struct._unique_str_item_537 = value;
        break;
      case 538:
        _struct._unique_str_item_538 = value;
        break;
      case 539:
        _struct._unique_str_item_539 = value;
        break;
      case 540:
        _struct._unique_str_item_540 = value;
        break;
      case 541:
        _struct._unique_str_item_541 = value;
        break;
      case 542:
        _struct._unique_str_item_542 = value;
        break;
      case 543:
        _struct._unique_str_item_543 = value;
        break;
      case 544:
        _struct._unique_str_item_544 = value;
        break;
      case 545:
        _struct._unique_str_item_545 = value;
        break;
      case 546:
        _struct._unique_str_item_546 = value;
        break;
      case 547:
        _struct._unique_str_item_547 = value;
        break;
      case 548:
        _struct._unique_str_item_548 = value;
        break;
      case 549:
        _struct._unique_str_item_549 = value;
        break;
      case 550:
        _struct._unique_str_item_550 = value;
        break;
      case 551:
        _struct._unique_str_item_551 = value;
        break;
      case 552:
        _struct._unique_str_item_552 = value;
        break;
      case 553:
        _struct._unique_str_item_553 = value;
        break;
      case 554:
        _struct._unique_str_item_554 = value;
        break;
      case 555:
        _struct._unique_str_item_555 = value;
        break;
      case 556:
        _struct._unique_str_item_556 = value;
        break;
      case 557:
        _struct._unique_str_item_557 = value;
        break;
      case 558:
        _struct._unique_str_item_558 = value;
        break;
      case 559:
        _struct._unique_str_item_559 = value;
        break;
      case 560:
        _struct._unique_str_item_560 = value;
        break;
      case 561:
        _struct._unique_str_item_561 = value;
        break;
      case 562:
        _struct._unique_str_item_562 = value;
        break;
      case 563:
        _struct._unique_str_item_563 = value;
        break;
      case 564:
        _struct._unique_str_item_564 = value;
        break;
      case 565:
        _struct._unique_str_item_565 = value;
        break;
      case 566:
        _struct._unique_str_item_566 = value;
        break;
      case 567:
        _struct._unique_str_item_567 = value;
        break;
      case 568:
        _struct._unique_str_item_568 = value;
        break;
      case 569:
        _struct._unique_str_item_569 = value;
        break;
      case 570:
        _struct._unique_str_item_570 = value;
        break;
      case 571:
        _struct._unique_str_item_571 = value;
        break;
      case 572:
        _struct._unique_str_item_572 = value;
        break;
      case 573:
        _struct._unique_str_item_573 = value;
        break;
      case 574:
        _struct._unique_str_item_574 = value;
        break;
      case 575:
        _struct._unique_str_item_575 = value;
        break;
      case 576:
        _struct._unique_str_item_576 = value;
        break;
      case 577:
        _struct._unique_str_item_577 = value;
        break;
      case 578:
        _struct._unique_str_item_578 = value;
        break;
      case 579:
        _struct._unique_str_item_579 = value;
        break;
      case 580:
        _struct._unique_str_item_580 = value;
        break;
      case 581:
        _struct._unique_str_item_581 = value;
        break;
      case 582:
        _struct._unique_str_item_582 = value;
        break;
      case 583:
        _struct._unique_str_item_583 = value;
        break;
      case 584:
        _struct._unique_str_item_584 = value;
        break;
      case 585:
        _struct._unique_str_item_585 = value;
        break;
      case 586:
        _struct._unique_str_item_586 = value;
        break;
      case 587:
        _struct._unique_str_item_587 = value;
        break;
      case 588:
        _struct._unique_str_item_588 = value;
        break;
      case 589:
        _struct._unique_str_item_589 = value;
        break;
      case 590:
        _struct._unique_str_item_590 = value;
        break;
      case 591:
        _struct._unique_str_item_591 = value;
        break;
      case 592:
        _struct._unique_str_item_592 = value;
        break;
      case 593:
        _struct._unique_str_item_593 = value;
        break;
      case 594:
        _struct._unique_str_item_594 = value;
        break;
      case 595:
        _struct._unique_str_item_595 = value;
        break;
      case 596:
        _struct._unique_str_item_596 = value;
        break;
      case 597:
        _struct._unique_str_item_597 = value;
        break;
      case 598:
        _struct._unique_str_item_598 = value;
        break;
      case 599:
        _struct._unique_str_item_599 = value;
        break;
      case 600:
        _struct._unique_str_item_600 = value;
        break;
      case 601:
        _struct._unique_str_item_601 = value;
        break;
      case 602:
        _struct._unique_str_item_602 = value;
        break;
      case 603:
        _struct._unique_str_item_603 = value;
        break;
      case 604:
        _struct._unique_str_item_604 = value;
        break;
      case 605:
        _struct._unique_str_item_605 = value;
        break;
      case 606:
        _struct._unique_str_item_606 = value;
        break;
      case 607:
        _struct._unique_str_item_607 = value;
        break;
      case 608:
        _struct._unique_str_item_608 = value;
        break;
      case 609:
        _struct._unique_str_item_609 = value;
        break;
      case 610:
        _struct._unique_str_item_610 = value;
        break;
      case 611:
        _struct._unique_str_item_611 = value;
        break;
      case 612:
        _struct._unique_str_item_612 = value;
        break;
      case 613:
        _struct._unique_str_item_613 = value;
        break;
      case 614:
        _struct._unique_str_item_614 = value;
        break;
      case 615:
        _struct._unique_str_item_615 = value;
        break;
      case 616:
        _struct._unique_str_item_616 = value;
        break;
      case 617:
        _struct._unique_str_item_617 = value;
        break;
      case 618:
        _struct._unique_str_item_618 = value;
        break;
      case 619:
        _struct._unique_str_item_619 = value;
        break;
      case 620:
        _struct._unique_str_item_620 = value;
        break;
      case 621:
        _struct._unique_str_item_621 = value;
        break;
      case 622:
        _struct._unique_str_item_622 = value;
        break;
      case 623:
        _struct._unique_str_item_623 = value;
        break;
      case 624:
        _struct._unique_str_item_624 = value;
        break;
      case 625:
        _struct._unique_str_item_625 = value;
        break;
      case 626:
        _struct._unique_str_item_626 = value;
        break;
      case 627:
        _struct._unique_str_item_627 = value;
        break;
      case 628:
        _struct._unique_str_item_628 = value;
        break;
      case 629:
        _struct._unique_str_item_629 = value;
        break;
      case 630:
        _struct._unique_str_item_630 = value;
        break;
      case 631:
        _struct._unique_str_item_631 = value;
        break;
      case 632:
        _struct._unique_str_item_632 = value;
        break;
      case 633:
        _struct._unique_str_item_633 = value;
        break;
      case 634:
        _struct._unique_str_item_634 = value;
        break;
      case 635:
        _struct._unique_str_item_635 = value;
        break;
      case 636:
        _struct._unique_str_item_636 = value;
        break;
      case 637:
        _struct._unique_str_item_637 = value;
        break;
      case 638:
        _struct._unique_str_item_638 = value;
        break;
      case 639:
        _struct._unique_str_item_639 = value;
        break;
      case 640:
        _struct._unique_str_item_640 = value;
        break;
      case 641:
        _struct._unique_str_item_641 = value;
        break;
      case 642:
        _struct._unique_str_item_642 = value;
        break;
      case 643:
        _struct._unique_str_item_643 = value;
        break;
      case 644:
        _struct._unique_str_item_644 = value;
        break;
      case 645:
        _struct._unique_str_item_645 = value;
        break;
      case 646:
        _struct._unique_str_item_646 = value;
        break;
      case 647:
        _struct._unique_str_item_647 = value;
        break;
      case 648:
        _struct._unique_str_item_648 = value;
        break;
      case 649:
        _struct._unique_str_item_649 = value;
        break;
      case 650:
        _struct._unique_str_item_650 = value;
        break;
      case 651:
        _struct._unique_str_item_651 = value;
        break;
      case 652:
        _struct._unique_str_item_652 = value;
        break;
      case 653:
        _struct._unique_str_item_653 = value;
        break;
      case 654:
        _struct._unique_str_item_654 = value;
        break;
      case 655:
        _struct._unique_str_item_655 = value;
        break;
      case 656:
        _struct._unique_str_item_656 = value;
        break;
      case 657:
        _struct._unique_str_item_657 = value;
        break;
      case 658:
        _struct._unique_str_item_658 = value;
        break;
      case 659:
        _struct._unique_str_item_659 = value;
        break;
      case 660:
        _struct._unique_str_item_660 = value;
        break;
      case 661:
        _struct._unique_str_item_661 = value;
        break;
      case 662:
        _struct._unique_str_item_662 = value;
        break;
      case 663:
        _struct._unique_str_item_663 = value;
        break;
      case 664:
        _struct._unique_str_item_664 = value;
        break;
      case 665:
        _struct._unique_str_item_665 = value;
        break;
      case 666:
        _struct._unique_str_item_666 = value;
        break;
      case 667:
        _struct._unique_str_item_667 = value;
        break;
      case 668:
        _struct._unique_str_item_668 = value;
        break;
      case 669:
        _struct._unique_str_item_669 = value;
        break;
      case 670:
        _struct._unique_str_item_670 = value;
        break;
      case 671:
        _struct._unique_str_item_671 = value;
        break;
      case 672:
        _struct._unique_str_item_672 = value;
        break;
      case 673:
        _struct._unique_str_item_673 = value;
        break;
      case 674:
        _struct._unique_str_item_674 = value;
        break;
      case 675:
        _struct._unique_str_item_675 = value;
        break;
      case 676:
        _struct._unique_str_item_676 = value;
        break;
      case 677:
        _struct._unique_str_item_677 = value;
        break;
      case 678:
        _struct._unique_str_item_678 = value;
        break;
      case 679:
        _struct._unique_str_item_679 = value;
        break;
      case 680:
        _struct._unique_str_item_680 = value;
        break;
      case 681:
        _struct._unique_str_item_681 = value;
        break;
      case 682:
        _struct._unique_str_item_682 = value;
        break;
      case 683:
        _struct._unique_str_item_683 = value;
        break;
      case 684:
        _struct._unique_str_item_684 = value;
        break;
      case 685:
        _struct._unique_str_item_685 = value;
        break;
      case 686:
        _struct._unique_str_item_686 = value;
        break;
      case 687:
        _struct._unique_str_item_687 = value;
        break;
      case 688:
        _struct._unique_str_item_688 = value;
        break;
      case 689:
        _struct._unique_str_item_689 = value;
        break;
      case 690:
        _struct._unique_str_item_690 = value;
        break;
      case 691:
        _struct._unique_str_item_691 = value;
        break;
      case 692:
        _struct._unique_str_item_692 = value;
        break;
      case 693:
        _struct._unique_str_item_693 = value;
        break;
      case 694:
        _struct._unique_str_item_694 = value;
        break;
      case 695:
        _struct._unique_str_item_695 = value;
        break;
      case 696:
        _struct._unique_str_item_696 = value;
        break;
      case 697:
        _struct._unique_str_item_697 = value;
        break;
      case 698:
        _struct._unique_str_item_698 = value;
        break;
      case 699:
        _struct._unique_str_item_699 = value;
        break;
      case 700:
        _struct._unique_str_item_700 = value;
        break;
      case 701:
        _struct._unique_str_item_701 = value;
        break;
      case 702:
        _struct._unique_str_item_702 = value;
        break;
      case 703:
        _struct._unique_str_item_703 = value;
        break;
      case 704:
        _struct._unique_str_item_704 = value;
        break;
      case 705:
        _struct._unique_str_item_705 = value;
        break;
      case 706:
        _struct._unique_str_item_706 = value;
        break;
      case 707:
        _struct._unique_str_item_707 = value;
        break;
      case 708:
        _struct._unique_str_item_708 = value;
        break;
      case 709:
        _struct._unique_str_item_709 = value;
        break;
      case 710:
        _struct._unique_str_item_710 = value;
        break;
      case 711:
        _struct._unique_str_item_711 = value;
        break;
      case 712:
        _struct._unique_str_item_712 = value;
        break;
      case 713:
        _struct._unique_str_item_713 = value;
        break;
      case 714:
        _struct._unique_str_item_714 = value;
        break;
      case 715:
        _struct._unique_str_item_715 = value;
        break;
      case 716:
        _struct._unique_str_item_716 = value;
        break;
      case 717:
        _struct._unique_str_item_717 = value;
        break;
      case 718:
        _struct._unique_str_item_718 = value;
        break;
      case 719:
        _struct._unique_str_item_719 = value;
        break;
      case 720:
        _struct._unique_str_item_720 = value;
        break;
      case 721:
        _struct._unique_str_item_721 = value;
        break;
      case 722:
        _struct._unique_str_item_722 = value;
        break;
      case 723:
        _struct._unique_str_item_723 = value;
        break;
      case 724:
        _struct._unique_str_item_724 = value;
        break;
      case 725:
        _struct._unique_str_item_725 = value;
        break;
      case 726:
        _struct._unique_str_item_726 = value;
        break;
      case 727:
        _struct._unique_str_item_727 = value;
        break;
      case 728:
        _struct._unique_str_item_728 = value;
        break;
      case 729:
        _struct._unique_str_item_729 = value;
        break;
      case 730:
        _struct._unique_str_item_730 = value;
        break;
      case 731:
        _struct._unique_str_item_731 = value;
        break;
      case 732:
        _struct._unique_str_item_732 = value;
        break;
      case 733:
        _struct._unique_str_item_733 = value;
        break;
      case 734:
        _struct._unique_str_item_734 = value;
        break;
      case 735:
        _struct._unique_str_item_735 = value;
        break;
      case 736:
        _struct._unique_str_item_736 = value;
        break;
      case 737:
        _struct._unique_str_item_737 = value;
        break;
      case 738:
        _struct._unique_str_item_738 = value;
        break;
      case 739:
        _struct._unique_str_item_739 = value;
        break;
      case 740:
        _struct._unique_str_item_740 = value;
        break;
      case 741:
        _struct._unique_str_item_741 = value;
        break;
      case 742:
        _struct._unique_str_item_742 = value;
        break;
      case 743:
        _struct._unique_str_item_743 = value;
        break;
      case 744:
        _struct._unique_str_item_744 = value;
        break;
      case 745:
        _struct._unique_str_item_745 = value;
        break;
      case 746:
        _struct._unique_str_item_746 = value;
        break;
      case 747:
        _struct._unique_str_item_747 = value;
        break;
      case 748:
        _struct._unique_str_item_748 = value;
        break;
      case 749:
        _struct._unique_str_item_749 = value;
        break;
      case 750:
        _struct._unique_str_item_750 = value;
        break;
      case 751:
        _struct._unique_str_item_751 = value;
        break;
      case 752:
        _struct._unique_str_item_752 = value;
        break;
      case 753:
        _struct._unique_str_item_753 = value;
        break;
      case 754:
        _struct._unique_str_item_754 = value;
        break;
      case 755:
        _struct._unique_str_item_755 = value;
        break;
      case 756:
        _struct._unique_str_item_756 = value;
        break;
      case 757:
        _struct._unique_str_item_757 = value;
        break;
      case 758:
        _struct._unique_str_item_758 = value;
        break;
      case 759:
        _struct._unique_str_item_759 = value;
        break;
      case 760:
        _struct._unique_str_item_760 = value;
        break;
      case 761:
        _struct._unique_str_item_761 = value;
        break;
      case 762:
        _struct._unique_str_item_762 = value;
        break;
      case 763:
        _struct._unique_str_item_763 = value;
        break;
      case 764:
        _struct._unique_str_item_764 = value;
        break;
      case 765:
        _struct._unique_str_item_765 = value;
        break;
      case 766:
        _struct._unique_str_item_766 = value;
        break;
      case 767:
        _struct._unique_str_item_767 = value;
        break;
      case 768:
        _struct._unique_str_item_768 = value;
        break;
      case 769:
        _struct._unique_str_item_769 = value;
        break;
      case 770:
        _struct._unique_str_item_770 = value;
        break;
      case 771:
        _struct._unique_str_item_771 = value;
        break;
      case 772:
        _struct._unique_str_item_772 = value;
        break;
      case 773:
        _struct._unique_str_item_773 = value;
        break;
      case 774:
        _struct._unique_str_item_774 = value;
        break;
      case 775:
        _struct._unique_str_item_775 = value;
        break;
      case 776:
        _struct._unique_str_item_776 = value;
        break;
      case 777:
        _struct._unique_str_item_777 = value;
        break;
      case 778:
        _struct._unique_str_item_778 = value;
        break;
      case 779:
        _struct._unique_str_item_779 = value;
        break;
      case 780:
        _struct._unique_str_item_780 = value;
        break;
      case 781:
        _struct._unique_str_item_781 = value;
        break;
      case 782:
        _struct._unique_str_item_782 = value;
        break;
      case 783:
        _struct._unique_str_item_783 = value;
        break;
      case 784:
        _struct._unique_str_item_784 = value;
        break;
      case 785:
        _struct._unique_str_item_785 = value;
        break;
      case 786:
        _struct._unique_str_item_786 = value;
        break;
      case 787:
        _struct._unique_str_item_787 = value;
        break;
      case 788:
        _struct._unique_str_item_788 = value;
        break;
      case 789:
        _struct._unique_str_item_789 = value;
        break;
      case 790:
        _struct._unique_str_item_790 = value;
        break;
      case 791:
        _struct._unique_str_item_791 = value;
        break;
      case 792:
        _struct._unique_str_item_792 = value;
        break;
      case 793:
        _struct._unique_str_item_793 = value;
        break;
      case 794:
        _struct._unique_str_item_794 = value;
        break;
      case 795:
        _struct._unique_str_item_795 = value;
        break;
      case 796:
        _struct._unique_str_item_796 = value;
        break;
      case 797:
        _struct._unique_str_item_797 = value;
        break;
      case 798:
        _struct._unique_str_item_798 = value;
        break;
      case 799:
        _struct._unique_str_item_799 = value;
        break;
      case 800:
        _struct._unique_str_item_800 = value;
        break;
      case 801:
        _struct._unique_str_item_801 = value;
        break;
      case 802:
        _struct._unique_str_item_802 = value;
        break;
      case 803:
        _struct._unique_str_item_803 = value;
        break;
      case 804:
        _struct._unique_str_item_804 = value;
        break;
      case 805:
        _struct._unique_str_item_805 = value;
        break;
      case 806:
        _struct._unique_str_item_806 = value;
        break;
      case 807:
        _struct._unique_str_item_807 = value;
        break;
      case 808:
        _struct._unique_str_item_808 = value;
        break;
      case 809:
        _struct._unique_str_item_809 = value;
        break;
      case 810:
        _struct._unique_str_item_810 = value;
        break;
      case 811:
        _struct._unique_str_item_811 = value;
        break;
      case 812:
        _struct._unique_str_item_812 = value;
        break;
      case 813:
        _struct._unique_str_item_813 = value;
        break;
      case 814:
        _struct._unique_str_item_814 = value;
        break;
      case 815:
        _struct._unique_str_item_815 = value;
        break;
      case 816:
        _struct._unique_str_item_816 = value;
        break;
      case 817:
        _struct._unique_str_item_817 = value;
        break;
      case 818:
        _struct._unique_str_item_818 = value;
        break;
      case 819:
        _struct._unique_str_item_819 = value;
        break;
      case 820:
        _struct._unique_str_item_820 = value;
        break;
      case 821:
        _struct._unique_str_item_821 = value;
        break;
      case 822:
        _struct._unique_str_item_822 = value;
        break;
      case 823:
        _struct._unique_str_item_823 = value;
        break;
      case 824:
        _struct._unique_str_item_824 = value;
        break;
      case 825:
        _struct._unique_str_item_825 = value;
        break;
      case 826:
        _struct._unique_str_item_826 = value;
        break;
      case 827:
        _struct._unique_str_item_827 = value;
        break;
      case 828:
        _struct._unique_str_item_828 = value;
        break;
      case 829:
        _struct._unique_str_item_829 = value;
        break;
      case 830:
        _struct._unique_str_item_830 = value;
        break;
      case 831:
        _struct._unique_str_item_831 = value;
        break;
      case 832:
        _struct._unique_str_item_832 = value;
        break;
      case 833:
        _struct._unique_str_item_833 = value;
        break;
      case 834:
        _struct._unique_str_item_834 = value;
        break;
      case 835:
        _struct._unique_str_item_835 = value;
        break;
      case 836:
        _struct._unique_str_item_836 = value;
        break;
      case 837:
        _struct._unique_str_item_837 = value;
        break;
      case 838:
        _struct._unique_str_item_838 = value;
        break;
      case 839:
        _struct._unique_str_item_839 = value;
        break;
      case 840:
        _struct._unique_str_item_840 = value;
        break;
      case 841:
        _struct._unique_str_item_841 = value;
        break;
      case 842:
        _struct._unique_str_item_842 = value;
        break;
      case 843:
        _struct._unique_str_item_843 = value;
        break;
      case 844:
        _struct._unique_str_item_844 = value;
        break;
      case 845:
        _struct._unique_str_item_845 = value;
        break;
      case 846:
        _struct._unique_str_item_846 = value;
        break;
      case 847:
        _struct._unique_str_item_847 = value;
        break;
      case 848:
        _struct._unique_str_item_848 = value;
        break;
      case 849:
        _struct._unique_str_item_849 = value;
        break;
      case 850:
        _struct._unique_str_item_850 = value;
        break;
      case 851:
        _struct._unique_str_item_851 = value;
        break;
      case 852:
        _struct._unique_str_item_852 = value;
        break;
      case 853:
        _struct._unique_str_item_853 = value;
        break;
      case 854:
        _struct._unique_str_item_854 = value;
        break;
      case 855:
        _struct._unique_str_item_855 = value;
        break;
      case 856:
        _struct._unique_str_item_856 = value;
        break;
      case 857:
        _struct._unique_str_item_857 = value;
        break;
      case 858:
        _struct._unique_str_item_858 = value;
        break;
      case 859:
        _struct._unique_str_item_859 = value;
        break;
      case 860:
        _struct._unique_str_item_860 = value;
        break;
      case 861:
        _struct._unique_str_item_861 = value;
        break;
      case 862:
        _struct._unique_str_item_862 = value;
        break;
      case 863:
        _struct._unique_str_item_863 = value;
        break;
      case 864:
        _struct._unique_str_item_864 = value;
        break;
      case 865:
        _struct._unique_str_item_865 = value;
        break;
      case 866:
        _struct._unique_str_item_866 = value;
        break;
      case 867:
        _struct._unique_str_item_867 = value;
        break;
      case 868:
        _struct._unique_str_item_868 = value;
        break;
      case 869:
        _struct._unique_str_item_869 = value;
        break;
      case 870:
        _struct._unique_str_item_870 = value;
        break;
      case 871:
        _struct._unique_str_item_871 = value;
        break;
      case 872:
        _struct._unique_str_item_872 = value;
        break;
      case 873:
        _struct._unique_str_item_873 = value;
        break;
      case 874:
        _struct._unique_str_item_874 = value;
        break;
      case 875:
        _struct._unique_str_item_875 = value;
        break;
      case 876:
        _struct._unique_str_item_876 = value;
        break;
      case 877:
        _struct._unique_str_item_877 = value;
        break;
      case 878:
        _struct._unique_str_item_878 = value;
        break;
      case 879:
        _struct._unique_str_item_879 = value;
        break;
      case 880:
        _struct._unique_str_item_880 = value;
        break;
      case 881:
        _struct._unique_str_item_881 = value;
        break;
      case 882:
        _struct._unique_str_item_882 = value;
        break;
      case 883:
        _struct._unique_str_item_883 = value;
        break;
      case 884:
        _struct._unique_str_item_884 = value;
        break;
      case 885:
        _struct._unique_str_item_885 = value;
        break;
      case 886:
        _struct._unique_str_item_886 = value;
        break;
      case 887:
        _struct._unique_str_item_887 = value;
        break;
      case 888:
        _struct._unique_str_item_888 = value;
        break;
      case 889:
        _struct._unique_str_item_889 = value;
        break;
      case 890:
        _struct._unique_str_item_890 = value;
        break;
      case 891:
        _struct._unique_str_item_891 = value;
        break;
      case 892:
        _struct._unique_str_item_892 = value;
        break;
      case 893:
        _struct._unique_str_item_893 = value;
        break;
      case 894:
        _struct._unique_str_item_894 = value;
        break;
      case 895:
        _struct._unique_str_item_895 = value;
        break;
      case 896:
        _struct._unique_str_item_896 = value;
        break;
      case 897:
        _struct._unique_str_item_897 = value;
        break;
      case 898:
        _struct._unique_str_item_898 = value;
        break;
      case 899:
        _struct._unique_str_item_899 = value;
        break;
      case 900:
        _struct._unique_str_item_900 = value;
        break;
      case 901:
        _struct._unique_str_item_901 = value;
        break;
      case 902:
        _struct._unique_str_item_902 = value;
        break;
      case 903:
        _struct._unique_str_item_903 = value;
        break;
      case 904:
        _struct._unique_str_item_904 = value;
        break;
      case 905:
        _struct._unique_str_item_905 = value;
        break;
      case 906:
        _struct._unique_str_item_906 = value;
        break;
      case 907:
        _struct._unique_str_item_907 = value;
        break;
      case 908:
        _struct._unique_str_item_908 = value;
        break;
      case 909:
        _struct._unique_str_item_909 = value;
        break;
      case 910:
        _struct._unique_str_item_910 = value;
        break;
      case 911:
        _struct._unique_str_item_911 = value;
        break;
      case 912:
        _struct._unique_str_item_912 = value;
        break;
      case 913:
        _struct._unique_str_item_913 = value;
        break;
      case 914:
        _struct._unique_str_item_914 = value;
        break;
      case 915:
        _struct._unique_str_item_915 = value;
        break;
      case 916:
        _struct._unique_str_item_916 = value;
        break;
      case 917:
        _struct._unique_str_item_917 = value;
        break;
      case 918:
        _struct._unique_str_item_918 = value;
        break;
      case 919:
        _struct._unique_str_item_919 = value;
        break;
      case 920:
        _struct._unique_str_item_920 = value;
        break;
      case 921:
        _struct._unique_str_item_921 = value;
        break;
      case 922:
        _struct._unique_str_item_922 = value;
        break;
      case 923:
        _struct._unique_str_item_923 = value;
        break;
      case 924:
        _struct._unique_str_item_924 = value;
        break;
      case 925:
        _struct._unique_str_item_925 = value;
        break;
      case 926:
        _struct._unique_str_item_926 = value;
        break;
      case 927:
        _struct._unique_str_item_927 = value;
        break;
      case 928:
        _struct._unique_str_item_928 = value;
        break;
      case 929:
        _struct._unique_str_item_929 = value;
        break;
      case 930:
        _struct._unique_str_item_930 = value;
        break;
      case 931:
        _struct._unique_str_item_931 = value;
        break;
      case 932:
        _struct._unique_str_item_932 = value;
        break;
      case 933:
        _struct._unique_str_item_933 = value;
        break;
      case 934:
        _struct._unique_str_item_934 = value;
        break;
      case 935:
        _struct._unique_str_item_935 = value;
        break;
      case 936:
        _struct._unique_str_item_936 = value;
        break;
      case 937:
        _struct._unique_str_item_937 = value;
        break;
      case 938:
        _struct._unique_str_item_938 = value;
        break;
      case 939:
        _struct._unique_str_item_939 = value;
        break;
      case 940:
        _struct._unique_str_item_940 = value;
        break;
      case 941:
        _struct._unique_str_item_941 = value;
        break;
      case 942:
        _struct._unique_str_item_942 = value;
        break;
      case 943:
        _struct._unique_str_item_943 = value;
        break;
      case 944:
        _struct._unique_str_item_944 = value;
        break;
      case 945:
        _struct._unique_str_item_945 = value;
        break;
      case 946:
        _struct._unique_str_item_946 = value;
        break;
      case 947:
        _struct._unique_str_item_947 = value;
        break;
      case 948:
        _struct._unique_str_item_948 = value;
        break;
      case 949:
        _struct._unique_str_item_949 = value;
        break;
      case 950:
        _struct._unique_str_item_950 = value;
        break;
      case 951:
        _struct._unique_str_item_951 = value;
        break;
      case 952:
        _struct._unique_str_item_952 = value;
        break;
      case 953:
        _struct._unique_str_item_953 = value;
        break;
      case 954:
        _struct._unique_str_item_954 = value;
        break;
      case 955:
        _struct._unique_str_item_955 = value;
        break;
      case 956:
        _struct._unique_str_item_956 = value;
        break;
      case 957:
        _struct._unique_str_item_957 = value;
        break;
      case 958:
        _struct._unique_str_item_958 = value;
        break;
      case 959:
        _struct._unique_str_item_959 = value;
        break;
      case 960:
        _struct._unique_str_item_960 = value;
        break;
      case 961:
        _struct._unique_str_item_961 = value;
        break;
      case 962:
        _struct._unique_str_item_962 = value;
        break;
      case 963:
        _struct._unique_str_item_963 = value;
        break;
      case 964:
        _struct._unique_str_item_964 = value;
        break;
      case 965:
        _struct._unique_str_item_965 = value;
        break;
      case 966:
        _struct._unique_str_item_966 = value;
        break;
      case 967:
        _struct._unique_str_item_967 = value;
        break;
      case 968:
        _struct._unique_str_item_968 = value;
        break;
      case 969:
        _struct._unique_str_item_969 = value;
        break;
      case 970:
        _struct._unique_str_item_970 = value;
        break;
      case 971:
        _struct._unique_str_item_971 = value;
        break;
      case 972:
        _struct._unique_str_item_972 = value;
        break;
      case 973:
        _struct._unique_str_item_973 = value;
        break;
      case 974:
        _struct._unique_str_item_974 = value;
        break;
      case 975:
        _struct._unique_str_item_975 = value;
        break;
      case 976:
        _struct._unique_str_item_976 = value;
        break;
      case 977:
        _struct._unique_str_item_977 = value;
        break;
      case 978:
        _struct._unique_str_item_978 = value;
        break;
      case 979:
        _struct._unique_str_item_979 = value;
        break;
      case 980:
        _struct._unique_str_item_980 = value;
        break;
      case 981:
        _struct._unique_str_item_981 = value;
        break;
      case 982:
        _struct._unique_str_item_982 = value;
        break;
      case 983:
        _struct._unique_str_item_983 = value;
        break;
      case 984:
        _struct._unique_str_item_984 = value;
        break;
      case 985:
        _struct._unique_str_item_985 = value;
        break;
      case 986:
        _struct._unique_str_item_986 = value;
        break;
      case 987:
        _struct._unique_str_item_987 = value;
        break;
      case 988:
        _struct._unique_str_item_988 = value;
        break;
      case 989:
        _struct._unique_str_item_989 = value;
        break;
      case 990:
        _struct._unique_str_item_990 = value;
        break;
      case 991:
        _struct._unique_str_item_991 = value;
        break;
      case 992:
        _struct._unique_str_item_992 = value;
        break;
      case 993:
        _struct._unique_str_item_993 = value;
        break;
      case 994:
        _struct._unique_str_item_994 = value;
        break;
      case 995:
        _struct._unique_str_item_995 = value;
        break;
      case 996:
        _struct._unique_str_item_996 = value;
        break;
      case 997:
        _struct._unique_str_item_997 = value;
        break;
      case 998:
        _struct._unique_str_item_998 = value;
        break;
      case 999:
        _struct._unique_str_item_999 = value;
        break;
      case 1000:
        _struct._unique_str_item_1000 = value;
        break;
      case 1001:
        _struct._unique_str_item_1001 = value;
        break;
      case 1002:
        _struct._unique_str_item_1002 = value;
        break;
      case 1003:
        _struct._unique_str_item_1003 = value;
        break;
      case 1004:
        _struct._unique_str_item_1004 = value;
        break;
      case 1005:
        _struct._unique_str_item_1005 = value;
        break;
      case 1006:
        _struct._unique_str_item_1006 = value;
        break;
      case 1007:
        _struct._unique_str_item_1007 = value;
        break;
      case 1008:
        _struct._unique_str_item_1008 = value;
        break;
      case 1009:
        _struct._unique_str_item_1009 = value;
        break;
      case 1010:
        _struct._unique_str_item_1010 = value;
        break;
      case 1011:
        _struct._unique_str_item_1011 = value;
        break;
      case 1012:
        _struct._unique_str_item_1012 = value;
        break;
      case 1013:
        _struct._unique_str_item_1013 = value;
        break;
      case 1014:
        _struct._unique_str_item_1014 = value;
        break;
      case 1015:
        _struct._unique_str_item_1015 = value;
        break;
      case 1016:
        _struct._unique_str_item_1016 = value;
        break;
      case 1017:
        _struct._unique_str_item_1017 = value;
        break;
      case 1018:
        _struct._unique_str_item_1018 = value;
        break;
      case 1019:
        _struct._unique_str_item_1019 = value;
        break;
      case 1020:
        _struct._unique_str_item_1020 = value;
        break;
      case 1021:
        _struct._unique_str_item_1021 = value;
        break;
      case 1022:
        _struct._unique_str_item_1022 = value;
        break;
      case 1023:
        _struct._unique_str_item_1023 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// /// Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG().
class rcutils_error_state_t extends ffi.Struct {
  @ffi.Int8()
  external int _unique_message_item_0;
  @ffi.Int8()
  external int _unique_message_item_1;
  @ffi.Int8()
  external int _unique_message_item_2;
  @ffi.Int8()
  external int _unique_message_item_3;
  @ffi.Int8()
  external int _unique_message_item_4;
  @ffi.Int8()
  external int _unique_message_item_5;
  @ffi.Int8()
  external int _unique_message_item_6;
  @ffi.Int8()
  external int _unique_message_item_7;
  @ffi.Int8()
  external int _unique_message_item_8;
  @ffi.Int8()
  external int _unique_message_item_9;
  @ffi.Int8()
  external int _unique_message_item_10;
  @ffi.Int8()
  external int _unique_message_item_11;
  @ffi.Int8()
  external int _unique_message_item_12;
  @ffi.Int8()
  external int _unique_message_item_13;
  @ffi.Int8()
  external int _unique_message_item_14;
  @ffi.Int8()
  external int _unique_message_item_15;
  @ffi.Int8()
  external int _unique_message_item_16;
  @ffi.Int8()
  external int _unique_message_item_17;
  @ffi.Int8()
  external int _unique_message_item_18;
  @ffi.Int8()
  external int _unique_message_item_19;
  @ffi.Int8()
  external int _unique_message_item_20;
  @ffi.Int8()
  external int _unique_message_item_21;
  @ffi.Int8()
  external int _unique_message_item_22;
  @ffi.Int8()
  external int _unique_message_item_23;
  @ffi.Int8()
  external int _unique_message_item_24;
  @ffi.Int8()
  external int _unique_message_item_25;
  @ffi.Int8()
  external int _unique_message_item_26;
  @ffi.Int8()
  external int _unique_message_item_27;
  @ffi.Int8()
  external int _unique_message_item_28;
  @ffi.Int8()
  external int _unique_message_item_29;
  @ffi.Int8()
  external int _unique_message_item_30;
  @ffi.Int8()
  external int _unique_message_item_31;
  @ffi.Int8()
  external int _unique_message_item_32;
  @ffi.Int8()
  external int _unique_message_item_33;
  @ffi.Int8()
  external int _unique_message_item_34;
  @ffi.Int8()
  external int _unique_message_item_35;
  @ffi.Int8()
  external int _unique_message_item_36;
  @ffi.Int8()
  external int _unique_message_item_37;
  @ffi.Int8()
  external int _unique_message_item_38;
  @ffi.Int8()
  external int _unique_message_item_39;
  @ffi.Int8()
  external int _unique_message_item_40;
  @ffi.Int8()
  external int _unique_message_item_41;
  @ffi.Int8()
  external int _unique_message_item_42;
  @ffi.Int8()
  external int _unique_message_item_43;
  @ffi.Int8()
  external int _unique_message_item_44;
  @ffi.Int8()
  external int _unique_message_item_45;
  @ffi.Int8()
  external int _unique_message_item_46;
  @ffi.Int8()
  external int _unique_message_item_47;
  @ffi.Int8()
  external int _unique_message_item_48;
  @ffi.Int8()
  external int _unique_message_item_49;
  @ffi.Int8()
  external int _unique_message_item_50;
  @ffi.Int8()
  external int _unique_message_item_51;
  @ffi.Int8()
  external int _unique_message_item_52;
  @ffi.Int8()
  external int _unique_message_item_53;
  @ffi.Int8()
  external int _unique_message_item_54;
  @ffi.Int8()
  external int _unique_message_item_55;
  @ffi.Int8()
  external int _unique_message_item_56;
  @ffi.Int8()
  external int _unique_message_item_57;
  @ffi.Int8()
  external int _unique_message_item_58;
  @ffi.Int8()
  external int _unique_message_item_59;
  @ffi.Int8()
  external int _unique_message_item_60;
  @ffi.Int8()
  external int _unique_message_item_61;
  @ffi.Int8()
  external int _unique_message_item_62;
  @ffi.Int8()
  external int _unique_message_item_63;
  @ffi.Int8()
  external int _unique_message_item_64;
  @ffi.Int8()
  external int _unique_message_item_65;
  @ffi.Int8()
  external int _unique_message_item_66;
  @ffi.Int8()
  external int _unique_message_item_67;
  @ffi.Int8()
  external int _unique_message_item_68;
  @ffi.Int8()
  external int _unique_message_item_69;
  @ffi.Int8()
  external int _unique_message_item_70;
  @ffi.Int8()
  external int _unique_message_item_71;
  @ffi.Int8()
  external int _unique_message_item_72;
  @ffi.Int8()
  external int _unique_message_item_73;
  @ffi.Int8()
  external int _unique_message_item_74;
  @ffi.Int8()
  external int _unique_message_item_75;
  @ffi.Int8()
  external int _unique_message_item_76;
  @ffi.Int8()
  external int _unique_message_item_77;
  @ffi.Int8()
  external int _unique_message_item_78;
  @ffi.Int8()
  external int _unique_message_item_79;
  @ffi.Int8()
  external int _unique_message_item_80;
  @ffi.Int8()
  external int _unique_message_item_81;
  @ffi.Int8()
  external int _unique_message_item_82;
  @ffi.Int8()
  external int _unique_message_item_83;
  @ffi.Int8()
  external int _unique_message_item_84;
  @ffi.Int8()
  external int _unique_message_item_85;
  @ffi.Int8()
  external int _unique_message_item_86;
  @ffi.Int8()
  external int _unique_message_item_87;
  @ffi.Int8()
  external int _unique_message_item_88;
  @ffi.Int8()
  external int _unique_message_item_89;
  @ffi.Int8()
  external int _unique_message_item_90;
  @ffi.Int8()
  external int _unique_message_item_91;
  @ffi.Int8()
  external int _unique_message_item_92;
  @ffi.Int8()
  external int _unique_message_item_93;
  @ffi.Int8()
  external int _unique_message_item_94;
  @ffi.Int8()
  external int _unique_message_item_95;
  @ffi.Int8()
  external int _unique_message_item_96;
  @ffi.Int8()
  external int _unique_message_item_97;
  @ffi.Int8()
  external int _unique_message_item_98;
  @ffi.Int8()
  external int _unique_message_item_99;
  @ffi.Int8()
  external int _unique_message_item_100;
  @ffi.Int8()
  external int _unique_message_item_101;
  @ffi.Int8()
  external int _unique_message_item_102;
  @ffi.Int8()
  external int _unique_message_item_103;
  @ffi.Int8()
  external int _unique_message_item_104;
  @ffi.Int8()
  external int _unique_message_item_105;
  @ffi.Int8()
  external int _unique_message_item_106;
  @ffi.Int8()
  external int _unique_message_item_107;
  @ffi.Int8()
  external int _unique_message_item_108;
  @ffi.Int8()
  external int _unique_message_item_109;
  @ffi.Int8()
  external int _unique_message_item_110;
  @ffi.Int8()
  external int _unique_message_item_111;
  @ffi.Int8()
  external int _unique_message_item_112;
  @ffi.Int8()
  external int _unique_message_item_113;
  @ffi.Int8()
  external int _unique_message_item_114;
  @ffi.Int8()
  external int _unique_message_item_115;
  @ffi.Int8()
  external int _unique_message_item_116;
  @ffi.Int8()
  external int _unique_message_item_117;
  @ffi.Int8()
  external int _unique_message_item_118;
  @ffi.Int8()
  external int _unique_message_item_119;
  @ffi.Int8()
  external int _unique_message_item_120;
  @ffi.Int8()
  external int _unique_message_item_121;
  @ffi.Int8()
  external int _unique_message_item_122;
  @ffi.Int8()
  external int _unique_message_item_123;
  @ffi.Int8()
  external int _unique_message_item_124;
  @ffi.Int8()
  external int _unique_message_item_125;
  @ffi.Int8()
  external int _unique_message_item_126;
  @ffi.Int8()
  external int _unique_message_item_127;
  @ffi.Int8()
  external int _unique_message_item_128;
  @ffi.Int8()
  external int _unique_message_item_129;
  @ffi.Int8()
  external int _unique_message_item_130;
  @ffi.Int8()
  external int _unique_message_item_131;
  @ffi.Int8()
  external int _unique_message_item_132;
  @ffi.Int8()
  external int _unique_message_item_133;
  @ffi.Int8()
  external int _unique_message_item_134;
  @ffi.Int8()
  external int _unique_message_item_135;
  @ffi.Int8()
  external int _unique_message_item_136;
  @ffi.Int8()
  external int _unique_message_item_137;
  @ffi.Int8()
  external int _unique_message_item_138;
  @ffi.Int8()
  external int _unique_message_item_139;
  @ffi.Int8()
  external int _unique_message_item_140;
  @ffi.Int8()
  external int _unique_message_item_141;
  @ffi.Int8()
  external int _unique_message_item_142;
  @ffi.Int8()
  external int _unique_message_item_143;
  @ffi.Int8()
  external int _unique_message_item_144;
  @ffi.Int8()
  external int _unique_message_item_145;
  @ffi.Int8()
  external int _unique_message_item_146;
  @ffi.Int8()
  external int _unique_message_item_147;
  @ffi.Int8()
  external int _unique_message_item_148;
  @ffi.Int8()
  external int _unique_message_item_149;
  @ffi.Int8()
  external int _unique_message_item_150;
  @ffi.Int8()
  external int _unique_message_item_151;
  @ffi.Int8()
  external int _unique_message_item_152;
  @ffi.Int8()
  external int _unique_message_item_153;
  @ffi.Int8()
  external int _unique_message_item_154;
  @ffi.Int8()
  external int _unique_message_item_155;
  @ffi.Int8()
  external int _unique_message_item_156;
  @ffi.Int8()
  external int _unique_message_item_157;
  @ffi.Int8()
  external int _unique_message_item_158;
  @ffi.Int8()
  external int _unique_message_item_159;
  @ffi.Int8()
  external int _unique_message_item_160;
  @ffi.Int8()
  external int _unique_message_item_161;
  @ffi.Int8()
  external int _unique_message_item_162;
  @ffi.Int8()
  external int _unique_message_item_163;
  @ffi.Int8()
  external int _unique_message_item_164;
  @ffi.Int8()
  external int _unique_message_item_165;
  @ffi.Int8()
  external int _unique_message_item_166;
  @ffi.Int8()
  external int _unique_message_item_167;
  @ffi.Int8()
  external int _unique_message_item_168;
  @ffi.Int8()
  external int _unique_message_item_169;
  @ffi.Int8()
  external int _unique_message_item_170;
  @ffi.Int8()
  external int _unique_message_item_171;
  @ffi.Int8()
  external int _unique_message_item_172;
  @ffi.Int8()
  external int _unique_message_item_173;
  @ffi.Int8()
  external int _unique_message_item_174;
  @ffi.Int8()
  external int _unique_message_item_175;
  @ffi.Int8()
  external int _unique_message_item_176;
  @ffi.Int8()
  external int _unique_message_item_177;
  @ffi.Int8()
  external int _unique_message_item_178;
  @ffi.Int8()
  external int _unique_message_item_179;
  @ffi.Int8()
  external int _unique_message_item_180;
  @ffi.Int8()
  external int _unique_message_item_181;
  @ffi.Int8()
  external int _unique_message_item_182;
  @ffi.Int8()
  external int _unique_message_item_183;
  @ffi.Int8()
  external int _unique_message_item_184;
  @ffi.Int8()
  external int _unique_message_item_185;
  @ffi.Int8()
  external int _unique_message_item_186;
  @ffi.Int8()
  external int _unique_message_item_187;
  @ffi.Int8()
  external int _unique_message_item_188;
  @ffi.Int8()
  external int _unique_message_item_189;
  @ffi.Int8()
  external int _unique_message_item_190;
  @ffi.Int8()
  external int _unique_message_item_191;
  @ffi.Int8()
  external int _unique_message_item_192;
  @ffi.Int8()
  external int _unique_message_item_193;
  @ffi.Int8()
  external int _unique_message_item_194;
  @ffi.Int8()
  external int _unique_message_item_195;
  @ffi.Int8()
  external int _unique_message_item_196;
  @ffi.Int8()
  external int _unique_message_item_197;
  @ffi.Int8()
  external int _unique_message_item_198;
  @ffi.Int8()
  external int _unique_message_item_199;
  @ffi.Int8()
  external int _unique_message_item_200;
  @ffi.Int8()
  external int _unique_message_item_201;
  @ffi.Int8()
  external int _unique_message_item_202;
  @ffi.Int8()
  external int _unique_message_item_203;
  @ffi.Int8()
  external int _unique_message_item_204;
  @ffi.Int8()
  external int _unique_message_item_205;
  @ffi.Int8()
  external int _unique_message_item_206;
  @ffi.Int8()
  external int _unique_message_item_207;
  @ffi.Int8()
  external int _unique_message_item_208;
  @ffi.Int8()
  external int _unique_message_item_209;
  @ffi.Int8()
  external int _unique_message_item_210;
  @ffi.Int8()
  external int _unique_message_item_211;
  @ffi.Int8()
  external int _unique_message_item_212;
  @ffi.Int8()
  external int _unique_message_item_213;
  @ffi.Int8()
  external int _unique_message_item_214;
  @ffi.Int8()
  external int _unique_message_item_215;
  @ffi.Int8()
  external int _unique_message_item_216;
  @ffi.Int8()
  external int _unique_message_item_217;
  @ffi.Int8()
  external int _unique_message_item_218;
  @ffi.Int8()
  external int _unique_message_item_219;
  @ffi.Int8()
  external int _unique_message_item_220;
  @ffi.Int8()
  external int _unique_message_item_221;
  @ffi.Int8()
  external int _unique_message_item_222;
  @ffi.Int8()
  external int _unique_message_item_223;
  @ffi.Int8()
  external int _unique_message_item_224;
  @ffi.Int8()
  external int _unique_message_item_225;
  @ffi.Int8()
  external int _unique_message_item_226;
  @ffi.Int8()
  external int _unique_message_item_227;
  @ffi.Int8()
  external int _unique_message_item_228;
  @ffi.Int8()
  external int _unique_message_item_229;
  @ffi.Int8()
  external int _unique_message_item_230;
  @ffi.Int8()
  external int _unique_message_item_231;
  @ffi.Int8()
  external int _unique_message_item_232;
  @ffi.Int8()
  external int _unique_message_item_233;
  @ffi.Int8()
  external int _unique_message_item_234;
  @ffi.Int8()
  external int _unique_message_item_235;
  @ffi.Int8()
  external int _unique_message_item_236;
  @ffi.Int8()
  external int _unique_message_item_237;
  @ffi.Int8()
  external int _unique_message_item_238;
  @ffi.Int8()
  external int _unique_message_item_239;
  @ffi.Int8()
  external int _unique_message_item_240;
  @ffi.Int8()
  external int _unique_message_item_241;
  @ffi.Int8()
  external int _unique_message_item_242;
  @ffi.Int8()
  external int _unique_message_item_243;
  @ffi.Int8()
  external int _unique_message_item_244;
  @ffi.Int8()
  external int _unique_message_item_245;
  @ffi.Int8()
  external int _unique_message_item_246;
  @ffi.Int8()
  external int _unique_message_item_247;
  @ffi.Int8()
  external int _unique_message_item_248;
  @ffi.Int8()
  external int _unique_message_item_249;
  @ffi.Int8()
  external int _unique_message_item_250;
  @ffi.Int8()
  external int _unique_message_item_251;
  @ffi.Int8()
  external int _unique_message_item_252;
  @ffi.Int8()
  external int _unique_message_item_253;
  @ffi.Int8()
  external int _unique_message_item_254;
  @ffi.Int8()
  external int _unique_message_item_255;
  @ffi.Int8()
  external int _unique_message_item_256;
  @ffi.Int8()
  external int _unique_message_item_257;
  @ffi.Int8()
  external int _unique_message_item_258;
  @ffi.Int8()
  external int _unique_message_item_259;
  @ffi.Int8()
  external int _unique_message_item_260;
  @ffi.Int8()
  external int _unique_message_item_261;
  @ffi.Int8()
  external int _unique_message_item_262;
  @ffi.Int8()
  external int _unique_message_item_263;
  @ffi.Int8()
  external int _unique_message_item_264;
  @ffi.Int8()
  external int _unique_message_item_265;
  @ffi.Int8()
  external int _unique_message_item_266;
  @ffi.Int8()
  external int _unique_message_item_267;
  @ffi.Int8()
  external int _unique_message_item_268;
  @ffi.Int8()
  external int _unique_message_item_269;
  @ffi.Int8()
  external int _unique_message_item_270;
  @ffi.Int8()
  external int _unique_message_item_271;
  @ffi.Int8()
  external int _unique_message_item_272;
  @ffi.Int8()
  external int _unique_message_item_273;
  @ffi.Int8()
  external int _unique_message_item_274;
  @ffi.Int8()
  external int _unique_message_item_275;
  @ffi.Int8()
  external int _unique_message_item_276;
  @ffi.Int8()
  external int _unique_message_item_277;
  @ffi.Int8()
  external int _unique_message_item_278;
  @ffi.Int8()
  external int _unique_message_item_279;
  @ffi.Int8()
  external int _unique_message_item_280;
  @ffi.Int8()
  external int _unique_message_item_281;
  @ffi.Int8()
  external int _unique_message_item_282;
  @ffi.Int8()
  external int _unique_message_item_283;
  @ffi.Int8()
  external int _unique_message_item_284;
  @ffi.Int8()
  external int _unique_message_item_285;
  @ffi.Int8()
  external int _unique_message_item_286;
  @ffi.Int8()
  external int _unique_message_item_287;
  @ffi.Int8()
  external int _unique_message_item_288;
  @ffi.Int8()
  external int _unique_message_item_289;
  @ffi.Int8()
  external int _unique_message_item_290;
  @ffi.Int8()
  external int _unique_message_item_291;
  @ffi.Int8()
  external int _unique_message_item_292;
  @ffi.Int8()
  external int _unique_message_item_293;
  @ffi.Int8()
  external int _unique_message_item_294;
  @ffi.Int8()
  external int _unique_message_item_295;
  @ffi.Int8()
  external int _unique_message_item_296;
  @ffi.Int8()
  external int _unique_message_item_297;
  @ffi.Int8()
  external int _unique_message_item_298;
  @ffi.Int8()
  external int _unique_message_item_299;
  @ffi.Int8()
  external int _unique_message_item_300;
  @ffi.Int8()
  external int _unique_message_item_301;
  @ffi.Int8()
  external int _unique_message_item_302;
  @ffi.Int8()
  external int _unique_message_item_303;
  @ffi.Int8()
  external int _unique_message_item_304;
  @ffi.Int8()
  external int _unique_message_item_305;
  @ffi.Int8()
  external int _unique_message_item_306;
  @ffi.Int8()
  external int _unique_message_item_307;
  @ffi.Int8()
  external int _unique_message_item_308;
  @ffi.Int8()
  external int _unique_message_item_309;
  @ffi.Int8()
  external int _unique_message_item_310;
  @ffi.Int8()
  external int _unique_message_item_311;
  @ffi.Int8()
  external int _unique_message_item_312;
  @ffi.Int8()
  external int _unique_message_item_313;
  @ffi.Int8()
  external int _unique_message_item_314;
  @ffi.Int8()
  external int _unique_message_item_315;
  @ffi.Int8()
  external int _unique_message_item_316;
  @ffi.Int8()
  external int _unique_message_item_317;
  @ffi.Int8()
  external int _unique_message_item_318;
  @ffi.Int8()
  external int _unique_message_item_319;
  @ffi.Int8()
  external int _unique_message_item_320;
  @ffi.Int8()
  external int _unique_message_item_321;
  @ffi.Int8()
  external int _unique_message_item_322;
  @ffi.Int8()
  external int _unique_message_item_323;
  @ffi.Int8()
  external int _unique_message_item_324;
  @ffi.Int8()
  external int _unique_message_item_325;
  @ffi.Int8()
  external int _unique_message_item_326;
  @ffi.Int8()
  external int _unique_message_item_327;
  @ffi.Int8()
  external int _unique_message_item_328;
  @ffi.Int8()
  external int _unique_message_item_329;
  @ffi.Int8()
  external int _unique_message_item_330;
  @ffi.Int8()
  external int _unique_message_item_331;
  @ffi.Int8()
  external int _unique_message_item_332;
  @ffi.Int8()
  external int _unique_message_item_333;
  @ffi.Int8()
  external int _unique_message_item_334;
  @ffi.Int8()
  external int _unique_message_item_335;
  @ffi.Int8()
  external int _unique_message_item_336;
  @ffi.Int8()
  external int _unique_message_item_337;
  @ffi.Int8()
  external int _unique_message_item_338;
  @ffi.Int8()
  external int _unique_message_item_339;
  @ffi.Int8()
  external int _unique_message_item_340;
  @ffi.Int8()
  external int _unique_message_item_341;
  @ffi.Int8()
  external int _unique_message_item_342;
  @ffi.Int8()
  external int _unique_message_item_343;
  @ffi.Int8()
  external int _unique_message_item_344;
  @ffi.Int8()
  external int _unique_message_item_345;
  @ffi.Int8()
  external int _unique_message_item_346;
  @ffi.Int8()
  external int _unique_message_item_347;
  @ffi.Int8()
  external int _unique_message_item_348;
  @ffi.Int8()
  external int _unique_message_item_349;
  @ffi.Int8()
  external int _unique_message_item_350;
  @ffi.Int8()
  external int _unique_message_item_351;
  @ffi.Int8()
  external int _unique_message_item_352;
  @ffi.Int8()
  external int _unique_message_item_353;
  @ffi.Int8()
  external int _unique_message_item_354;
  @ffi.Int8()
  external int _unique_message_item_355;
  @ffi.Int8()
  external int _unique_message_item_356;
  @ffi.Int8()
  external int _unique_message_item_357;
  @ffi.Int8()
  external int _unique_message_item_358;
  @ffi.Int8()
  external int _unique_message_item_359;
  @ffi.Int8()
  external int _unique_message_item_360;
  @ffi.Int8()
  external int _unique_message_item_361;
  @ffi.Int8()
  external int _unique_message_item_362;
  @ffi.Int8()
  external int _unique_message_item_363;
  @ffi.Int8()
  external int _unique_message_item_364;
  @ffi.Int8()
  external int _unique_message_item_365;
  @ffi.Int8()
  external int _unique_message_item_366;
  @ffi.Int8()
  external int _unique_message_item_367;
  @ffi.Int8()
  external int _unique_message_item_368;
  @ffi.Int8()
  external int _unique_message_item_369;
  @ffi.Int8()
  external int _unique_message_item_370;
  @ffi.Int8()
  external int _unique_message_item_371;
  @ffi.Int8()
  external int _unique_message_item_372;
  @ffi.Int8()
  external int _unique_message_item_373;
  @ffi.Int8()
  external int _unique_message_item_374;
  @ffi.Int8()
  external int _unique_message_item_375;
  @ffi.Int8()
  external int _unique_message_item_376;
  @ffi.Int8()
  external int _unique_message_item_377;
  @ffi.Int8()
  external int _unique_message_item_378;
  @ffi.Int8()
  external int _unique_message_item_379;
  @ffi.Int8()
  external int _unique_message_item_380;
  @ffi.Int8()
  external int _unique_message_item_381;
  @ffi.Int8()
  external int _unique_message_item_382;
  @ffi.Int8()
  external int _unique_message_item_383;
  @ffi.Int8()
  external int _unique_message_item_384;
  @ffi.Int8()
  external int _unique_message_item_385;
  @ffi.Int8()
  external int _unique_message_item_386;
  @ffi.Int8()
  external int _unique_message_item_387;
  @ffi.Int8()
  external int _unique_message_item_388;
  @ffi.Int8()
  external int _unique_message_item_389;
  @ffi.Int8()
  external int _unique_message_item_390;
  @ffi.Int8()
  external int _unique_message_item_391;
  @ffi.Int8()
  external int _unique_message_item_392;
  @ffi.Int8()
  external int _unique_message_item_393;
  @ffi.Int8()
  external int _unique_message_item_394;
  @ffi.Int8()
  external int _unique_message_item_395;
  @ffi.Int8()
  external int _unique_message_item_396;
  @ffi.Int8()
  external int _unique_message_item_397;
  @ffi.Int8()
  external int _unique_message_item_398;
  @ffi.Int8()
  external int _unique_message_item_399;
  @ffi.Int8()
  external int _unique_message_item_400;
  @ffi.Int8()
  external int _unique_message_item_401;
  @ffi.Int8()
  external int _unique_message_item_402;
  @ffi.Int8()
  external int _unique_message_item_403;
  @ffi.Int8()
  external int _unique_message_item_404;
  @ffi.Int8()
  external int _unique_message_item_405;
  @ffi.Int8()
  external int _unique_message_item_406;
  @ffi.Int8()
  external int _unique_message_item_407;
  @ffi.Int8()
  external int _unique_message_item_408;
  @ffi.Int8()
  external int _unique_message_item_409;
  @ffi.Int8()
  external int _unique_message_item_410;
  @ffi.Int8()
  external int _unique_message_item_411;
  @ffi.Int8()
  external int _unique_message_item_412;
  @ffi.Int8()
  external int _unique_message_item_413;
  @ffi.Int8()
  external int _unique_message_item_414;
  @ffi.Int8()
  external int _unique_message_item_415;
  @ffi.Int8()
  external int _unique_message_item_416;
  @ffi.Int8()
  external int _unique_message_item_417;
  @ffi.Int8()
  external int _unique_message_item_418;
  @ffi.Int8()
  external int _unique_message_item_419;
  @ffi.Int8()
  external int _unique_message_item_420;
  @ffi.Int8()
  external int _unique_message_item_421;
  @ffi.Int8()
  external int _unique_message_item_422;
  @ffi.Int8()
  external int _unique_message_item_423;
  @ffi.Int8()
  external int _unique_message_item_424;
  @ffi.Int8()
  external int _unique_message_item_425;
  @ffi.Int8()
  external int _unique_message_item_426;
  @ffi.Int8()
  external int _unique_message_item_427;
  @ffi.Int8()
  external int _unique_message_item_428;
  @ffi.Int8()
  external int _unique_message_item_429;
  @ffi.Int8()
  external int _unique_message_item_430;
  @ffi.Int8()
  external int _unique_message_item_431;
  @ffi.Int8()
  external int _unique_message_item_432;
  @ffi.Int8()
  external int _unique_message_item_433;
  @ffi.Int8()
  external int _unique_message_item_434;
  @ffi.Int8()
  external int _unique_message_item_435;
  @ffi.Int8()
  external int _unique_message_item_436;
  @ffi.Int8()
  external int _unique_message_item_437;
  @ffi.Int8()
  external int _unique_message_item_438;
  @ffi.Int8()
  external int _unique_message_item_439;
  @ffi.Int8()
  external int _unique_message_item_440;
  @ffi.Int8()
  external int _unique_message_item_441;
  @ffi.Int8()
  external int _unique_message_item_442;
  @ffi.Int8()
  external int _unique_message_item_443;
  @ffi.Int8()
  external int _unique_message_item_444;
  @ffi.Int8()
  external int _unique_message_item_445;
  @ffi.Int8()
  external int _unique_message_item_446;
  @ffi.Int8()
  external int _unique_message_item_447;
  @ffi.Int8()
  external int _unique_message_item_448;
  @ffi.Int8()
  external int _unique_message_item_449;
  @ffi.Int8()
  external int _unique_message_item_450;
  @ffi.Int8()
  external int _unique_message_item_451;
  @ffi.Int8()
  external int _unique_message_item_452;
  @ffi.Int8()
  external int _unique_message_item_453;
  @ffi.Int8()
  external int _unique_message_item_454;
  @ffi.Int8()
  external int _unique_message_item_455;
  @ffi.Int8()
  external int _unique_message_item_456;
  @ffi.Int8()
  external int _unique_message_item_457;
  @ffi.Int8()
  external int _unique_message_item_458;
  @ffi.Int8()
  external int _unique_message_item_459;
  @ffi.Int8()
  external int _unique_message_item_460;
  @ffi.Int8()
  external int _unique_message_item_461;
  @ffi.Int8()
  external int _unique_message_item_462;
  @ffi.Int8()
  external int _unique_message_item_463;
  @ffi.Int8()
  external int _unique_message_item_464;
  @ffi.Int8()
  external int _unique_message_item_465;
  @ffi.Int8()
  external int _unique_message_item_466;
  @ffi.Int8()
  external int _unique_message_item_467;
  @ffi.Int8()
  external int _unique_message_item_468;
  @ffi.Int8()
  external int _unique_message_item_469;
  @ffi.Int8()
  external int _unique_message_item_470;
  @ffi.Int8()
  external int _unique_message_item_471;
  @ffi.Int8()
  external int _unique_message_item_472;
  @ffi.Int8()
  external int _unique_message_item_473;
  @ffi.Int8()
  external int _unique_message_item_474;
  @ffi.Int8()
  external int _unique_message_item_475;
  @ffi.Int8()
  external int _unique_message_item_476;
  @ffi.Int8()
  external int _unique_message_item_477;
  @ffi.Int8()
  external int _unique_message_item_478;
  @ffi.Int8()
  external int _unique_message_item_479;
  @ffi.Int8()
  external int _unique_message_item_480;
  @ffi.Int8()
  external int _unique_message_item_481;
  @ffi.Int8()
  external int _unique_message_item_482;
  @ffi.Int8()
  external int _unique_message_item_483;
  @ffi.Int8()
  external int _unique_message_item_484;
  @ffi.Int8()
  external int _unique_message_item_485;
  @ffi.Int8()
  external int _unique_message_item_486;
  @ffi.Int8()
  external int _unique_message_item_487;
  @ffi.Int8()
  external int _unique_message_item_488;
  @ffi.Int8()
  external int _unique_message_item_489;
  @ffi.Int8()
  external int _unique_message_item_490;
  @ffi.Int8()
  external int _unique_message_item_491;
  @ffi.Int8()
  external int _unique_message_item_492;
  @ffi.Int8()
  external int _unique_message_item_493;
  @ffi.Int8()
  external int _unique_message_item_494;
  @ffi.Int8()
  external int _unique_message_item_495;
  @ffi.Int8()
  external int _unique_message_item_496;
  @ffi.Int8()
  external int _unique_message_item_497;
  @ffi.Int8()
  external int _unique_message_item_498;
  @ffi.Int8()
  external int _unique_message_item_499;
  @ffi.Int8()
  external int _unique_message_item_500;
  @ffi.Int8()
  external int _unique_message_item_501;
  @ffi.Int8()
  external int _unique_message_item_502;
  @ffi.Int8()
  external int _unique_message_item_503;
  @ffi.Int8()
  external int _unique_message_item_504;
  @ffi.Int8()
  external int _unique_message_item_505;
  @ffi.Int8()
  external int _unique_message_item_506;
  @ffi.Int8()
  external int _unique_message_item_507;
  @ffi.Int8()
  external int _unique_message_item_508;
  @ffi.Int8()
  external int _unique_message_item_509;
  @ffi.Int8()
  external int _unique_message_item_510;
  @ffi.Int8()
  external int _unique_message_item_511;
  @ffi.Int8()
  external int _unique_message_item_512;
  @ffi.Int8()
  external int _unique_message_item_513;
  @ffi.Int8()
  external int _unique_message_item_514;
  @ffi.Int8()
  external int _unique_message_item_515;
  @ffi.Int8()
  external int _unique_message_item_516;
  @ffi.Int8()
  external int _unique_message_item_517;
  @ffi.Int8()
  external int _unique_message_item_518;
  @ffi.Int8()
  external int _unique_message_item_519;
  @ffi.Int8()
  external int _unique_message_item_520;
  @ffi.Int8()
  external int _unique_message_item_521;
  @ffi.Int8()
  external int _unique_message_item_522;
  @ffi.Int8()
  external int _unique_message_item_523;
  @ffi.Int8()
  external int _unique_message_item_524;
  @ffi.Int8()
  external int _unique_message_item_525;
  @ffi.Int8()
  external int _unique_message_item_526;
  @ffi.Int8()
  external int _unique_message_item_527;
  @ffi.Int8()
  external int _unique_message_item_528;
  @ffi.Int8()
  external int _unique_message_item_529;
  @ffi.Int8()
  external int _unique_message_item_530;
  @ffi.Int8()
  external int _unique_message_item_531;
  @ffi.Int8()
  external int _unique_message_item_532;
  @ffi.Int8()
  external int _unique_message_item_533;
  @ffi.Int8()
  external int _unique_message_item_534;
  @ffi.Int8()
  external int _unique_message_item_535;
  @ffi.Int8()
  external int _unique_message_item_536;
  @ffi.Int8()
  external int _unique_message_item_537;
  @ffi.Int8()
  external int _unique_message_item_538;
  @ffi.Int8()
  external int _unique_message_item_539;
  @ffi.Int8()
  external int _unique_message_item_540;
  @ffi.Int8()
  external int _unique_message_item_541;
  @ffi.Int8()
  external int _unique_message_item_542;
  @ffi.Int8()
  external int _unique_message_item_543;
  @ffi.Int8()
  external int _unique_message_item_544;
  @ffi.Int8()
  external int _unique_message_item_545;
  @ffi.Int8()
  external int _unique_message_item_546;
  @ffi.Int8()
  external int _unique_message_item_547;
  @ffi.Int8()
  external int _unique_message_item_548;
  @ffi.Int8()
  external int _unique_message_item_549;
  @ffi.Int8()
  external int _unique_message_item_550;
  @ffi.Int8()
  external int _unique_message_item_551;
  @ffi.Int8()
  external int _unique_message_item_552;
  @ffi.Int8()
  external int _unique_message_item_553;
  @ffi.Int8()
  external int _unique_message_item_554;
  @ffi.Int8()
  external int _unique_message_item_555;
  @ffi.Int8()
  external int _unique_message_item_556;
  @ffi.Int8()
  external int _unique_message_item_557;
  @ffi.Int8()
  external int _unique_message_item_558;
  @ffi.Int8()
  external int _unique_message_item_559;
  @ffi.Int8()
  external int _unique_message_item_560;
  @ffi.Int8()
  external int _unique_message_item_561;
  @ffi.Int8()
  external int _unique_message_item_562;
  @ffi.Int8()
  external int _unique_message_item_563;
  @ffi.Int8()
  external int _unique_message_item_564;
  @ffi.Int8()
  external int _unique_message_item_565;
  @ffi.Int8()
  external int _unique_message_item_566;
  @ffi.Int8()
  external int _unique_message_item_567;
  @ffi.Int8()
  external int _unique_message_item_568;
  @ffi.Int8()
  external int _unique_message_item_569;
  @ffi.Int8()
  external int _unique_message_item_570;
  @ffi.Int8()
  external int _unique_message_item_571;
  @ffi.Int8()
  external int _unique_message_item_572;
  @ffi.Int8()
  external int _unique_message_item_573;
  @ffi.Int8()
  external int _unique_message_item_574;
  @ffi.Int8()
  external int _unique_message_item_575;
  @ffi.Int8()
  external int _unique_message_item_576;
  @ffi.Int8()
  external int _unique_message_item_577;
  @ffi.Int8()
  external int _unique_message_item_578;
  @ffi.Int8()
  external int _unique_message_item_579;
  @ffi.Int8()
  external int _unique_message_item_580;
  @ffi.Int8()
  external int _unique_message_item_581;
  @ffi.Int8()
  external int _unique_message_item_582;
  @ffi.Int8()
  external int _unique_message_item_583;
  @ffi.Int8()
  external int _unique_message_item_584;
  @ffi.Int8()
  external int _unique_message_item_585;
  @ffi.Int8()
  external int _unique_message_item_586;
  @ffi.Int8()
  external int _unique_message_item_587;
  @ffi.Int8()
  external int _unique_message_item_588;
  @ffi.Int8()
  external int _unique_message_item_589;
  @ffi.Int8()
  external int _unique_message_item_590;
  @ffi.Int8()
  external int _unique_message_item_591;
  @ffi.Int8()
  external int _unique_message_item_592;
  @ffi.Int8()
  external int _unique_message_item_593;
  @ffi.Int8()
  external int _unique_message_item_594;
  @ffi.Int8()
  external int _unique_message_item_595;
  @ffi.Int8()
  external int _unique_message_item_596;
  @ffi.Int8()
  external int _unique_message_item_597;
  @ffi.Int8()
  external int _unique_message_item_598;
  @ffi.Int8()
  external int _unique_message_item_599;
  @ffi.Int8()
  external int _unique_message_item_600;
  @ffi.Int8()
  external int _unique_message_item_601;
  @ffi.Int8()
  external int _unique_message_item_602;
  @ffi.Int8()
  external int _unique_message_item_603;
  @ffi.Int8()
  external int _unique_message_item_604;
  @ffi.Int8()
  external int _unique_message_item_605;
  @ffi.Int8()
  external int _unique_message_item_606;
  @ffi.Int8()
  external int _unique_message_item_607;
  @ffi.Int8()
  external int _unique_message_item_608;
  @ffi.Int8()
  external int _unique_message_item_609;
  @ffi.Int8()
  external int _unique_message_item_610;
  @ffi.Int8()
  external int _unique_message_item_611;
  @ffi.Int8()
  external int _unique_message_item_612;
  @ffi.Int8()
  external int _unique_message_item_613;
  @ffi.Int8()
  external int _unique_message_item_614;
  @ffi.Int8()
  external int _unique_message_item_615;
  @ffi.Int8()
  external int _unique_message_item_616;
  @ffi.Int8()
  external int _unique_message_item_617;
  @ffi.Int8()
  external int _unique_message_item_618;
  @ffi.Int8()
  external int _unique_message_item_619;
  @ffi.Int8()
  external int _unique_message_item_620;
  @ffi.Int8()
  external int _unique_message_item_621;
  @ffi.Int8()
  external int _unique_message_item_622;
  @ffi.Int8()
  external int _unique_message_item_623;
  @ffi.Int8()
  external int _unique_message_item_624;
  @ffi.Int8()
  external int _unique_message_item_625;
  @ffi.Int8()
  external int _unique_message_item_626;
  @ffi.Int8()
  external int _unique_message_item_627;
  @ffi.Int8()
  external int _unique_message_item_628;
  @ffi.Int8()
  external int _unique_message_item_629;
  @ffi.Int8()
  external int _unique_message_item_630;
  @ffi.Int8()
  external int _unique_message_item_631;
  @ffi.Int8()
  external int _unique_message_item_632;
  @ffi.Int8()
  external int _unique_message_item_633;
  @ffi.Int8()
  external int _unique_message_item_634;
  @ffi.Int8()
  external int _unique_message_item_635;
  @ffi.Int8()
  external int _unique_message_item_636;
  @ffi.Int8()
  external int _unique_message_item_637;
  @ffi.Int8()
  external int _unique_message_item_638;
  @ffi.Int8()
  external int _unique_message_item_639;
  @ffi.Int8()
  external int _unique_message_item_640;
  @ffi.Int8()
  external int _unique_message_item_641;
  @ffi.Int8()
  external int _unique_message_item_642;
  @ffi.Int8()
  external int _unique_message_item_643;
  @ffi.Int8()
  external int _unique_message_item_644;
  @ffi.Int8()
  external int _unique_message_item_645;
  @ffi.Int8()
  external int _unique_message_item_646;
  @ffi.Int8()
  external int _unique_message_item_647;
  @ffi.Int8()
  external int _unique_message_item_648;
  @ffi.Int8()
  external int _unique_message_item_649;
  @ffi.Int8()
  external int _unique_message_item_650;
  @ffi.Int8()
  external int _unique_message_item_651;
  @ffi.Int8()
  external int _unique_message_item_652;
  @ffi.Int8()
  external int _unique_message_item_653;
  @ffi.Int8()
  external int _unique_message_item_654;
  @ffi.Int8()
  external int _unique_message_item_655;
  @ffi.Int8()
  external int _unique_message_item_656;
  @ffi.Int8()
  external int _unique_message_item_657;
  @ffi.Int8()
  external int _unique_message_item_658;
  @ffi.Int8()
  external int _unique_message_item_659;
  @ffi.Int8()
  external int _unique_message_item_660;
  @ffi.Int8()
  external int _unique_message_item_661;
  @ffi.Int8()
  external int _unique_message_item_662;
  @ffi.Int8()
  external int _unique_message_item_663;
  @ffi.Int8()
  external int _unique_message_item_664;
  @ffi.Int8()
  external int _unique_message_item_665;
  @ffi.Int8()
  external int _unique_message_item_666;
  @ffi.Int8()
  external int _unique_message_item_667;
  @ffi.Int8()
  external int _unique_message_item_668;
  @ffi.Int8()
  external int _unique_message_item_669;
  @ffi.Int8()
  external int _unique_message_item_670;
  @ffi.Int8()
  external int _unique_message_item_671;
  @ffi.Int8()
  external int _unique_message_item_672;
  @ffi.Int8()
  external int _unique_message_item_673;
  @ffi.Int8()
  external int _unique_message_item_674;
  @ffi.Int8()
  external int _unique_message_item_675;
  @ffi.Int8()
  external int _unique_message_item_676;
  @ffi.Int8()
  external int _unique_message_item_677;
  @ffi.Int8()
  external int _unique_message_item_678;
  @ffi.Int8()
  external int _unique_message_item_679;
  @ffi.Int8()
  external int _unique_message_item_680;
  @ffi.Int8()
  external int _unique_message_item_681;
  @ffi.Int8()
  external int _unique_message_item_682;
  @ffi.Int8()
  external int _unique_message_item_683;
  @ffi.Int8()
  external int _unique_message_item_684;
  @ffi.Int8()
  external int _unique_message_item_685;
  @ffi.Int8()
  external int _unique_message_item_686;
  @ffi.Int8()
  external int _unique_message_item_687;
  @ffi.Int8()
  external int _unique_message_item_688;
  @ffi.Int8()
  external int _unique_message_item_689;
  @ffi.Int8()
  external int _unique_message_item_690;
  @ffi.Int8()
  external int _unique_message_item_691;
  @ffi.Int8()
  external int _unique_message_item_692;
  @ffi.Int8()
  external int _unique_message_item_693;
  @ffi.Int8()
  external int _unique_message_item_694;
  @ffi.Int8()
  external int _unique_message_item_695;
  @ffi.Int8()
  external int _unique_message_item_696;
  @ffi.Int8()
  external int _unique_message_item_697;
  @ffi.Int8()
  external int _unique_message_item_698;
  @ffi.Int8()
  external int _unique_message_item_699;
  @ffi.Int8()
  external int _unique_message_item_700;
  @ffi.Int8()
  external int _unique_message_item_701;
  @ffi.Int8()
  external int _unique_message_item_702;
  @ffi.Int8()
  external int _unique_message_item_703;
  @ffi.Int8()
  external int _unique_message_item_704;
  @ffi.Int8()
  external int _unique_message_item_705;
  @ffi.Int8()
  external int _unique_message_item_706;
  @ffi.Int8()
  external int _unique_message_item_707;
  @ffi.Int8()
  external int _unique_message_item_708;
  @ffi.Int8()
  external int _unique_message_item_709;
  @ffi.Int8()
  external int _unique_message_item_710;
  @ffi.Int8()
  external int _unique_message_item_711;
  @ffi.Int8()
  external int _unique_message_item_712;
  @ffi.Int8()
  external int _unique_message_item_713;
  @ffi.Int8()
  external int _unique_message_item_714;
  @ffi.Int8()
  external int _unique_message_item_715;
  @ffi.Int8()
  external int _unique_message_item_716;
  @ffi.Int8()
  external int _unique_message_item_717;
  @ffi.Int8()
  external int _unique_message_item_718;
  @ffi.Int8()
  external int _unique_message_item_719;
  @ffi.Int8()
  external int _unique_message_item_720;
  @ffi.Int8()
  external int _unique_message_item_721;
  @ffi.Int8()
  external int _unique_message_item_722;
  @ffi.Int8()
  external int _unique_message_item_723;
  @ffi.Int8()
  external int _unique_message_item_724;
  @ffi.Int8()
  external int _unique_message_item_725;
  @ffi.Int8()
  external int _unique_message_item_726;
  @ffi.Int8()
  external int _unique_message_item_727;
  @ffi.Int8()
  external int _unique_message_item_728;
  @ffi.Int8()
  external int _unique_message_item_729;
  @ffi.Int8()
  external int _unique_message_item_730;
  @ffi.Int8()
  external int _unique_message_item_731;
  @ffi.Int8()
  external int _unique_message_item_732;
  @ffi.Int8()
  external int _unique_message_item_733;
  @ffi.Int8()
  external int _unique_message_item_734;
  @ffi.Int8()
  external int _unique_message_item_735;
  @ffi.Int8()
  external int _unique_message_item_736;
  @ffi.Int8()
  external int _unique_message_item_737;
  @ffi.Int8()
  external int _unique_message_item_738;
  @ffi.Int8()
  external int _unique_message_item_739;
  @ffi.Int8()
  external int _unique_message_item_740;
  @ffi.Int8()
  external int _unique_message_item_741;
  @ffi.Int8()
  external int _unique_message_item_742;
  @ffi.Int8()
  external int _unique_message_item_743;
  @ffi.Int8()
  external int _unique_message_item_744;
  @ffi.Int8()
  external int _unique_message_item_745;
  @ffi.Int8()
  external int _unique_message_item_746;
  @ffi.Int8()
  external int _unique_message_item_747;
  @ffi.Int8()
  external int _unique_message_item_748;
  @ffi.Int8()
  external int _unique_message_item_749;
  @ffi.Int8()
  external int _unique_message_item_750;
  @ffi.Int8()
  external int _unique_message_item_751;
  @ffi.Int8()
  external int _unique_message_item_752;
  @ffi.Int8()
  external int _unique_message_item_753;
  @ffi.Int8()
  external int _unique_message_item_754;
  @ffi.Int8()
  external int _unique_message_item_755;
  @ffi.Int8()
  external int _unique_message_item_756;
  @ffi.Int8()
  external int _unique_message_item_757;
  @ffi.Int8()
  external int _unique_message_item_758;
  @ffi.Int8()
  external int _unique_message_item_759;
  @ffi.Int8()
  external int _unique_message_item_760;
  @ffi.Int8()
  external int _unique_message_item_761;
  @ffi.Int8()
  external int _unique_message_item_762;
  @ffi.Int8()
  external int _unique_message_item_763;
  @ffi.Int8()
  external int _unique_message_item_764;
  @ffi.Int8()
  external int _unique_message_item_765;
  @ffi.Int8()
  external int _unique_message_item_766;
  @ffi.Int8()
  external int _unique_message_item_767;

  /// Helper for array `message`.
  ArrayHelper_rcutils_error_state_t_message_level0 get message =>
      ArrayHelper_rcutils_error_state_t_message_level0(this, [768], 0, 0);
  @ffi.Int8()
  external int _unique_file_item_0;
  @ffi.Int8()
  external int _unique_file_item_1;
  @ffi.Int8()
  external int _unique_file_item_2;
  @ffi.Int8()
  external int _unique_file_item_3;
  @ffi.Int8()
  external int _unique_file_item_4;
  @ffi.Int8()
  external int _unique_file_item_5;
  @ffi.Int8()
  external int _unique_file_item_6;
  @ffi.Int8()
  external int _unique_file_item_7;
  @ffi.Int8()
  external int _unique_file_item_8;
  @ffi.Int8()
  external int _unique_file_item_9;
  @ffi.Int8()
  external int _unique_file_item_10;
  @ffi.Int8()
  external int _unique_file_item_11;
  @ffi.Int8()
  external int _unique_file_item_12;
  @ffi.Int8()
  external int _unique_file_item_13;
  @ffi.Int8()
  external int _unique_file_item_14;
  @ffi.Int8()
  external int _unique_file_item_15;
  @ffi.Int8()
  external int _unique_file_item_16;
  @ffi.Int8()
  external int _unique_file_item_17;
  @ffi.Int8()
  external int _unique_file_item_18;
  @ffi.Int8()
  external int _unique_file_item_19;
  @ffi.Int8()
  external int _unique_file_item_20;
  @ffi.Int8()
  external int _unique_file_item_21;
  @ffi.Int8()
  external int _unique_file_item_22;
  @ffi.Int8()
  external int _unique_file_item_23;
  @ffi.Int8()
  external int _unique_file_item_24;
  @ffi.Int8()
  external int _unique_file_item_25;
  @ffi.Int8()
  external int _unique_file_item_26;
  @ffi.Int8()
  external int _unique_file_item_27;
  @ffi.Int8()
  external int _unique_file_item_28;
  @ffi.Int8()
  external int _unique_file_item_29;
  @ffi.Int8()
  external int _unique_file_item_30;
  @ffi.Int8()
  external int _unique_file_item_31;
  @ffi.Int8()
  external int _unique_file_item_32;
  @ffi.Int8()
  external int _unique_file_item_33;
  @ffi.Int8()
  external int _unique_file_item_34;
  @ffi.Int8()
  external int _unique_file_item_35;
  @ffi.Int8()
  external int _unique_file_item_36;
  @ffi.Int8()
  external int _unique_file_item_37;
  @ffi.Int8()
  external int _unique_file_item_38;
  @ffi.Int8()
  external int _unique_file_item_39;
  @ffi.Int8()
  external int _unique_file_item_40;
  @ffi.Int8()
  external int _unique_file_item_41;
  @ffi.Int8()
  external int _unique_file_item_42;
  @ffi.Int8()
  external int _unique_file_item_43;
  @ffi.Int8()
  external int _unique_file_item_44;
  @ffi.Int8()
  external int _unique_file_item_45;
  @ffi.Int8()
  external int _unique_file_item_46;
  @ffi.Int8()
  external int _unique_file_item_47;
  @ffi.Int8()
  external int _unique_file_item_48;
  @ffi.Int8()
  external int _unique_file_item_49;
  @ffi.Int8()
  external int _unique_file_item_50;
  @ffi.Int8()
  external int _unique_file_item_51;
  @ffi.Int8()
  external int _unique_file_item_52;
  @ffi.Int8()
  external int _unique_file_item_53;
  @ffi.Int8()
  external int _unique_file_item_54;
  @ffi.Int8()
  external int _unique_file_item_55;
  @ffi.Int8()
  external int _unique_file_item_56;
  @ffi.Int8()
  external int _unique_file_item_57;
  @ffi.Int8()
  external int _unique_file_item_58;
  @ffi.Int8()
  external int _unique_file_item_59;
  @ffi.Int8()
  external int _unique_file_item_60;
  @ffi.Int8()
  external int _unique_file_item_61;
  @ffi.Int8()
  external int _unique_file_item_62;
  @ffi.Int8()
  external int _unique_file_item_63;
  @ffi.Int8()
  external int _unique_file_item_64;
  @ffi.Int8()
  external int _unique_file_item_65;
  @ffi.Int8()
  external int _unique_file_item_66;
  @ffi.Int8()
  external int _unique_file_item_67;
  @ffi.Int8()
  external int _unique_file_item_68;
  @ffi.Int8()
  external int _unique_file_item_69;
  @ffi.Int8()
  external int _unique_file_item_70;
  @ffi.Int8()
  external int _unique_file_item_71;
  @ffi.Int8()
  external int _unique_file_item_72;
  @ffi.Int8()
  external int _unique_file_item_73;
  @ffi.Int8()
  external int _unique_file_item_74;
  @ffi.Int8()
  external int _unique_file_item_75;
  @ffi.Int8()
  external int _unique_file_item_76;
  @ffi.Int8()
  external int _unique_file_item_77;
  @ffi.Int8()
  external int _unique_file_item_78;
  @ffi.Int8()
  external int _unique_file_item_79;
  @ffi.Int8()
  external int _unique_file_item_80;
  @ffi.Int8()
  external int _unique_file_item_81;
  @ffi.Int8()
  external int _unique_file_item_82;
  @ffi.Int8()
  external int _unique_file_item_83;
  @ffi.Int8()
  external int _unique_file_item_84;
  @ffi.Int8()
  external int _unique_file_item_85;
  @ffi.Int8()
  external int _unique_file_item_86;
  @ffi.Int8()
  external int _unique_file_item_87;
  @ffi.Int8()
  external int _unique_file_item_88;
  @ffi.Int8()
  external int _unique_file_item_89;
  @ffi.Int8()
  external int _unique_file_item_90;
  @ffi.Int8()
  external int _unique_file_item_91;
  @ffi.Int8()
  external int _unique_file_item_92;
  @ffi.Int8()
  external int _unique_file_item_93;
  @ffi.Int8()
  external int _unique_file_item_94;
  @ffi.Int8()
  external int _unique_file_item_95;
  @ffi.Int8()
  external int _unique_file_item_96;
  @ffi.Int8()
  external int _unique_file_item_97;
  @ffi.Int8()
  external int _unique_file_item_98;
  @ffi.Int8()
  external int _unique_file_item_99;
  @ffi.Int8()
  external int _unique_file_item_100;
  @ffi.Int8()
  external int _unique_file_item_101;
  @ffi.Int8()
  external int _unique_file_item_102;
  @ffi.Int8()
  external int _unique_file_item_103;
  @ffi.Int8()
  external int _unique_file_item_104;
  @ffi.Int8()
  external int _unique_file_item_105;
  @ffi.Int8()
  external int _unique_file_item_106;
  @ffi.Int8()
  external int _unique_file_item_107;
  @ffi.Int8()
  external int _unique_file_item_108;
  @ffi.Int8()
  external int _unique_file_item_109;
  @ffi.Int8()
  external int _unique_file_item_110;
  @ffi.Int8()
  external int _unique_file_item_111;
  @ffi.Int8()
  external int _unique_file_item_112;
  @ffi.Int8()
  external int _unique_file_item_113;
  @ffi.Int8()
  external int _unique_file_item_114;
  @ffi.Int8()
  external int _unique_file_item_115;
  @ffi.Int8()
  external int _unique_file_item_116;
  @ffi.Int8()
  external int _unique_file_item_117;
  @ffi.Int8()
  external int _unique_file_item_118;
  @ffi.Int8()
  external int _unique_file_item_119;
  @ffi.Int8()
  external int _unique_file_item_120;
  @ffi.Int8()
  external int _unique_file_item_121;
  @ffi.Int8()
  external int _unique_file_item_122;
  @ffi.Int8()
  external int _unique_file_item_123;
  @ffi.Int8()
  external int _unique_file_item_124;
  @ffi.Int8()
  external int _unique_file_item_125;
  @ffi.Int8()
  external int _unique_file_item_126;
  @ffi.Int8()
  external int _unique_file_item_127;
  @ffi.Int8()
  external int _unique_file_item_128;
  @ffi.Int8()
  external int _unique_file_item_129;
  @ffi.Int8()
  external int _unique_file_item_130;
  @ffi.Int8()
  external int _unique_file_item_131;
  @ffi.Int8()
  external int _unique_file_item_132;
  @ffi.Int8()
  external int _unique_file_item_133;
  @ffi.Int8()
  external int _unique_file_item_134;
  @ffi.Int8()
  external int _unique_file_item_135;
  @ffi.Int8()
  external int _unique_file_item_136;
  @ffi.Int8()
  external int _unique_file_item_137;
  @ffi.Int8()
  external int _unique_file_item_138;
  @ffi.Int8()
  external int _unique_file_item_139;
  @ffi.Int8()
  external int _unique_file_item_140;
  @ffi.Int8()
  external int _unique_file_item_141;
  @ffi.Int8()
  external int _unique_file_item_142;
  @ffi.Int8()
  external int _unique_file_item_143;
  @ffi.Int8()
  external int _unique_file_item_144;
  @ffi.Int8()
  external int _unique_file_item_145;
  @ffi.Int8()
  external int _unique_file_item_146;
  @ffi.Int8()
  external int _unique_file_item_147;
  @ffi.Int8()
  external int _unique_file_item_148;
  @ffi.Int8()
  external int _unique_file_item_149;
  @ffi.Int8()
  external int _unique_file_item_150;
  @ffi.Int8()
  external int _unique_file_item_151;
  @ffi.Int8()
  external int _unique_file_item_152;
  @ffi.Int8()
  external int _unique_file_item_153;
  @ffi.Int8()
  external int _unique_file_item_154;
  @ffi.Int8()
  external int _unique_file_item_155;
  @ffi.Int8()
  external int _unique_file_item_156;
  @ffi.Int8()
  external int _unique_file_item_157;
  @ffi.Int8()
  external int _unique_file_item_158;
  @ffi.Int8()
  external int _unique_file_item_159;
  @ffi.Int8()
  external int _unique_file_item_160;
  @ffi.Int8()
  external int _unique_file_item_161;
  @ffi.Int8()
  external int _unique_file_item_162;
  @ffi.Int8()
  external int _unique_file_item_163;
  @ffi.Int8()
  external int _unique_file_item_164;
  @ffi.Int8()
  external int _unique_file_item_165;
  @ffi.Int8()
  external int _unique_file_item_166;
  @ffi.Int8()
  external int _unique_file_item_167;
  @ffi.Int8()
  external int _unique_file_item_168;
  @ffi.Int8()
  external int _unique_file_item_169;
  @ffi.Int8()
  external int _unique_file_item_170;
  @ffi.Int8()
  external int _unique_file_item_171;
  @ffi.Int8()
  external int _unique_file_item_172;
  @ffi.Int8()
  external int _unique_file_item_173;
  @ffi.Int8()
  external int _unique_file_item_174;
  @ffi.Int8()
  external int _unique_file_item_175;
  @ffi.Int8()
  external int _unique_file_item_176;
  @ffi.Int8()
  external int _unique_file_item_177;
  @ffi.Int8()
  external int _unique_file_item_178;
  @ffi.Int8()
  external int _unique_file_item_179;
  @ffi.Int8()
  external int _unique_file_item_180;
  @ffi.Int8()
  external int _unique_file_item_181;
  @ffi.Int8()
  external int _unique_file_item_182;
  @ffi.Int8()
  external int _unique_file_item_183;
  @ffi.Int8()
  external int _unique_file_item_184;
  @ffi.Int8()
  external int _unique_file_item_185;
  @ffi.Int8()
  external int _unique_file_item_186;
  @ffi.Int8()
  external int _unique_file_item_187;
  @ffi.Int8()
  external int _unique_file_item_188;
  @ffi.Int8()
  external int _unique_file_item_189;
  @ffi.Int8()
  external int _unique_file_item_190;
  @ffi.Int8()
  external int _unique_file_item_191;
  @ffi.Int8()
  external int _unique_file_item_192;
  @ffi.Int8()
  external int _unique_file_item_193;
  @ffi.Int8()
  external int _unique_file_item_194;
  @ffi.Int8()
  external int _unique_file_item_195;
  @ffi.Int8()
  external int _unique_file_item_196;
  @ffi.Int8()
  external int _unique_file_item_197;
  @ffi.Int8()
  external int _unique_file_item_198;
  @ffi.Int8()
  external int _unique_file_item_199;
  @ffi.Int8()
  external int _unique_file_item_200;
  @ffi.Int8()
  external int _unique_file_item_201;
  @ffi.Int8()
  external int _unique_file_item_202;
  @ffi.Int8()
  external int _unique_file_item_203;
  @ffi.Int8()
  external int _unique_file_item_204;
  @ffi.Int8()
  external int _unique_file_item_205;
  @ffi.Int8()
  external int _unique_file_item_206;
  @ffi.Int8()
  external int _unique_file_item_207;
  @ffi.Int8()
  external int _unique_file_item_208;
  @ffi.Int8()
  external int _unique_file_item_209;
  @ffi.Int8()
  external int _unique_file_item_210;
  @ffi.Int8()
  external int _unique_file_item_211;
  @ffi.Int8()
  external int _unique_file_item_212;
  @ffi.Int8()
  external int _unique_file_item_213;
  @ffi.Int8()
  external int _unique_file_item_214;
  @ffi.Int8()
  external int _unique_file_item_215;
  @ffi.Int8()
  external int _unique_file_item_216;
  @ffi.Int8()
  external int _unique_file_item_217;
  @ffi.Int8()
  external int _unique_file_item_218;
  @ffi.Int8()
  external int _unique_file_item_219;
  @ffi.Int8()
  external int _unique_file_item_220;
  @ffi.Int8()
  external int _unique_file_item_221;
  @ffi.Int8()
  external int _unique_file_item_222;
  @ffi.Int8()
  external int _unique_file_item_223;
  @ffi.Int8()
  external int _unique_file_item_224;
  @ffi.Int8()
  external int _unique_file_item_225;
  @ffi.Int8()
  external int _unique_file_item_226;
  @ffi.Int8()
  external int _unique_file_item_227;
  @ffi.Int8()
  external int _unique_file_item_228;

  /// Helper for array `file`.
  ArrayHelper_rcutils_error_state_t_file_level0 get file =>
      ArrayHelper_rcutils_error_state_t_file_level0(this, [229], 0, 0);

  /// /// Line number of error.
  @ffi.Uint64()
  external int line_number;
}

/// Helper for array `message` in struct `rcutils_error_state_t`.
class ArrayHelper_rcutils_error_state_t_message_level0 {
  final rcutils_error_state_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_rcutils_error_state_t_message_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_message_item_0;
      case 1:
        return _struct._unique_message_item_1;
      case 2:
        return _struct._unique_message_item_2;
      case 3:
        return _struct._unique_message_item_3;
      case 4:
        return _struct._unique_message_item_4;
      case 5:
        return _struct._unique_message_item_5;
      case 6:
        return _struct._unique_message_item_6;
      case 7:
        return _struct._unique_message_item_7;
      case 8:
        return _struct._unique_message_item_8;
      case 9:
        return _struct._unique_message_item_9;
      case 10:
        return _struct._unique_message_item_10;
      case 11:
        return _struct._unique_message_item_11;
      case 12:
        return _struct._unique_message_item_12;
      case 13:
        return _struct._unique_message_item_13;
      case 14:
        return _struct._unique_message_item_14;
      case 15:
        return _struct._unique_message_item_15;
      case 16:
        return _struct._unique_message_item_16;
      case 17:
        return _struct._unique_message_item_17;
      case 18:
        return _struct._unique_message_item_18;
      case 19:
        return _struct._unique_message_item_19;
      case 20:
        return _struct._unique_message_item_20;
      case 21:
        return _struct._unique_message_item_21;
      case 22:
        return _struct._unique_message_item_22;
      case 23:
        return _struct._unique_message_item_23;
      case 24:
        return _struct._unique_message_item_24;
      case 25:
        return _struct._unique_message_item_25;
      case 26:
        return _struct._unique_message_item_26;
      case 27:
        return _struct._unique_message_item_27;
      case 28:
        return _struct._unique_message_item_28;
      case 29:
        return _struct._unique_message_item_29;
      case 30:
        return _struct._unique_message_item_30;
      case 31:
        return _struct._unique_message_item_31;
      case 32:
        return _struct._unique_message_item_32;
      case 33:
        return _struct._unique_message_item_33;
      case 34:
        return _struct._unique_message_item_34;
      case 35:
        return _struct._unique_message_item_35;
      case 36:
        return _struct._unique_message_item_36;
      case 37:
        return _struct._unique_message_item_37;
      case 38:
        return _struct._unique_message_item_38;
      case 39:
        return _struct._unique_message_item_39;
      case 40:
        return _struct._unique_message_item_40;
      case 41:
        return _struct._unique_message_item_41;
      case 42:
        return _struct._unique_message_item_42;
      case 43:
        return _struct._unique_message_item_43;
      case 44:
        return _struct._unique_message_item_44;
      case 45:
        return _struct._unique_message_item_45;
      case 46:
        return _struct._unique_message_item_46;
      case 47:
        return _struct._unique_message_item_47;
      case 48:
        return _struct._unique_message_item_48;
      case 49:
        return _struct._unique_message_item_49;
      case 50:
        return _struct._unique_message_item_50;
      case 51:
        return _struct._unique_message_item_51;
      case 52:
        return _struct._unique_message_item_52;
      case 53:
        return _struct._unique_message_item_53;
      case 54:
        return _struct._unique_message_item_54;
      case 55:
        return _struct._unique_message_item_55;
      case 56:
        return _struct._unique_message_item_56;
      case 57:
        return _struct._unique_message_item_57;
      case 58:
        return _struct._unique_message_item_58;
      case 59:
        return _struct._unique_message_item_59;
      case 60:
        return _struct._unique_message_item_60;
      case 61:
        return _struct._unique_message_item_61;
      case 62:
        return _struct._unique_message_item_62;
      case 63:
        return _struct._unique_message_item_63;
      case 64:
        return _struct._unique_message_item_64;
      case 65:
        return _struct._unique_message_item_65;
      case 66:
        return _struct._unique_message_item_66;
      case 67:
        return _struct._unique_message_item_67;
      case 68:
        return _struct._unique_message_item_68;
      case 69:
        return _struct._unique_message_item_69;
      case 70:
        return _struct._unique_message_item_70;
      case 71:
        return _struct._unique_message_item_71;
      case 72:
        return _struct._unique_message_item_72;
      case 73:
        return _struct._unique_message_item_73;
      case 74:
        return _struct._unique_message_item_74;
      case 75:
        return _struct._unique_message_item_75;
      case 76:
        return _struct._unique_message_item_76;
      case 77:
        return _struct._unique_message_item_77;
      case 78:
        return _struct._unique_message_item_78;
      case 79:
        return _struct._unique_message_item_79;
      case 80:
        return _struct._unique_message_item_80;
      case 81:
        return _struct._unique_message_item_81;
      case 82:
        return _struct._unique_message_item_82;
      case 83:
        return _struct._unique_message_item_83;
      case 84:
        return _struct._unique_message_item_84;
      case 85:
        return _struct._unique_message_item_85;
      case 86:
        return _struct._unique_message_item_86;
      case 87:
        return _struct._unique_message_item_87;
      case 88:
        return _struct._unique_message_item_88;
      case 89:
        return _struct._unique_message_item_89;
      case 90:
        return _struct._unique_message_item_90;
      case 91:
        return _struct._unique_message_item_91;
      case 92:
        return _struct._unique_message_item_92;
      case 93:
        return _struct._unique_message_item_93;
      case 94:
        return _struct._unique_message_item_94;
      case 95:
        return _struct._unique_message_item_95;
      case 96:
        return _struct._unique_message_item_96;
      case 97:
        return _struct._unique_message_item_97;
      case 98:
        return _struct._unique_message_item_98;
      case 99:
        return _struct._unique_message_item_99;
      case 100:
        return _struct._unique_message_item_100;
      case 101:
        return _struct._unique_message_item_101;
      case 102:
        return _struct._unique_message_item_102;
      case 103:
        return _struct._unique_message_item_103;
      case 104:
        return _struct._unique_message_item_104;
      case 105:
        return _struct._unique_message_item_105;
      case 106:
        return _struct._unique_message_item_106;
      case 107:
        return _struct._unique_message_item_107;
      case 108:
        return _struct._unique_message_item_108;
      case 109:
        return _struct._unique_message_item_109;
      case 110:
        return _struct._unique_message_item_110;
      case 111:
        return _struct._unique_message_item_111;
      case 112:
        return _struct._unique_message_item_112;
      case 113:
        return _struct._unique_message_item_113;
      case 114:
        return _struct._unique_message_item_114;
      case 115:
        return _struct._unique_message_item_115;
      case 116:
        return _struct._unique_message_item_116;
      case 117:
        return _struct._unique_message_item_117;
      case 118:
        return _struct._unique_message_item_118;
      case 119:
        return _struct._unique_message_item_119;
      case 120:
        return _struct._unique_message_item_120;
      case 121:
        return _struct._unique_message_item_121;
      case 122:
        return _struct._unique_message_item_122;
      case 123:
        return _struct._unique_message_item_123;
      case 124:
        return _struct._unique_message_item_124;
      case 125:
        return _struct._unique_message_item_125;
      case 126:
        return _struct._unique_message_item_126;
      case 127:
        return _struct._unique_message_item_127;
      case 128:
        return _struct._unique_message_item_128;
      case 129:
        return _struct._unique_message_item_129;
      case 130:
        return _struct._unique_message_item_130;
      case 131:
        return _struct._unique_message_item_131;
      case 132:
        return _struct._unique_message_item_132;
      case 133:
        return _struct._unique_message_item_133;
      case 134:
        return _struct._unique_message_item_134;
      case 135:
        return _struct._unique_message_item_135;
      case 136:
        return _struct._unique_message_item_136;
      case 137:
        return _struct._unique_message_item_137;
      case 138:
        return _struct._unique_message_item_138;
      case 139:
        return _struct._unique_message_item_139;
      case 140:
        return _struct._unique_message_item_140;
      case 141:
        return _struct._unique_message_item_141;
      case 142:
        return _struct._unique_message_item_142;
      case 143:
        return _struct._unique_message_item_143;
      case 144:
        return _struct._unique_message_item_144;
      case 145:
        return _struct._unique_message_item_145;
      case 146:
        return _struct._unique_message_item_146;
      case 147:
        return _struct._unique_message_item_147;
      case 148:
        return _struct._unique_message_item_148;
      case 149:
        return _struct._unique_message_item_149;
      case 150:
        return _struct._unique_message_item_150;
      case 151:
        return _struct._unique_message_item_151;
      case 152:
        return _struct._unique_message_item_152;
      case 153:
        return _struct._unique_message_item_153;
      case 154:
        return _struct._unique_message_item_154;
      case 155:
        return _struct._unique_message_item_155;
      case 156:
        return _struct._unique_message_item_156;
      case 157:
        return _struct._unique_message_item_157;
      case 158:
        return _struct._unique_message_item_158;
      case 159:
        return _struct._unique_message_item_159;
      case 160:
        return _struct._unique_message_item_160;
      case 161:
        return _struct._unique_message_item_161;
      case 162:
        return _struct._unique_message_item_162;
      case 163:
        return _struct._unique_message_item_163;
      case 164:
        return _struct._unique_message_item_164;
      case 165:
        return _struct._unique_message_item_165;
      case 166:
        return _struct._unique_message_item_166;
      case 167:
        return _struct._unique_message_item_167;
      case 168:
        return _struct._unique_message_item_168;
      case 169:
        return _struct._unique_message_item_169;
      case 170:
        return _struct._unique_message_item_170;
      case 171:
        return _struct._unique_message_item_171;
      case 172:
        return _struct._unique_message_item_172;
      case 173:
        return _struct._unique_message_item_173;
      case 174:
        return _struct._unique_message_item_174;
      case 175:
        return _struct._unique_message_item_175;
      case 176:
        return _struct._unique_message_item_176;
      case 177:
        return _struct._unique_message_item_177;
      case 178:
        return _struct._unique_message_item_178;
      case 179:
        return _struct._unique_message_item_179;
      case 180:
        return _struct._unique_message_item_180;
      case 181:
        return _struct._unique_message_item_181;
      case 182:
        return _struct._unique_message_item_182;
      case 183:
        return _struct._unique_message_item_183;
      case 184:
        return _struct._unique_message_item_184;
      case 185:
        return _struct._unique_message_item_185;
      case 186:
        return _struct._unique_message_item_186;
      case 187:
        return _struct._unique_message_item_187;
      case 188:
        return _struct._unique_message_item_188;
      case 189:
        return _struct._unique_message_item_189;
      case 190:
        return _struct._unique_message_item_190;
      case 191:
        return _struct._unique_message_item_191;
      case 192:
        return _struct._unique_message_item_192;
      case 193:
        return _struct._unique_message_item_193;
      case 194:
        return _struct._unique_message_item_194;
      case 195:
        return _struct._unique_message_item_195;
      case 196:
        return _struct._unique_message_item_196;
      case 197:
        return _struct._unique_message_item_197;
      case 198:
        return _struct._unique_message_item_198;
      case 199:
        return _struct._unique_message_item_199;
      case 200:
        return _struct._unique_message_item_200;
      case 201:
        return _struct._unique_message_item_201;
      case 202:
        return _struct._unique_message_item_202;
      case 203:
        return _struct._unique_message_item_203;
      case 204:
        return _struct._unique_message_item_204;
      case 205:
        return _struct._unique_message_item_205;
      case 206:
        return _struct._unique_message_item_206;
      case 207:
        return _struct._unique_message_item_207;
      case 208:
        return _struct._unique_message_item_208;
      case 209:
        return _struct._unique_message_item_209;
      case 210:
        return _struct._unique_message_item_210;
      case 211:
        return _struct._unique_message_item_211;
      case 212:
        return _struct._unique_message_item_212;
      case 213:
        return _struct._unique_message_item_213;
      case 214:
        return _struct._unique_message_item_214;
      case 215:
        return _struct._unique_message_item_215;
      case 216:
        return _struct._unique_message_item_216;
      case 217:
        return _struct._unique_message_item_217;
      case 218:
        return _struct._unique_message_item_218;
      case 219:
        return _struct._unique_message_item_219;
      case 220:
        return _struct._unique_message_item_220;
      case 221:
        return _struct._unique_message_item_221;
      case 222:
        return _struct._unique_message_item_222;
      case 223:
        return _struct._unique_message_item_223;
      case 224:
        return _struct._unique_message_item_224;
      case 225:
        return _struct._unique_message_item_225;
      case 226:
        return _struct._unique_message_item_226;
      case 227:
        return _struct._unique_message_item_227;
      case 228:
        return _struct._unique_message_item_228;
      case 229:
        return _struct._unique_message_item_229;
      case 230:
        return _struct._unique_message_item_230;
      case 231:
        return _struct._unique_message_item_231;
      case 232:
        return _struct._unique_message_item_232;
      case 233:
        return _struct._unique_message_item_233;
      case 234:
        return _struct._unique_message_item_234;
      case 235:
        return _struct._unique_message_item_235;
      case 236:
        return _struct._unique_message_item_236;
      case 237:
        return _struct._unique_message_item_237;
      case 238:
        return _struct._unique_message_item_238;
      case 239:
        return _struct._unique_message_item_239;
      case 240:
        return _struct._unique_message_item_240;
      case 241:
        return _struct._unique_message_item_241;
      case 242:
        return _struct._unique_message_item_242;
      case 243:
        return _struct._unique_message_item_243;
      case 244:
        return _struct._unique_message_item_244;
      case 245:
        return _struct._unique_message_item_245;
      case 246:
        return _struct._unique_message_item_246;
      case 247:
        return _struct._unique_message_item_247;
      case 248:
        return _struct._unique_message_item_248;
      case 249:
        return _struct._unique_message_item_249;
      case 250:
        return _struct._unique_message_item_250;
      case 251:
        return _struct._unique_message_item_251;
      case 252:
        return _struct._unique_message_item_252;
      case 253:
        return _struct._unique_message_item_253;
      case 254:
        return _struct._unique_message_item_254;
      case 255:
        return _struct._unique_message_item_255;
      case 256:
        return _struct._unique_message_item_256;
      case 257:
        return _struct._unique_message_item_257;
      case 258:
        return _struct._unique_message_item_258;
      case 259:
        return _struct._unique_message_item_259;
      case 260:
        return _struct._unique_message_item_260;
      case 261:
        return _struct._unique_message_item_261;
      case 262:
        return _struct._unique_message_item_262;
      case 263:
        return _struct._unique_message_item_263;
      case 264:
        return _struct._unique_message_item_264;
      case 265:
        return _struct._unique_message_item_265;
      case 266:
        return _struct._unique_message_item_266;
      case 267:
        return _struct._unique_message_item_267;
      case 268:
        return _struct._unique_message_item_268;
      case 269:
        return _struct._unique_message_item_269;
      case 270:
        return _struct._unique_message_item_270;
      case 271:
        return _struct._unique_message_item_271;
      case 272:
        return _struct._unique_message_item_272;
      case 273:
        return _struct._unique_message_item_273;
      case 274:
        return _struct._unique_message_item_274;
      case 275:
        return _struct._unique_message_item_275;
      case 276:
        return _struct._unique_message_item_276;
      case 277:
        return _struct._unique_message_item_277;
      case 278:
        return _struct._unique_message_item_278;
      case 279:
        return _struct._unique_message_item_279;
      case 280:
        return _struct._unique_message_item_280;
      case 281:
        return _struct._unique_message_item_281;
      case 282:
        return _struct._unique_message_item_282;
      case 283:
        return _struct._unique_message_item_283;
      case 284:
        return _struct._unique_message_item_284;
      case 285:
        return _struct._unique_message_item_285;
      case 286:
        return _struct._unique_message_item_286;
      case 287:
        return _struct._unique_message_item_287;
      case 288:
        return _struct._unique_message_item_288;
      case 289:
        return _struct._unique_message_item_289;
      case 290:
        return _struct._unique_message_item_290;
      case 291:
        return _struct._unique_message_item_291;
      case 292:
        return _struct._unique_message_item_292;
      case 293:
        return _struct._unique_message_item_293;
      case 294:
        return _struct._unique_message_item_294;
      case 295:
        return _struct._unique_message_item_295;
      case 296:
        return _struct._unique_message_item_296;
      case 297:
        return _struct._unique_message_item_297;
      case 298:
        return _struct._unique_message_item_298;
      case 299:
        return _struct._unique_message_item_299;
      case 300:
        return _struct._unique_message_item_300;
      case 301:
        return _struct._unique_message_item_301;
      case 302:
        return _struct._unique_message_item_302;
      case 303:
        return _struct._unique_message_item_303;
      case 304:
        return _struct._unique_message_item_304;
      case 305:
        return _struct._unique_message_item_305;
      case 306:
        return _struct._unique_message_item_306;
      case 307:
        return _struct._unique_message_item_307;
      case 308:
        return _struct._unique_message_item_308;
      case 309:
        return _struct._unique_message_item_309;
      case 310:
        return _struct._unique_message_item_310;
      case 311:
        return _struct._unique_message_item_311;
      case 312:
        return _struct._unique_message_item_312;
      case 313:
        return _struct._unique_message_item_313;
      case 314:
        return _struct._unique_message_item_314;
      case 315:
        return _struct._unique_message_item_315;
      case 316:
        return _struct._unique_message_item_316;
      case 317:
        return _struct._unique_message_item_317;
      case 318:
        return _struct._unique_message_item_318;
      case 319:
        return _struct._unique_message_item_319;
      case 320:
        return _struct._unique_message_item_320;
      case 321:
        return _struct._unique_message_item_321;
      case 322:
        return _struct._unique_message_item_322;
      case 323:
        return _struct._unique_message_item_323;
      case 324:
        return _struct._unique_message_item_324;
      case 325:
        return _struct._unique_message_item_325;
      case 326:
        return _struct._unique_message_item_326;
      case 327:
        return _struct._unique_message_item_327;
      case 328:
        return _struct._unique_message_item_328;
      case 329:
        return _struct._unique_message_item_329;
      case 330:
        return _struct._unique_message_item_330;
      case 331:
        return _struct._unique_message_item_331;
      case 332:
        return _struct._unique_message_item_332;
      case 333:
        return _struct._unique_message_item_333;
      case 334:
        return _struct._unique_message_item_334;
      case 335:
        return _struct._unique_message_item_335;
      case 336:
        return _struct._unique_message_item_336;
      case 337:
        return _struct._unique_message_item_337;
      case 338:
        return _struct._unique_message_item_338;
      case 339:
        return _struct._unique_message_item_339;
      case 340:
        return _struct._unique_message_item_340;
      case 341:
        return _struct._unique_message_item_341;
      case 342:
        return _struct._unique_message_item_342;
      case 343:
        return _struct._unique_message_item_343;
      case 344:
        return _struct._unique_message_item_344;
      case 345:
        return _struct._unique_message_item_345;
      case 346:
        return _struct._unique_message_item_346;
      case 347:
        return _struct._unique_message_item_347;
      case 348:
        return _struct._unique_message_item_348;
      case 349:
        return _struct._unique_message_item_349;
      case 350:
        return _struct._unique_message_item_350;
      case 351:
        return _struct._unique_message_item_351;
      case 352:
        return _struct._unique_message_item_352;
      case 353:
        return _struct._unique_message_item_353;
      case 354:
        return _struct._unique_message_item_354;
      case 355:
        return _struct._unique_message_item_355;
      case 356:
        return _struct._unique_message_item_356;
      case 357:
        return _struct._unique_message_item_357;
      case 358:
        return _struct._unique_message_item_358;
      case 359:
        return _struct._unique_message_item_359;
      case 360:
        return _struct._unique_message_item_360;
      case 361:
        return _struct._unique_message_item_361;
      case 362:
        return _struct._unique_message_item_362;
      case 363:
        return _struct._unique_message_item_363;
      case 364:
        return _struct._unique_message_item_364;
      case 365:
        return _struct._unique_message_item_365;
      case 366:
        return _struct._unique_message_item_366;
      case 367:
        return _struct._unique_message_item_367;
      case 368:
        return _struct._unique_message_item_368;
      case 369:
        return _struct._unique_message_item_369;
      case 370:
        return _struct._unique_message_item_370;
      case 371:
        return _struct._unique_message_item_371;
      case 372:
        return _struct._unique_message_item_372;
      case 373:
        return _struct._unique_message_item_373;
      case 374:
        return _struct._unique_message_item_374;
      case 375:
        return _struct._unique_message_item_375;
      case 376:
        return _struct._unique_message_item_376;
      case 377:
        return _struct._unique_message_item_377;
      case 378:
        return _struct._unique_message_item_378;
      case 379:
        return _struct._unique_message_item_379;
      case 380:
        return _struct._unique_message_item_380;
      case 381:
        return _struct._unique_message_item_381;
      case 382:
        return _struct._unique_message_item_382;
      case 383:
        return _struct._unique_message_item_383;
      case 384:
        return _struct._unique_message_item_384;
      case 385:
        return _struct._unique_message_item_385;
      case 386:
        return _struct._unique_message_item_386;
      case 387:
        return _struct._unique_message_item_387;
      case 388:
        return _struct._unique_message_item_388;
      case 389:
        return _struct._unique_message_item_389;
      case 390:
        return _struct._unique_message_item_390;
      case 391:
        return _struct._unique_message_item_391;
      case 392:
        return _struct._unique_message_item_392;
      case 393:
        return _struct._unique_message_item_393;
      case 394:
        return _struct._unique_message_item_394;
      case 395:
        return _struct._unique_message_item_395;
      case 396:
        return _struct._unique_message_item_396;
      case 397:
        return _struct._unique_message_item_397;
      case 398:
        return _struct._unique_message_item_398;
      case 399:
        return _struct._unique_message_item_399;
      case 400:
        return _struct._unique_message_item_400;
      case 401:
        return _struct._unique_message_item_401;
      case 402:
        return _struct._unique_message_item_402;
      case 403:
        return _struct._unique_message_item_403;
      case 404:
        return _struct._unique_message_item_404;
      case 405:
        return _struct._unique_message_item_405;
      case 406:
        return _struct._unique_message_item_406;
      case 407:
        return _struct._unique_message_item_407;
      case 408:
        return _struct._unique_message_item_408;
      case 409:
        return _struct._unique_message_item_409;
      case 410:
        return _struct._unique_message_item_410;
      case 411:
        return _struct._unique_message_item_411;
      case 412:
        return _struct._unique_message_item_412;
      case 413:
        return _struct._unique_message_item_413;
      case 414:
        return _struct._unique_message_item_414;
      case 415:
        return _struct._unique_message_item_415;
      case 416:
        return _struct._unique_message_item_416;
      case 417:
        return _struct._unique_message_item_417;
      case 418:
        return _struct._unique_message_item_418;
      case 419:
        return _struct._unique_message_item_419;
      case 420:
        return _struct._unique_message_item_420;
      case 421:
        return _struct._unique_message_item_421;
      case 422:
        return _struct._unique_message_item_422;
      case 423:
        return _struct._unique_message_item_423;
      case 424:
        return _struct._unique_message_item_424;
      case 425:
        return _struct._unique_message_item_425;
      case 426:
        return _struct._unique_message_item_426;
      case 427:
        return _struct._unique_message_item_427;
      case 428:
        return _struct._unique_message_item_428;
      case 429:
        return _struct._unique_message_item_429;
      case 430:
        return _struct._unique_message_item_430;
      case 431:
        return _struct._unique_message_item_431;
      case 432:
        return _struct._unique_message_item_432;
      case 433:
        return _struct._unique_message_item_433;
      case 434:
        return _struct._unique_message_item_434;
      case 435:
        return _struct._unique_message_item_435;
      case 436:
        return _struct._unique_message_item_436;
      case 437:
        return _struct._unique_message_item_437;
      case 438:
        return _struct._unique_message_item_438;
      case 439:
        return _struct._unique_message_item_439;
      case 440:
        return _struct._unique_message_item_440;
      case 441:
        return _struct._unique_message_item_441;
      case 442:
        return _struct._unique_message_item_442;
      case 443:
        return _struct._unique_message_item_443;
      case 444:
        return _struct._unique_message_item_444;
      case 445:
        return _struct._unique_message_item_445;
      case 446:
        return _struct._unique_message_item_446;
      case 447:
        return _struct._unique_message_item_447;
      case 448:
        return _struct._unique_message_item_448;
      case 449:
        return _struct._unique_message_item_449;
      case 450:
        return _struct._unique_message_item_450;
      case 451:
        return _struct._unique_message_item_451;
      case 452:
        return _struct._unique_message_item_452;
      case 453:
        return _struct._unique_message_item_453;
      case 454:
        return _struct._unique_message_item_454;
      case 455:
        return _struct._unique_message_item_455;
      case 456:
        return _struct._unique_message_item_456;
      case 457:
        return _struct._unique_message_item_457;
      case 458:
        return _struct._unique_message_item_458;
      case 459:
        return _struct._unique_message_item_459;
      case 460:
        return _struct._unique_message_item_460;
      case 461:
        return _struct._unique_message_item_461;
      case 462:
        return _struct._unique_message_item_462;
      case 463:
        return _struct._unique_message_item_463;
      case 464:
        return _struct._unique_message_item_464;
      case 465:
        return _struct._unique_message_item_465;
      case 466:
        return _struct._unique_message_item_466;
      case 467:
        return _struct._unique_message_item_467;
      case 468:
        return _struct._unique_message_item_468;
      case 469:
        return _struct._unique_message_item_469;
      case 470:
        return _struct._unique_message_item_470;
      case 471:
        return _struct._unique_message_item_471;
      case 472:
        return _struct._unique_message_item_472;
      case 473:
        return _struct._unique_message_item_473;
      case 474:
        return _struct._unique_message_item_474;
      case 475:
        return _struct._unique_message_item_475;
      case 476:
        return _struct._unique_message_item_476;
      case 477:
        return _struct._unique_message_item_477;
      case 478:
        return _struct._unique_message_item_478;
      case 479:
        return _struct._unique_message_item_479;
      case 480:
        return _struct._unique_message_item_480;
      case 481:
        return _struct._unique_message_item_481;
      case 482:
        return _struct._unique_message_item_482;
      case 483:
        return _struct._unique_message_item_483;
      case 484:
        return _struct._unique_message_item_484;
      case 485:
        return _struct._unique_message_item_485;
      case 486:
        return _struct._unique_message_item_486;
      case 487:
        return _struct._unique_message_item_487;
      case 488:
        return _struct._unique_message_item_488;
      case 489:
        return _struct._unique_message_item_489;
      case 490:
        return _struct._unique_message_item_490;
      case 491:
        return _struct._unique_message_item_491;
      case 492:
        return _struct._unique_message_item_492;
      case 493:
        return _struct._unique_message_item_493;
      case 494:
        return _struct._unique_message_item_494;
      case 495:
        return _struct._unique_message_item_495;
      case 496:
        return _struct._unique_message_item_496;
      case 497:
        return _struct._unique_message_item_497;
      case 498:
        return _struct._unique_message_item_498;
      case 499:
        return _struct._unique_message_item_499;
      case 500:
        return _struct._unique_message_item_500;
      case 501:
        return _struct._unique_message_item_501;
      case 502:
        return _struct._unique_message_item_502;
      case 503:
        return _struct._unique_message_item_503;
      case 504:
        return _struct._unique_message_item_504;
      case 505:
        return _struct._unique_message_item_505;
      case 506:
        return _struct._unique_message_item_506;
      case 507:
        return _struct._unique_message_item_507;
      case 508:
        return _struct._unique_message_item_508;
      case 509:
        return _struct._unique_message_item_509;
      case 510:
        return _struct._unique_message_item_510;
      case 511:
        return _struct._unique_message_item_511;
      case 512:
        return _struct._unique_message_item_512;
      case 513:
        return _struct._unique_message_item_513;
      case 514:
        return _struct._unique_message_item_514;
      case 515:
        return _struct._unique_message_item_515;
      case 516:
        return _struct._unique_message_item_516;
      case 517:
        return _struct._unique_message_item_517;
      case 518:
        return _struct._unique_message_item_518;
      case 519:
        return _struct._unique_message_item_519;
      case 520:
        return _struct._unique_message_item_520;
      case 521:
        return _struct._unique_message_item_521;
      case 522:
        return _struct._unique_message_item_522;
      case 523:
        return _struct._unique_message_item_523;
      case 524:
        return _struct._unique_message_item_524;
      case 525:
        return _struct._unique_message_item_525;
      case 526:
        return _struct._unique_message_item_526;
      case 527:
        return _struct._unique_message_item_527;
      case 528:
        return _struct._unique_message_item_528;
      case 529:
        return _struct._unique_message_item_529;
      case 530:
        return _struct._unique_message_item_530;
      case 531:
        return _struct._unique_message_item_531;
      case 532:
        return _struct._unique_message_item_532;
      case 533:
        return _struct._unique_message_item_533;
      case 534:
        return _struct._unique_message_item_534;
      case 535:
        return _struct._unique_message_item_535;
      case 536:
        return _struct._unique_message_item_536;
      case 537:
        return _struct._unique_message_item_537;
      case 538:
        return _struct._unique_message_item_538;
      case 539:
        return _struct._unique_message_item_539;
      case 540:
        return _struct._unique_message_item_540;
      case 541:
        return _struct._unique_message_item_541;
      case 542:
        return _struct._unique_message_item_542;
      case 543:
        return _struct._unique_message_item_543;
      case 544:
        return _struct._unique_message_item_544;
      case 545:
        return _struct._unique_message_item_545;
      case 546:
        return _struct._unique_message_item_546;
      case 547:
        return _struct._unique_message_item_547;
      case 548:
        return _struct._unique_message_item_548;
      case 549:
        return _struct._unique_message_item_549;
      case 550:
        return _struct._unique_message_item_550;
      case 551:
        return _struct._unique_message_item_551;
      case 552:
        return _struct._unique_message_item_552;
      case 553:
        return _struct._unique_message_item_553;
      case 554:
        return _struct._unique_message_item_554;
      case 555:
        return _struct._unique_message_item_555;
      case 556:
        return _struct._unique_message_item_556;
      case 557:
        return _struct._unique_message_item_557;
      case 558:
        return _struct._unique_message_item_558;
      case 559:
        return _struct._unique_message_item_559;
      case 560:
        return _struct._unique_message_item_560;
      case 561:
        return _struct._unique_message_item_561;
      case 562:
        return _struct._unique_message_item_562;
      case 563:
        return _struct._unique_message_item_563;
      case 564:
        return _struct._unique_message_item_564;
      case 565:
        return _struct._unique_message_item_565;
      case 566:
        return _struct._unique_message_item_566;
      case 567:
        return _struct._unique_message_item_567;
      case 568:
        return _struct._unique_message_item_568;
      case 569:
        return _struct._unique_message_item_569;
      case 570:
        return _struct._unique_message_item_570;
      case 571:
        return _struct._unique_message_item_571;
      case 572:
        return _struct._unique_message_item_572;
      case 573:
        return _struct._unique_message_item_573;
      case 574:
        return _struct._unique_message_item_574;
      case 575:
        return _struct._unique_message_item_575;
      case 576:
        return _struct._unique_message_item_576;
      case 577:
        return _struct._unique_message_item_577;
      case 578:
        return _struct._unique_message_item_578;
      case 579:
        return _struct._unique_message_item_579;
      case 580:
        return _struct._unique_message_item_580;
      case 581:
        return _struct._unique_message_item_581;
      case 582:
        return _struct._unique_message_item_582;
      case 583:
        return _struct._unique_message_item_583;
      case 584:
        return _struct._unique_message_item_584;
      case 585:
        return _struct._unique_message_item_585;
      case 586:
        return _struct._unique_message_item_586;
      case 587:
        return _struct._unique_message_item_587;
      case 588:
        return _struct._unique_message_item_588;
      case 589:
        return _struct._unique_message_item_589;
      case 590:
        return _struct._unique_message_item_590;
      case 591:
        return _struct._unique_message_item_591;
      case 592:
        return _struct._unique_message_item_592;
      case 593:
        return _struct._unique_message_item_593;
      case 594:
        return _struct._unique_message_item_594;
      case 595:
        return _struct._unique_message_item_595;
      case 596:
        return _struct._unique_message_item_596;
      case 597:
        return _struct._unique_message_item_597;
      case 598:
        return _struct._unique_message_item_598;
      case 599:
        return _struct._unique_message_item_599;
      case 600:
        return _struct._unique_message_item_600;
      case 601:
        return _struct._unique_message_item_601;
      case 602:
        return _struct._unique_message_item_602;
      case 603:
        return _struct._unique_message_item_603;
      case 604:
        return _struct._unique_message_item_604;
      case 605:
        return _struct._unique_message_item_605;
      case 606:
        return _struct._unique_message_item_606;
      case 607:
        return _struct._unique_message_item_607;
      case 608:
        return _struct._unique_message_item_608;
      case 609:
        return _struct._unique_message_item_609;
      case 610:
        return _struct._unique_message_item_610;
      case 611:
        return _struct._unique_message_item_611;
      case 612:
        return _struct._unique_message_item_612;
      case 613:
        return _struct._unique_message_item_613;
      case 614:
        return _struct._unique_message_item_614;
      case 615:
        return _struct._unique_message_item_615;
      case 616:
        return _struct._unique_message_item_616;
      case 617:
        return _struct._unique_message_item_617;
      case 618:
        return _struct._unique_message_item_618;
      case 619:
        return _struct._unique_message_item_619;
      case 620:
        return _struct._unique_message_item_620;
      case 621:
        return _struct._unique_message_item_621;
      case 622:
        return _struct._unique_message_item_622;
      case 623:
        return _struct._unique_message_item_623;
      case 624:
        return _struct._unique_message_item_624;
      case 625:
        return _struct._unique_message_item_625;
      case 626:
        return _struct._unique_message_item_626;
      case 627:
        return _struct._unique_message_item_627;
      case 628:
        return _struct._unique_message_item_628;
      case 629:
        return _struct._unique_message_item_629;
      case 630:
        return _struct._unique_message_item_630;
      case 631:
        return _struct._unique_message_item_631;
      case 632:
        return _struct._unique_message_item_632;
      case 633:
        return _struct._unique_message_item_633;
      case 634:
        return _struct._unique_message_item_634;
      case 635:
        return _struct._unique_message_item_635;
      case 636:
        return _struct._unique_message_item_636;
      case 637:
        return _struct._unique_message_item_637;
      case 638:
        return _struct._unique_message_item_638;
      case 639:
        return _struct._unique_message_item_639;
      case 640:
        return _struct._unique_message_item_640;
      case 641:
        return _struct._unique_message_item_641;
      case 642:
        return _struct._unique_message_item_642;
      case 643:
        return _struct._unique_message_item_643;
      case 644:
        return _struct._unique_message_item_644;
      case 645:
        return _struct._unique_message_item_645;
      case 646:
        return _struct._unique_message_item_646;
      case 647:
        return _struct._unique_message_item_647;
      case 648:
        return _struct._unique_message_item_648;
      case 649:
        return _struct._unique_message_item_649;
      case 650:
        return _struct._unique_message_item_650;
      case 651:
        return _struct._unique_message_item_651;
      case 652:
        return _struct._unique_message_item_652;
      case 653:
        return _struct._unique_message_item_653;
      case 654:
        return _struct._unique_message_item_654;
      case 655:
        return _struct._unique_message_item_655;
      case 656:
        return _struct._unique_message_item_656;
      case 657:
        return _struct._unique_message_item_657;
      case 658:
        return _struct._unique_message_item_658;
      case 659:
        return _struct._unique_message_item_659;
      case 660:
        return _struct._unique_message_item_660;
      case 661:
        return _struct._unique_message_item_661;
      case 662:
        return _struct._unique_message_item_662;
      case 663:
        return _struct._unique_message_item_663;
      case 664:
        return _struct._unique_message_item_664;
      case 665:
        return _struct._unique_message_item_665;
      case 666:
        return _struct._unique_message_item_666;
      case 667:
        return _struct._unique_message_item_667;
      case 668:
        return _struct._unique_message_item_668;
      case 669:
        return _struct._unique_message_item_669;
      case 670:
        return _struct._unique_message_item_670;
      case 671:
        return _struct._unique_message_item_671;
      case 672:
        return _struct._unique_message_item_672;
      case 673:
        return _struct._unique_message_item_673;
      case 674:
        return _struct._unique_message_item_674;
      case 675:
        return _struct._unique_message_item_675;
      case 676:
        return _struct._unique_message_item_676;
      case 677:
        return _struct._unique_message_item_677;
      case 678:
        return _struct._unique_message_item_678;
      case 679:
        return _struct._unique_message_item_679;
      case 680:
        return _struct._unique_message_item_680;
      case 681:
        return _struct._unique_message_item_681;
      case 682:
        return _struct._unique_message_item_682;
      case 683:
        return _struct._unique_message_item_683;
      case 684:
        return _struct._unique_message_item_684;
      case 685:
        return _struct._unique_message_item_685;
      case 686:
        return _struct._unique_message_item_686;
      case 687:
        return _struct._unique_message_item_687;
      case 688:
        return _struct._unique_message_item_688;
      case 689:
        return _struct._unique_message_item_689;
      case 690:
        return _struct._unique_message_item_690;
      case 691:
        return _struct._unique_message_item_691;
      case 692:
        return _struct._unique_message_item_692;
      case 693:
        return _struct._unique_message_item_693;
      case 694:
        return _struct._unique_message_item_694;
      case 695:
        return _struct._unique_message_item_695;
      case 696:
        return _struct._unique_message_item_696;
      case 697:
        return _struct._unique_message_item_697;
      case 698:
        return _struct._unique_message_item_698;
      case 699:
        return _struct._unique_message_item_699;
      case 700:
        return _struct._unique_message_item_700;
      case 701:
        return _struct._unique_message_item_701;
      case 702:
        return _struct._unique_message_item_702;
      case 703:
        return _struct._unique_message_item_703;
      case 704:
        return _struct._unique_message_item_704;
      case 705:
        return _struct._unique_message_item_705;
      case 706:
        return _struct._unique_message_item_706;
      case 707:
        return _struct._unique_message_item_707;
      case 708:
        return _struct._unique_message_item_708;
      case 709:
        return _struct._unique_message_item_709;
      case 710:
        return _struct._unique_message_item_710;
      case 711:
        return _struct._unique_message_item_711;
      case 712:
        return _struct._unique_message_item_712;
      case 713:
        return _struct._unique_message_item_713;
      case 714:
        return _struct._unique_message_item_714;
      case 715:
        return _struct._unique_message_item_715;
      case 716:
        return _struct._unique_message_item_716;
      case 717:
        return _struct._unique_message_item_717;
      case 718:
        return _struct._unique_message_item_718;
      case 719:
        return _struct._unique_message_item_719;
      case 720:
        return _struct._unique_message_item_720;
      case 721:
        return _struct._unique_message_item_721;
      case 722:
        return _struct._unique_message_item_722;
      case 723:
        return _struct._unique_message_item_723;
      case 724:
        return _struct._unique_message_item_724;
      case 725:
        return _struct._unique_message_item_725;
      case 726:
        return _struct._unique_message_item_726;
      case 727:
        return _struct._unique_message_item_727;
      case 728:
        return _struct._unique_message_item_728;
      case 729:
        return _struct._unique_message_item_729;
      case 730:
        return _struct._unique_message_item_730;
      case 731:
        return _struct._unique_message_item_731;
      case 732:
        return _struct._unique_message_item_732;
      case 733:
        return _struct._unique_message_item_733;
      case 734:
        return _struct._unique_message_item_734;
      case 735:
        return _struct._unique_message_item_735;
      case 736:
        return _struct._unique_message_item_736;
      case 737:
        return _struct._unique_message_item_737;
      case 738:
        return _struct._unique_message_item_738;
      case 739:
        return _struct._unique_message_item_739;
      case 740:
        return _struct._unique_message_item_740;
      case 741:
        return _struct._unique_message_item_741;
      case 742:
        return _struct._unique_message_item_742;
      case 743:
        return _struct._unique_message_item_743;
      case 744:
        return _struct._unique_message_item_744;
      case 745:
        return _struct._unique_message_item_745;
      case 746:
        return _struct._unique_message_item_746;
      case 747:
        return _struct._unique_message_item_747;
      case 748:
        return _struct._unique_message_item_748;
      case 749:
        return _struct._unique_message_item_749;
      case 750:
        return _struct._unique_message_item_750;
      case 751:
        return _struct._unique_message_item_751;
      case 752:
        return _struct._unique_message_item_752;
      case 753:
        return _struct._unique_message_item_753;
      case 754:
        return _struct._unique_message_item_754;
      case 755:
        return _struct._unique_message_item_755;
      case 756:
        return _struct._unique_message_item_756;
      case 757:
        return _struct._unique_message_item_757;
      case 758:
        return _struct._unique_message_item_758;
      case 759:
        return _struct._unique_message_item_759;
      case 760:
        return _struct._unique_message_item_760;
      case 761:
        return _struct._unique_message_item_761;
      case 762:
        return _struct._unique_message_item_762;
      case 763:
        return _struct._unique_message_item_763;
      case 764:
        return _struct._unique_message_item_764;
      case 765:
        return _struct._unique_message_item_765;
      case 766:
        return _struct._unique_message_item_766;
      case 767:
        return _struct._unique_message_item_767;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_message_item_0 = value;
        break;
      case 1:
        _struct._unique_message_item_1 = value;
        break;
      case 2:
        _struct._unique_message_item_2 = value;
        break;
      case 3:
        _struct._unique_message_item_3 = value;
        break;
      case 4:
        _struct._unique_message_item_4 = value;
        break;
      case 5:
        _struct._unique_message_item_5 = value;
        break;
      case 6:
        _struct._unique_message_item_6 = value;
        break;
      case 7:
        _struct._unique_message_item_7 = value;
        break;
      case 8:
        _struct._unique_message_item_8 = value;
        break;
      case 9:
        _struct._unique_message_item_9 = value;
        break;
      case 10:
        _struct._unique_message_item_10 = value;
        break;
      case 11:
        _struct._unique_message_item_11 = value;
        break;
      case 12:
        _struct._unique_message_item_12 = value;
        break;
      case 13:
        _struct._unique_message_item_13 = value;
        break;
      case 14:
        _struct._unique_message_item_14 = value;
        break;
      case 15:
        _struct._unique_message_item_15 = value;
        break;
      case 16:
        _struct._unique_message_item_16 = value;
        break;
      case 17:
        _struct._unique_message_item_17 = value;
        break;
      case 18:
        _struct._unique_message_item_18 = value;
        break;
      case 19:
        _struct._unique_message_item_19 = value;
        break;
      case 20:
        _struct._unique_message_item_20 = value;
        break;
      case 21:
        _struct._unique_message_item_21 = value;
        break;
      case 22:
        _struct._unique_message_item_22 = value;
        break;
      case 23:
        _struct._unique_message_item_23 = value;
        break;
      case 24:
        _struct._unique_message_item_24 = value;
        break;
      case 25:
        _struct._unique_message_item_25 = value;
        break;
      case 26:
        _struct._unique_message_item_26 = value;
        break;
      case 27:
        _struct._unique_message_item_27 = value;
        break;
      case 28:
        _struct._unique_message_item_28 = value;
        break;
      case 29:
        _struct._unique_message_item_29 = value;
        break;
      case 30:
        _struct._unique_message_item_30 = value;
        break;
      case 31:
        _struct._unique_message_item_31 = value;
        break;
      case 32:
        _struct._unique_message_item_32 = value;
        break;
      case 33:
        _struct._unique_message_item_33 = value;
        break;
      case 34:
        _struct._unique_message_item_34 = value;
        break;
      case 35:
        _struct._unique_message_item_35 = value;
        break;
      case 36:
        _struct._unique_message_item_36 = value;
        break;
      case 37:
        _struct._unique_message_item_37 = value;
        break;
      case 38:
        _struct._unique_message_item_38 = value;
        break;
      case 39:
        _struct._unique_message_item_39 = value;
        break;
      case 40:
        _struct._unique_message_item_40 = value;
        break;
      case 41:
        _struct._unique_message_item_41 = value;
        break;
      case 42:
        _struct._unique_message_item_42 = value;
        break;
      case 43:
        _struct._unique_message_item_43 = value;
        break;
      case 44:
        _struct._unique_message_item_44 = value;
        break;
      case 45:
        _struct._unique_message_item_45 = value;
        break;
      case 46:
        _struct._unique_message_item_46 = value;
        break;
      case 47:
        _struct._unique_message_item_47 = value;
        break;
      case 48:
        _struct._unique_message_item_48 = value;
        break;
      case 49:
        _struct._unique_message_item_49 = value;
        break;
      case 50:
        _struct._unique_message_item_50 = value;
        break;
      case 51:
        _struct._unique_message_item_51 = value;
        break;
      case 52:
        _struct._unique_message_item_52 = value;
        break;
      case 53:
        _struct._unique_message_item_53 = value;
        break;
      case 54:
        _struct._unique_message_item_54 = value;
        break;
      case 55:
        _struct._unique_message_item_55 = value;
        break;
      case 56:
        _struct._unique_message_item_56 = value;
        break;
      case 57:
        _struct._unique_message_item_57 = value;
        break;
      case 58:
        _struct._unique_message_item_58 = value;
        break;
      case 59:
        _struct._unique_message_item_59 = value;
        break;
      case 60:
        _struct._unique_message_item_60 = value;
        break;
      case 61:
        _struct._unique_message_item_61 = value;
        break;
      case 62:
        _struct._unique_message_item_62 = value;
        break;
      case 63:
        _struct._unique_message_item_63 = value;
        break;
      case 64:
        _struct._unique_message_item_64 = value;
        break;
      case 65:
        _struct._unique_message_item_65 = value;
        break;
      case 66:
        _struct._unique_message_item_66 = value;
        break;
      case 67:
        _struct._unique_message_item_67 = value;
        break;
      case 68:
        _struct._unique_message_item_68 = value;
        break;
      case 69:
        _struct._unique_message_item_69 = value;
        break;
      case 70:
        _struct._unique_message_item_70 = value;
        break;
      case 71:
        _struct._unique_message_item_71 = value;
        break;
      case 72:
        _struct._unique_message_item_72 = value;
        break;
      case 73:
        _struct._unique_message_item_73 = value;
        break;
      case 74:
        _struct._unique_message_item_74 = value;
        break;
      case 75:
        _struct._unique_message_item_75 = value;
        break;
      case 76:
        _struct._unique_message_item_76 = value;
        break;
      case 77:
        _struct._unique_message_item_77 = value;
        break;
      case 78:
        _struct._unique_message_item_78 = value;
        break;
      case 79:
        _struct._unique_message_item_79 = value;
        break;
      case 80:
        _struct._unique_message_item_80 = value;
        break;
      case 81:
        _struct._unique_message_item_81 = value;
        break;
      case 82:
        _struct._unique_message_item_82 = value;
        break;
      case 83:
        _struct._unique_message_item_83 = value;
        break;
      case 84:
        _struct._unique_message_item_84 = value;
        break;
      case 85:
        _struct._unique_message_item_85 = value;
        break;
      case 86:
        _struct._unique_message_item_86 = value;
        break;
      case 87:
        _struct._unique_message_item_87 = value;
        break;
      case 88:
        _struct._unique_message_item_88 = value;
        break;
      case 89:
        _struct._unique_message_item_89 = value;
        break;
      case 90:
        _struct._unique_message_item_90 = value;
        break;
      case 91:
        _struct._unique_message_item_91 = value;
        break;
      case 92:
        _struct._unique_message_item_92 = value;
        break;
      case 93:
        _struct._unique_message_item_93 = value;
        break;
      case 94:
        _struct._unique_message_item_94 = value;
        break;
      case 95:
        _struct._unique_message_item_95 = value;
        break;
      case 96:
        _struct._unique_message_item_96 = value;
        break;
      case 97:
        _struct._unique_message_item_97 = value;
        break;
      case 98:
        _struct._unique_message_item_98 = value;
        break;
      case 99:
        _struct._unique_message_item_99 = value;
        break;
      case 100:
        _struct._unique_message_item_100 = value;
        break;
      case 101:
        _struct._unique_message_item_101 = value;
        break;
      case 102:
        _struct._unique_message_item_102 = value;
        break;
      case 103:
        _struct._unique_message_item_103 = value;
        break;
      case 104:
        _struct._unique_message_item_104 = value;
        break;
      case 105:
        _struct._unique_message_item_105 = value;
        break;
      case 106:
        _struct._unique_message_item_106 = value;
        break;
      case 107:
        _struct._unique_message_item_107 = value;
        break;
      case 108:
        _struct._unique_message_item_108 = value;
        break;
      case 109:
        _struct._unique_message_item_109 = value;
        break;
      case 110:
        _struct._unique_message_item_110 = value;
        break;
      case 111:
        _struct._unique_message_item_111 = value;
        break;
      case 112:
        _struct._unique_message_item_112 = value;
        break;
      case 113:
        _struct._unique_message_item_113 = value;
        break;
      case 114:
        _struct._unique_message_item_114 = value;
        break;
      case 115:
        _struct._unique_message_item_115 = value;
        break;
      case 116:
        _struct._unique_message_item_116 = value;
        break;
      case 117:
        _struct._unique_message_item_117 = value;
        break;
      case 118:
        _struct._unique_message_item_118 = value;
        break;
      case 119:
        _struct._unique_message_item_119 = value;
        break;
      case 120:
        _struct._unique_message_item_120 = value;
        break;
      case 121:
        _struct._unique_message_item_121 = value;
        break;
      case 122:
        _struct._unique_message_item_122 = value;
        break;
      case 123:
        _struct._unique_message_item_123 = value;
        break;
      case 124:
        _struct._unique_message_item_124 = value;
        break;
      case 125:
        _struct._unique_message_item_125 = value;
        break;
      case 126:
        _struct._unique_message_item_126 = value;
        break;
      case 127:
        _struct._unique_message_item_127 = value;
        break;
      case 128:
        _struct._unique_message_item_128 = value;
        break;
      case 129:
        _struct._unique_message_item_129 = value;
        break;
      case 130:
        _struct._unique_message_item_130 = value;
        break;
      case 131:
        _struct._unique_message_item_131 = value;
        break;
      case 132:
        _struct._unique_message_item_132 = value;
        break;
      case 133:
        _struct._unique_message_item_133 = value;
        break;
      case 134:
        _struct._unique_message_item_134 = value;
        break;
      case 135:
        _struct._unique_message_item_135 = value;
        break;
      case 136:
        _struct._unique_message_item_136 = value;
        break;
      case 137:
        _struct._unique_message_item_137 = value;
        break;
      case 138:
        _struct._unique_message_item_138 = value;
        break;
      case 139:
        _struct._unique_message_item_139 = value;
        break;
      case 140:
        _struct._unique_message_item_140 = value;
        break;
      case 141:
        _struct._unique_message_item_141 = value;
        break;
      case 142:
        _struct._unique_message_item_142 = value;
        break;
      case 143:
        _struct._unique_message_item_143 = value;
        break;
      case 144:
        _struct._unique_message_item_144 = value;
        break;
      case 145:
        _struct._unique_message_item_145 = value;
        break;
      case 146:
        _struct._unique_message_item_146 = value;
        break;
      case 147:
        _struct._unique_message_item_147 = value;
        break;
      case 148:
        _struct._unique_message_item_148 = value;
        break;
      case 149:
        _struct._unique_message_item_149 = value;
        break;
      case 150:
        _struct._unique_message_item_150 = value;
        break;
      case 151:
        _struct._unique_message_item_151 = value;
        break;
      case 152:
        _struct._unique_message_item_152 = value;
        break;
      case 153:
        _struct._unique_message_item_153 = value;
        break;
      case 154:
        _struct._unique_message_item_154 = value;
        break;
      case 155:
        _struct._unique_message_item_155 = value;
        break;
      case 156:
        _struct._unique_message_item_156 = value;
        break;
      case 157:
        _struct._unique_message_item_157 = value;
        break;
      case 158:
        _struct._unique_message_item_158 = value;
        break;
      case 159:
        _struct._unique_message_item_159 = value;
        break;
      case 160:
        _struct._unique_message_item_160 = value;
        break;
      case 161:
        _struct._unique_message_item_161 = value;
        break;
      case 162:
        _struct._unique_message_item_162 = value;
        break;
      case 163:
        _struct._unique_message_item_163 = value;
        break;
      case 164:
        _struct._unique_message_item_164 = value;
        break;
      case 165:
        _struct._unique_message_item_165 = value;
        break;
      case 166:
        _struct._unique_message_item_166 = value;
        break;
      case 167:
        _struct._unique_message_item_167 = value;
        break;
      case 168:
        _struct._unique_message_item_168 = value;
        break;
      case 169:
        _struct._unique_message_item_169 = value;
        break;
      case 170:
        _struct._unique_message_item_170 = value;
        break;
      case 171:
        _struct._unique_message_item_171 = value;
        break;
      case 172:
        _struct._unique_message_item_172 = value;
        break;
      case 173:
        _struct._unique_message_item_173 = value;
        break;
      case 174:
        _struct._unique_message_item_174 = value;
        break;
      case 175:
        _struct._unique_message_item_175 = value;
        break;
      case 176:
        _struct._unique_message_item_176 = value;
        break;
      case 177:
        _struct._unique_message_item_177 = value;
        break;
      case 178:
        _struct._unique_message_item_178 = value;
        break;
      case 179:
        _struct._unique_message_item_179 = value;
        break;
      case 180:
        _struct._unique_message_item_180 = value;
        break;
      case 181:
        _struct._unique_message_item_181 = value;
        break;
      case 182:
        _struct._unique_message_item_182 = value;
        break;
      case 183:
        _struct._unique_message_item_183 = value;
        break;
      case 184:
        _struct._unique_message_item_184 = value;
        break;
      case 185:
        _struct._unique_message_item_185 = value;
        break;
      case 186:
        _struct._unique_message_item_186 = value;
        break;
      case 187:
        _struct._unique_message_item_187 = value;
        break;
      case 188:
        _struct._unique_message_item_188 = value;
        break;
      case 189:
        _struct._unique_message_item_189 = value;
        break;
      case 190:
        _struct._unique_message_item_190 = value;
        break;
      case 191:
        _struct._unique_message_item_191 = value;
        break;
      case 192:
        _struct._unique_message_item_192 = value;
        break;
      case 193:
        _struct._unique_message_item_193 = value;
        break;
      case 194:
        _struct._unique_message_item_194 = value;
        break;
      case 195:
        _struct._unique_message_item_195 = value;
        break;
      case 196:
        _struct._unique_message_item_196 = value;
        break;
      case 197:
        _struct._unique_message_item_197 = value;
        break;
      case 198:
        _struct._unique_message_item_198 = value;
        break;
      case 199:
        _struct._unique_message_item_199 = value;
        break;
      case 200:
        _struct._unique_message_item_200 = value;
        break;
      case 201:
        _struct._unique_message_item_201 = value;
        break;
      case 202:
        _struct._unique_message_item_202 = value;
        break;
      case 203:
        _struct._unique_message_item_203 = value;
        break;
      case 204:
        _struct._unique_message_item_204 = value;
        break;
      case 205:
        _struct._unique_message_item_205 = value;
        break;
      case 206:
        _struct._unique_message_item_206 = value;
        break;
      case 207:
        _struct._unique_message_item_207 = value;
        break;
      case 208:
        _struct._unique_message_item_208 = value;
        break;
      case 209:
        _struct._unique_message_item_209 = value;
        break;
      case 210:
        _struct._unique_message_item_210 = value;
        break;
      case 211:
        _struct._unique_message_item_211 = value;
        break;
      case 212:
        _struct._unique_message_item_212 = value;
        break;
      case 213:
        _struct._unique_message_item_213 = value;
        break;
      case 214:
        _struct._unique_message_item_214 = value;
        break;
      case 215:
        _struct._unique_message_item_215 = value;
        break;
      case 216:
        _struct._unique_message_item_216 = value;
        break;
      case 217:
        _struct._unique_message_item_217 = value;
        break;
      case 218:
        _struct._unique_message_item_218 = value;
        break;
      case 219:
        _struct._unique_message_item_219 = value;
        break;
      case 220:
        _struct._unique_message_item_220 = value;
        break;
      case 221:
        _struct._unique_message_item_221 = value;
        break;
      case 222:
        _struct._unique_message_item_222 = value;
        break;
      case 223:
        _struct._unique_message_item_223 = value;
        break;
      case 224:
        _struct._unique_message_item_224 = value;
        break;
      case 225:
        _struct._unique_message_item_225 = value;
        break;
      case 226:
        _struct._unique_message_item_226 = value;
        break;
      case 227:
        _struct._unique_message_item_227 = value;
        break;
      case 228:
        _struct._unique_message_item_228 = value;
        break;
      case 229:
        _struct._unique_message_item_229 = value;
        break;
      case 230:
        _struct._unique_message_item_230 = value;
        break;
      case 231:
        _struct._unique_message_item_231 = value;
        break;
      case 232:
        _struct._unique_message_item_232 = value;
        break;
      case 233:
        _struct._unique_message_item_233 = value;
        break;
      case 234:
        _struct._unique_message_item_234 = value;
        break;
      case 235:
        _struct._unique_message_item_235 = value;
        break;
      case 236:
        _struct._unique_message_item_236 = value;
        break;
      case 237:
        _struct._unique_message_item_237 = value;
        break;
      case 238:
        _struct._unique_message_item_238 = value;
        break;
      case 239:
        _struct._unique_message_item_239 = value;
        break;
      case 240:
        _struct._unique_message_item_240 = value;
        break;
      case 241:
        _struct._unique_message_item_241 = value;
        break;
      case 242:
        _struct._unique_message_item_242 = value;
        break;
      case 243:
        _struct._unique_message_item_243 = value;
        break;
      case 244:
        _struct._unique_message_item_244 = value;
        break;
      case 245:
        _struct._unique_message_item_245 = value;
        break;
      case 246:
        _struct._unique_message_item_246 = value;
        break;
      case 247:
        _struct._unique_message_item_247 = value;
        break;
      case 248:
        _struct._unique_message_item_248 = value;
        break;
      case 249:
        _struct._unique_message_item_249 = value;
        break;
      case 250:
        _struct._unique_message_item_250 = value;
        break;
      case 251:
        _struct._unique_message_item_251 = value;
        break;
      case 252:
        _struct._unique_message_item_252 = value;
        break;
      case 253:
        _struct._unique_message_item_253 = value;
        break;
      case 254:
        _struct._unique_message_item_254 = value;
        break;
      case 255:
        _struct._unique_message_item_255 = value;
        break;
      case 256:
        _struct._unique_message_item_256 = value;
        break;
      case 257:
        _struct._unique_message_item_257 = value;
        break;
      case 258:
        _struct._unique_message_item_258 = value;
        break;
      case 259:
        _struct._unique_message_item_259 = value;
        break;
      case 260:
        _struct._unique_message_item_260 = value;
        break;
      case 261:
        _struct._unique_message_item_261 = value;
        break;
      case 262:
        _struct._unique_message_item_262 = value;
        break;
      case 263:
        _struct._unique_message_item_263 = value;
        break;
      case 264:
        _struct._unique_message_item_264 = value;
        break;
      case 265:
        _struct._unique_message_item_265 = value;
        break;
      case 266:
        _struct._unique_message_item_266 = value;
        break;
      case 267:
        _struct._unique_message_item_267 = value;
        break;
      case 268:
        _struct._unique_message_item_268 = value;
        break;
      case 269:
        _struct._unique_message_item_269 = value;
        break;
      case 270:
        _struct._unique_message_item_270 = value;
        break;
      case 271:
        _struct._unique_message_item_271 = value;
        break;
      case 272:
        _struct._unique_message_item_272 = value;
        break;
      case 273:
        _struct._unique_message_item_273 = value;
        break;
      case 274:
        _struct._unique_message_item_274 = value;
        break;
      case 275:
        _struct._unique_message_item_275 = value;
        break;
      case 276:
        _struct._unique_message_item_276 = value;
        break;
      case 277:
        _struct._unique_message_item_277 = value;
        break;
      case 278:
        _struct._unique_message_item_278 = value;
        break;
      case 279:
        _struct._unique_message_item_279 = value;
        break;
      case 280:
        _struct._unique_message_item_280 = value;
        break;
      case 281:
        _struct._unique_message_item_281 = value;
        break;
      case 282:
        _struct._unique_message_item_282 = value;
        break;
      case 283:
        _struct._unique_message_item_283 = value;
        break;
      case 284:
        _struct._unique_message_item_284 = value;
        break;
      case 285:
        _struct._unique_message_item_285 = value;
        break;
      case 286:
        _struct._unique_message_item_286 = value;
        break;
      case 287:
        _struct._unique_message_item_287 = value;
        break;
      case 288:
        _struct._unique_message_item_288 = value;
        break;
      case 289:
        _struct._unique_message_item_289 = value;
        break;
      case 290:
        _struct._unique_message_item_290 = value;
        break;
      case 291:
        _struct._unique_message_item_291 = value;
        break;
      case 292:
        _struct._unique_message_item_292 = value;
        break;
      case 293:
        _struct._unique_message_item_293 = value;
        break;
      case 294:
        _struct._unique_message_item_294 = value;
        break;
      case 295:
        _struct._unique_message_item_295 = value;
        break;
      case 296:
        _struct._unique_message_item_296 = value;
        break;
      case 297:
        _struct._unique_message_item_297 = value;
        break;
      case 298:
        _struct._unique_message_item_298 = value;
        break;
      case 299:
        _struct._unique_message_item_299 = value;
        break;
      case 300:
        _struct._unique_message_item_300 = value;
        break;
      case 301:
        _struct._unique_message_item_301 = value;
        break;
      case 302:
        _struct._unique_message_item_302 = value;
        break;
      case 303:
        _struct._unique_message_item_303 = value;
        break;
      case 304:
        _struct._unique_message_item_304 = value;
        break;
      case 305:
        _struct._unique_message_item_305 = value;
        break;
      case 306:
        _struct._unique_message_item_306 = value;
        break;
      case 307:
        _struct._unique_message_item_307 = value;
        break;
      case 308:
        _struct._unique_message_item_308 = value;
        break;
      case 309:
        _struct._unique_message_item_309 = value;
        break;
      case 310:
        _struct._unique_message_item_310 = value;
        break;
      case 311:
        _struct._unique_message_item_311 = value;
        break;
      case 312:
        _struct._unique_message_item_312 = value;
        break;
      case 313:
        _struct._unique_message_item_313 = value;
        break;
      case 314:
        _struct._unique_message_item_314 = value;
        break;
      case 315:
        _struct._unique_message_item_315 = value;
        break;
      case 316:
        _struct._unique_message_item_316 = value;
        break;
      case 317:
        _struct._unique_message_item_317 = value;
        break;
      case 318:
        _struct._unique_message_item_318 = value;
        break;
      case 319:
        _struct._unique_message_item_319 = value;
        break;
      case 320:
        _struct._unique_message_item_320 = value;
        break;
      case 321:
        _struct._unique_message_item_321 = value;
        break;
      case 322:
        _struct._unique_message_item_322 = value;
        break;
      case 323:
        _struct._unique_message_item_323 = value;
        break;
      case 324:
        _struct._unique_message_item_324 = value;
        break;
      case 325:
        _struct._unique_message_item_325 = value;
        break;
      case 326:
        _struct._unique_message_item_326 = value;
        break;
      case 327:
        _struct._unique_message_item_327 = value;
        break;
      case 328:
        _struct._unique_message_item_328 = value;
        break;
      case 329:
        _struct._unique_message_item_329 = value;
        break;
      case 330:
        _struct._unique_message_item_330 = value;
        break;
      case 331:
        _struct._unique_message_item_331 = value;
        break;
      case 332:
        _struct._unique_message_item_332 = value;
        break;
      case 333:
        _struct._unique_message_item_333 = value;
        break;
      case 334:
        _struct._unique_message_item_334 = value;
        break;
      case 335:
        _struct._unique_message_item_335 = value;
        break;
      case 336:
        _struct._unique_message_item_336 = value;
        break;
      case 337:
        _struct._unique_message_item_337 = value;
        break;
      case 338:
        _struct._unique_message_item_338 = value;
        break;
      case 339:
        _struct._unique_message_item_339 = value;
        break;
      case 340:
        _struct._unique_message_item_340 = value;
        break;
      case 341:
        _struct._unique_message_item_341 = value;
        break;
      case 342:
        _struct._unique_message_item_342 = value;
        break;
      case 343:
        _struct._unique_message_item_343 = value;
        break;
      case 344:
        _struct._unique_message_item_344 = value;
        break;
      case 345:
        _struct._unique_message_item_345 = value;
        break;
      case 346:
        _struct._unique_message_item_346 = value;
        break;
      case 347:
        _struct._unique_message_item_347 = value;
        break;
      case 348:
        _struct._unique_message_item_348 = value;
        break;
      case 349:
        _struct._unique_message_item_349 = value;
        break;
      case 350:
        _struct._unique_message_item_350 = value;
        break;
      case 351:
        _struct._unique_message_item_351 = value;
        break;
      case 352:
        _struct._unique_message_item_352 = value;
        break;
      case 353:
        _struct._unique_message_item_353 = value;
        break;
      case 354:
        _struct._unique_message_item_354 = value;
        break;
      case 355:
        _struct._unique_message_item_355 = value;
        break;
      case 356:
        _struct._unique_message_item_356 = value;
        break;
      case 357:
        _struct._unique_message_item_357 = value;
        break;
      case 358:
        _struct._unique_message_item_358 = value;
        break;
      case 359:
        _struct._unique_message_item_359 = value;
        break;
      case 360:
        _struct._unique_message_item_360 = value;
        break;
      case 361:
        _struct._unique_message_item_361 = value;
        break;
      case 362:
        _struct._unique_message_item_362 = value;
        break;
      case 363:
        _struct._unique_message_item_363 = value;
        break;
      case 364:
        _struct._unique_message_item_364 = value;
        break;
      case 365:
        _struct._unique_message_item_365 = value;
        break;
      case 366:
        _struct._unique_message_item_366 = value;
        break;
      case 367:
        _struct._unique_message_item_367 = value;
        break;
      case 368:
        _struct._unique_message_item_368 = value;
        break;
      case 369:
        _struct._unique_message_item_369 = value;
        break;
      case 370:
        _struct._unique_message_item_370 = value;
        break;
      case 371:
        _struct._unique_message_item_371 = value;
        break;
      case 372:
        _struct._unique_message_item_372 = value;
        break;
      case 373:
        _struct._unique_message_item_373 = value;
        break;
      case 374:
        _struct._unique_message_item_374 = value;
        break;
      case 375:
        _struct._unique_message_item_375 = value;
        break;
      case 376:
        _struct._unique_message_item_376 = value;
        break;
      case 377:
        _struct._unique_message_item_377 = value;
        break;
      case 378:
        _struct._unique_message_item_378 = value;
        break;
      case 379:
        _struct._unique_message_item_379 = value;
        break;
      case 380:
        _struct._unique_message_item_380 = value;
        break;
      case 381:
        _struct._unique_message_item_381 = value;
        break;
      case 382:
        _struct._unique_message_item_382 = value;
        break;
      case 383:
        _struct._unique_message_item_383 = value;
        break;
      case 384:
        _struct._unique_message_item_384 = value;
        break;
      case 385:
        _struct._unique_message_item_385 = value;
        break;
      case 386:
        _struct._unique_message_item_386 = value;
        break;
      case 387:
        _struct._unique_message_item_387 = value;
        break;
      case 388:
        _struct._unique_message_item_388 = value;
        break;
      case 389:
        _struct._unique_message_item_389 = value;
        break;
      case 390:
        _struct._unique_message_item_390 = value;
        break;
      case 391:
        _struct._unique_message_item_391 = value;
        break;
      case 392:
        _struct._unique_message_item_392 = value;
        break;
      case 393:
        _struct._unique_message_item_393 = value;
        break;
      case 394:
        _struct._unique_message_item_394 = value;
        break;
      case 395:
        _struct._unique_message_item_395 = value;
        break;
      case 396:
        _struct._unique_message_item_396 = value;
        break;
      case 397:
        _struct._unique_message_item_397 = value;
        break;
      case 398:
        _struct._unique_message_item_398 = value;
        break;
      case 399:
        _struct._unique_message_item_399 = value;
        break;
      case 400:
        _struct._unique_message_item_400 = value;
        break;
      case 401:
        _struct._unique_message_item_401 = value;
        break;
      case 402:
        _struct._unique_message_item_402 = value;
        break;
      case 403:
        _struct._unique_message_item_403 = value;
        break;
      case 404:
        _struct._unique_message_item_404 = value;
        break;
      case 405:
        _struct._unique_message_item_405 = value;
        break;
      case 406:
        _struct._unique_message_item_406 = value;
        break;
      case 407:
        _struct._unique_message_item_407 = value;
        break;
      case 408:
        _struct._unique_message_item_408 = value;
        break;
      case 409:
        _struct._unique_message_item_409 = value;
        break;
      case 410:
        _struct._unique_message_item_410 = value;
        break;
      case 411:
        _struct._unique_message_item_411 = value;
        break;
      case 412:
        _struct._unique_message_item_412 = value;
        break;
      case 413:
        _struct._unique_message_item_413 = value;
        break;
      case 414:
        _struct._unique_message_item_414 = value;
        break;
      case 415:
        _struct._unique_message_item_415 = value;
        break;
      case 416:
        _struct._unique_message_item_416 = value;
        break;
      case 417:
        _struct._unique_message_item_417 = value;
        break;
      case 418:
        _struct._unique_message_item_418 = value;
        break;
      case 419:
        _struct._unique_message_item_419 = value;
        break;
      case 420:
        _struct._unique_message_item_420 = value;
        break;
      case 421:
        _struct._unique_message_item_421 = value;
        break;
      case 422:
        _struct._unique_message_item_422 = value;
        break;
      case 423:
        _struct._unique_message_item_423 = value;
        break;
      case 424:
        _struct._unique_message_item_424 = value;
        break;
      case 425:
        _struct._unique_message_item_425 = value;
        break;
      case 426:
        _struct._unique_message_item_426 = value;
        break;
      case 427:
        _struct._unique_message_item_427 = value;
        break;
      case 428:
        _struct._unique_message_item_428 = value;
        break;
      case 429:
        _struct._unique_message_item_429 = value;
        break;
      case 430:
        _struct._unique_message_item_430 = value;
        break;
      case 431:
        _struct._unique_message_item_431 = value;
        break;
      case 432:
        _struct._unique_message_item_432 = value;
        break;
      case 433:
        _struct._unique_message_item_433 = value;
        break;
      case 434:
        _struct._unique_message_item_434 = value;
        break;
      case 435:
        _struct._unique_message_item_435 = value;
        break;
      case 436:
        _struct._unique_message_item_436 = value;
        break;
      case 437:
        _struct._unique_message_item_437 = value;
        break;
      case 438:
        _struct._unique_message_item_438 = value;
        break;
      case 439:
        _struct._unique_message_item_439 = value;
        break;
      case 440:
        _struct._unique_message_item_440 = value;
        break;
      case 441:
        _struct._unique_message_item_441 = value;
        break;
      case 442:
        _struct._unique_message_item_442 = value;
        break;
      case 443:
        _struct._unique_message_item_443 = value;
        break;
      case 444:
        _struct._unique_message_item_444 = value;
        break;
      case 445:
        _struct._unique_message_item_445 = value;
        break;
      case 446:
        _struct._unique_message_item_446 = value;
        break;
      case 447:
        _struct._unique_message_item_447 = value;
        break;
      case 448:
        _struct._unique_message_item_448 = value;
        break;
      case 449:
        _struct._unique_message_item_449 = value;
        break;
      case 450:
        _struct._unique_message_item_450 = value;
        break;
      case 451:
        _struct._unique_message_item_451 = value;
        break;
      case 452:
        _struct._unique_message_item_452 = value;
        break;
      case 453:
        _struct._unique_message_item_453 = value;
        break;
      case 454:
        _struct._unique_message_item_454 = value;
        break;
      case 455:
        _struct._unique_message_item_455 = value;
        break;
      case 456:
        _struct._unique_message_item_456 = value;
        break;
      case 457:
        _struct._unique_message_item_457 = value;
        break;
      case 458:
        _struct._unique_message_item_458 = value;
        break;
      case 459:
        _struct._unique_message_item_459 = value;
        break;
      case 460:
        _struct._unique_message_item_460 = value;
        break;
      case 461:
        _struct._unique_message_item_461 = value;
        break;
      case 462:
        _struct._unique_message_item_462 = value;
        break;
      case 463:
        _struct._unique_message_item_463 = value;
        break;
      case 464:
        _struct._unique_message_item_464 = value;
        break;
      case 465:
        _struct._unique_message_item_465 = value;
        break;
      case 466:
        _struct._unique_message_item_466 = value;
        break;
      case 467:
        _struct._unique_message_item_467 = value;
        break;
      case 468:
        _struct._unique_message_item_468 = value;
        break;
      case 469:
        _struct._unique_message_item_469 = value;
        break;
      case 470:
        _struct._unique_message_item_470 = value;
        break;
      case 471:
        _struct._unique_message_item_471 = value;
        break;
      case 472:
        _struct._unique_message_item_472 = value;
        break;
      case 473:
        _struct._unique_message_item_473 = value;
        break;
      case 474:
        _struct._unique_message_item_474 = value;
        break;
      case 475:
        _struct._unique_message_item_475 = value;
        break;
      case 476:
        _struct._unique_message_item_476 = value;
        break;
      case 477:
        _struct._unique_message_item_477 = value;
        break;
      case 478:
        _struct._unique_message_item_478 = value;
        break;
      case 479:
        _struct._unique_message_item_479 = value;
        break;
      case 480:
        _struct._unique_message_item_480 = value;
        break;
      case 481:
        _struct._unique_message_item_481 = value;
        break;
      case 482:
        _struct._unique_message_item_482 = value;
        break;
      case 483:
        _struct._unique_message_item_483 = value;
        break;
      case 484:
        _struct._unique_message_item_484 = value;
        break;
      case 485:
        _struct._unique_message_item_485 = value;
        break;
      case 486:
        _struct._unique_message_item_486 = value;
        break;
      case 487:
        _struct._unique_message_item_487 = value;
        break;
      case 488:
        _struct._unique_message_item_488 = value;
        break;
      case 489:
        _struct._unique_message_item_489 = value;
        break;
      case 490:
        _struct._unique_message_item_490 = value;
        break;
      case 491:
        _struct._unique_message_item_491 = value;
        break;
      case 492:
        _struct._unique_message_item_492 = value;
        break;
      case 493:
        _struct._unique_message_item_493 = value;
        break;
      case 494:
        _struct._unique_message_item_494 = value;
        break;
      case 495:
        _struct._unique_message_item_495 = value;
        break;
      case 496:
        _struct._unique_message_item_496 = value;
        break;
      case 497:
        _struct._unique_message_item_497 = value;
        break;
      case 498:
        _struct._unique_message_item_498 = value;
        break;
      case 499:
        _struct._unique_message_item_499 = value;
        break;
      case 500:
        _struct._unique_message_item_500 = value;
        break;
      case 501:
        _struct._unique_message_item_501 = value;
        break;
      case 502:
        _struct._unique_message_item_502 = value;
        break;
      case 503:
        _struct._unique_message_item_503 = value;
        break;
      case 504:
        _struct._unique_message_item_504 = value;
        break;
      case 505:
        _struct._unique_message_item_505 = value;
        break;
      case 506:
        _struct._unique_message_item_506 = value;
        break;
      case 507:
        _struct._unique_message_item_507 = value;
        break;
      case 508:
        _struct._unique_message_item_508 = value;
        break;
      case 509:
        _struct._unique_message_item_509 = value;
        break;
      case 510:
        _struct._unique_message_item_510 = value;
        break;
      case 511:
        _struct._unique_message_item_511 = value;
        break;
      case 512:
        _struct._unique_message_item_512 = value;
        break;
      case 513:
        _struct._unique_message_item_513 = value;
        break;
      case 514:
        _struct._unique_message_item_514 = value;
        break;
      case 515:
        _struct._unique_message_item_515 = value;
        break;
      case 516:
        _struct._unique_message_item_516 = value;
        break;
      case 517:
        _struct._unique_message_item_517 = value;
        break;
      case 518:
        _struct._unique_message_item_518 = value;
        break;
      case 519:
        _struct._unique_message_item_519 = value;
        break;
      case 520:
        _struct._unique_message_item_520 = value;
        break;
      case 521:
        _struct._unique_message_item_521 = value;
        break;
      case 522:
        _struct._unique_message_item_522 = value;
        break;
      case 523:
        _struct._unique_message_item_523 = value;
        break;
      case 524:
        _struct._unique_message_item_524 = value;
        break;
      case 525:
        _struct._unique_message_item_525 = value;
        break;
      case 526:
        _struct._unique_message_item_526 = value;
        break;
      case 527:
        _struct._unique_message_item_527 = value;
        break;
      case 528:
        _struct._unique_message_item_528 = value;
        break;
      case 529:
        _struct._unique_message_item_529 = value;
        break;
      case 530:
        _struct._unique_message_item_530 = value;
        break;
      case 531:
        _struct._unique_message_item_531 = value;
        break;
      case 532:
        _struct._unique_message_item_532 = value;
        break;
      case 533:
        _struct._unique_message_item_533 = value;
        break;
      case 534:
        _struct._unique_message_item_534 = value;
        break;
      case 535:
        _struct._unique_message_item_535 = value;
        break;
      case 536:
        _struct._unique_message_item_536 = value;
        break;
      case 537:
        _struct._unique_message_item_537 = value;
        break;
      case 538:
        _struct._unique_message_item_538 = value;
        break;
      case 539:
        _struct._unique_message_item_539 = value;
        break;
      case 540:
        _struct._unique_message_item_540 = value;
        break;
      case 541:
        _struct._unique_message_item_541 = value;
        break;
      case 542:
        _struct._unique_message_item_542 = value;
        break;
      case 543:
        _struct._unique_message_item_543 = value;
        break;
      case 544:
        _struct._unique_message_item_544 = value;
        break;
      case 545:
        _struct._unique_message_item_545 = value;
        break;
      case 546:
        _struct._unique_message_item_546 = value;
        break;
      case 547:
        _struct._unique_message_item_547 = value;
        break;
      case 548:
        _struct._unique_message_item_548 = value;
        break;
      case 549:
        _struct._unique_message_item_549 = value;
        break;
      case 550:
        _struct._unique_message_item_550 = value;
        break;
      case 551:
        _struct._unique_message_item_551 = value;
        break;
      case 552:
        _struct._unique_message_item_552 = value;
        break;
      case 553:
        _struct._unique_message_item_553 = value;
        break;
      case 554:
        _struct._unique_message_item_554 = value;
        break;
      case 555:
        _struct._unique_message_item_555 = value;
        break;
      case 556:
        _struct._unique_message_item_556 = value;
        break;
      case 557:
        _struct._unique_message_item_557 = value;
        break;
      case 558:
        _struct._unique_message_item_558 = value;
        break;
      case 559:
        _struct._unique_message_item_559 = value;
        break;
      case 560:
        _struct._unique_message_item_560 = value;
        break;
      case 561:
        _struct._unique_message_item_561 = value;
        break;
      case 562:
        _struct._unique_message_item_562 = value;
        break;
      case 563:
        _struct._unique_message_item_563 = value;
        break;
      case 564:
        _struct._unique_message_item_564 = value;
        break;
      case 565:
        _struct._unique_message_item_565 = value;
        break;
      case 566:
        _struct._unique_message_item_566 = value;
        break;
      case 567:
        _struct._unique_message_item_567 = value;
        break;
      case 568:
        _struct._unique_message_item_568 = value;
        break;
      case 569:
        _struct._unique_message_item_569 = value;
        break;
      case 570:
        _struct._unique_message_item_570 = value;
        break;
      case 571:
        _struct._unique_message_item_571 = value;
        break;
      case 572:
        _struct._unique_message_item_572 = value;
        break;
      case 573:
        _struct._unique_message_item_573 = value;
        break;
      case 574:
        _struct._unique_message_item_574 = value;
        break;
      case 575:
        _struct._unique_message_item_575 = value;
        break;
      case 576:
        _struct._unique_message_item_576 = value;
        break;
      case 577:
        _struct._unique_message_item_577 = value;
        break;
      case 578:
        _struct._unique_message_item_578 = value;
        break;
      case 579:
        _struct._unique_message_item_579 = value;
        break;
      case 580:
        _struct._unique_message_item_580 = value;
        break;
      case 581:
        _struct._unique_message_item_581 = value;
        break;
      case 582:
        _struct._unique_message_item_582 = value;
        break;
      case 583:
        _struct._unique_message_item_583 = value;
        break;
      case 584:
        _struct._unique_message_item_584 = value;
        break;
      case 585:
        _struct._unique_message_item_585 = value;
        break;
      case 586:
        _struct._unique_message_item_586 = value;
        break;
      case 587:
        _struct._unique_message_item_587 = value;
        break;
      case 588:
        _struct._unique_message_item_588 = value;
        break;
      case 589:
        _struct._unique_message_item_589 = value;
        break;
      case 590:
        _struct._unique_message_item_590 = value;
        break;
      case 591:
        _struct._unique_message_item_591 = value;
        break;
      case 592:
        _struct._unique_message_item_592 = value;
        break;
      case 593:
        _struct._unique_message_item_593 = value;
        break;
      case 594:
        _struct._unique_message_item_594 = value;
        break;
      case 595:
        _struct._unique_message_item_595 = value;
        break;
      case 596:
        _struct._unique_message_item_596 = value;
        break;
      case 597:
        _struct._unique_message_item_597 = value;
        break;
      case 598:
        _struct._unique_message_item_598 = value;
        break;
      case 599:
        _struct._unique_message_item_599 = value;
        break;
      case 600:
        _struct._unique_message_item_600 = value;
        break;
      case 601:
        _struct._unique_message_item_601 = value;
        break;
      case 602:
        _struct._unique_message_item_602 = value;
        break;
      case 603:
        _struct._unique_message_item_603 = value;
        break;
      case 604:
        _struct._unique_message_item_604 = value;
        break;
      case 605:
        _struct._unique_message_item_605 = value;
        break;
      case 606:
        _struct._unique_message_item_606 = value;
        break;
      case 607:
        _struct._unique_message_item_607 = value;
        break;
      case 608:
        _struct._unique_message_item_608 = value;
        break;
      case 609:
        _struct._unique_message_item_609 = value;
        break;
      case 610:
        _struct._unique_message_item_610 = value;
        break;
      case 611:
        _struct._unique_message_item_611 = value;
        break;
      case 612:
        _struct._unique_message_item_612 = value;
        break;
      case 613:
        _struct._unique_message_item_613 = value;
        break;
      case 614:
        _struct._unique_message_item_614 = value;
        break;
      case 615:
        _struct._unique_message_item_615 = value;
        break;
      case 616:
        _struct._unique_message_item_616 = value;
        break;
      case 617:
        _struct._unique_message_item_617 = value;
        break;
      case 618:
        _struct._unique_message_item_618 = value;
        break;
      case 619:
        _struct._unique_message_item_619 = value;
        break;
      case 620:
        _struct._unique_message_item_620 = value;
        break;
      case 621:
        _struct._unique_message_item_621 = value;
        break;
      case 622:
        _struct._unique_message_item_622 = value;
        break;
      case 623:
        _struct._unique_message_item_623 = value;
        break;
      case 624:
        _struct._unique_message_item_624 = value;
        break;
      case 625:
        _struct._unique_message_item_625 = value;
        break;
      case 626:
        _struct._unique_message_item_626 = value;
        break;
      case 627:
        _struct._unique_message_item_627 = value;
        break;
      case 628:
        _struct._unique_message_item_628 = value;
        break;
      case 629:
        _struct._unique_message_item_629 = value;
        break;
      case 630:
        _struct._unique_message_item_630 = value;
        break;
      case 631:
        _struct._unique_message_item_631 = value;
        break;
      case 632:
        _struct._unique_message_item_632 = value;
        break;
      case 633:
        _struct._unique_message_item_633 = value;
        break;
      case 634:
        _struct._unique_message_item_634 = value;
        break;
      case 635:
        _struct._unique_message_item_635 = value;
        break;
      case 636:
        _struct._unique_message_item_636 = value;
        break;
      case 637:
        _struct._unique_message_item_637 = value;
        break;
      case 638:
        _struct._unique_message_item_638 = value;
        break;
      case 639:
        _struct._unique_message_item_639 = value;
        break;
      case 640:
        _struct._unique_message_item_640 = value;
        break;
      case 641:
        _struct._unique_message_item_641 = value;
        break;
      case 642:
        _struct._unique_message_item_642 = value;
        break;
      case 643:
        _struct._unique_message_item_643 = value;
        break;
      case 644:
        _struct._unique_message_item_644 = value;
        break;
      case 645:
        _struct._unique_message_item_645 = value;
        break;
      case 646:
        _struct._unique_message_item_646 = value;
        break;
      case 647:
        _struct._unique_message_item_647 = value;
        break;
      case 648:
        _struct._unique_message_item_648 = value;
        break;
      case 649:
        _struct._unique_message_item_649 = value;
        break;
      case 650:
        _struct._unique_message_item_650 = value;
        break;
      case 651:
        _struct._unique_message_item_651 = value;
        break;
      case 652:
        _struct._unique_message_item_652 = value;
        break;
      case 653:
        _struct._unique_message_item_653 = value;
        break;
      case 654:
        _struct._unique_message_item_654 = value;
        break;
      case 655:
        _struct._unique_message_item_655 = value;
        break;
      case 656:
        _struct._unique_message_item_656 = value;
        break;
      case 657:
        _struct._unique_message_item_657 = value;
        break;
      case 658:
        _struct._unique_message_item_658 = value;
        break;
      case 659:
        _struct._unique_message_item_659 = value;
        break;
      case 660:
        _struct._unique_message_item_660 = value;
        break;
      case 661:
        _struct._unique_message_item_661 = value;
        break;
      case 662:
        _struct._unique_message_item_662 = value;
        break;
      case 663:
        _struct._unique_message_item_663 = value;
        break;
      case 664:
        _struct._unique_message_item_664 = value;
        break;
      case 665:
        _struct._unique_message_item_665 = value;
        break;
      case 666:
        _struct._unique_message_item_666 = value;
        break;
      case 667:
        _struct._unique_message_item_667 = value;
        break;
      case 668:
        _struct._unique_message_item_668 = value;
        break;
      case 669:
        _struct._unique_message_item_669 = value;
        break;
      case 670:
        _struct._unique_message_item_670 = value;
        break;
      case 671:
        _struct._unique_message_item_671 = value;
        break;
      case 672:
        _struct._unique_message_item_672 = value;
        break;
      case 673:
        _struct._unique_message_item_673 = value;
        break;
      case 674:
        _struct._unique_message_item_674 = value;
        break;
      case 675:
        _struct._unique_message_item_675 = value;
        break;
      case 676:
        _struct._unique_message_item_676 = value;
        break;
      case 677:
        _struct._unique_message_item_677 = value;
        break;
      case 678:
        _struct._unique_message_item_678 = value;
        break;
      case 679:
        _struct._unique_message_item_679 = value;
        break;
      case 680:
        _struct._unique_message_item_680 = value;
        break;
      case 681:
        _struct._unique_message_item_681 = value;
        break;
      case 682:
        _struct._unique_message_item_682 = value;
        break;
      case 683:
        _struct._unique_message_item_683 = value;
        break;
      case 684:
        _struct._unique_message_item_684 = value;
        break;
      case 685:
        _struct._unique_message_item_685 = value;
        break;
      case 686:
        _struct._unique_message_item_686 = value;
        break;
      case 687:
        _struct._unique_message_item_687 = value;
        break;
      case 688:
        _struct._unique_message_item_688 = value;
        break;
      case 689:
        _struct._unique_message_item_689 = value;
        break;
      case 690:
        _struct._unique_message_item_690 = value;
        break;
      case 691:
        _struct._unique_message_item_691 = value;
        break;
      case 692:
        _struct._unique_message_item_692 = value;
        break;
      case 693:
        _struct._unique_message_item_693 = value;
        break;
      case 694:
        _struct._unique_message_item_694 = value;
        break;
      case 695:
        _struct._unique_message_item_695 = value;
        break;
      case 696:
        _struct._unique_message_item_696 = value;
        break;
      case 697:
        _struct._unique_message_item_697 = value;
        break;
      case 698:
        _struct._unique_message_item_698 = value;
        break;
      case 699:
        _struct._unique_message_item_699 = value;
        break;
      case 700:
        _struct._unique_message_item_700 = value;
        break;
      case 701:
        _struct._unique_message_item_701 = value;
        break;
      case 702:
        _struct._unique_message_item_702 = value;
        break;
      case 703:
        _struct._unique_message_item_703 = value;
        break;
      case 704:
        _struct._unique_message_item_704 = value;
        break;
      case 705:
        _struct._unique_message_item_705 = value;
        break;
      case 706:
        _struct._unique_message_item_706 = value;
        break;
      case 707:
        _struct._unique_message_item_707 = value;
        break;
      case 708:
        _struct._unique_message_item_708 = value;
        break;
      case 709:
        _struct._unique_message_item_709 = value;
        break;
      case 710:
        _struct._unique_message_item_710 = value;
        break;
      case 711:
        _struct._unique_message_item_711 = value;
        break;
      case 712:
        _struct._unique_message_item_712 = value;
        break;
      case 713:
        _struct._unique_message_item_713 = value;
        break;
      case 714:
        _struct._unique_message_item_714 = value;
        break;
      case 715:
        _struct._unique_message_item_715 = value;
        break;
      case 716:
        _struct._unique_message_item_716 = value;
        break;
      case 717:
        _struct._unique_message_item_717 = value;
        break;
      case 718:
        _struct._unique_message_item_718 = value;
        break;
      case 719:
        _struct._unique_message_item_719 = value;
        break;
      case 720:
        _struct._unique_message_item_720 = value;
        break;
      case 721:
        _struct._unique_message_item_721 = value;
        break;
      case 722:
        _struct._unique_message_item_722 = value;
        break;
      case 723:
        _struct._unique_message_item_723 = value;
        break;
      case 724:
        _struct._unique_message_item_724 = value;
        break;
      case 725:
        _struct._unique_message_item_725 = value;
        break;
      case 726:
        _struct._unique_message_item_726 = value;
        break;
      case 727:
        _struct._unique_message_item_727 = value;
        break;
      case 728:
        _struct._unique_message_item_728 = value;
        break;
      case 729:
        _struct._unique_message_item_729 = value;
        break;
      case 730:
        _struct._unique_message_item_730 = value;
        break;
      case 731:
        _struct._unique_message_item_731 = value;
        break;
      case 732:
        _struct._unique_message_item_732 = value;
        break;
      case 733:
        _struct._unique_message_item_733 = value;
        break;
      case 734:
        _struct._unique_message_item_734 = value;
        break;
      case 735:
        _struct._unique_message_item_735 = value;
        break;
      case 736:
        _struct._unique_message_item_736 = value;
        break;
      case 737:
        _struct._unique_message_item_737 = value;
        break;
      case 738:
        _struct._unique_message_item_738 = value;
        break;
      case 739:
        _struct._unique_message_item_739 = value;
        break;
      case 740:
        _struct._unique_message_item_740 = value;
        break;
      case 741:
        _struct._unique_message_item_741 = value;
        break;
      case 742:
        _struct._unique_message_item_742 = value;
        break;
      case 743:
        _struct._unique_message_item_743 = value;
        break;
      case 744:
        _struct._unique_message_item_744 = value;
        break;
      case 745:
        _struct._unique_message_item_745 = value;
        break;
      case 746:
        _struct._unique_message_item_746 = value;
        break;
      case 747:
        _struct._unique_message_item_747 = value;
        break;
      case 748:
        _struct._unique_message_item_748 = value;
        break;
      case 749:
        _struct._unique_message_item_749 = value;
        break;
      case 750:
        _struct._unique_message_item_750 = value;
        break;
      case 751:
        _struct._unique_message_item_751 = value;
        break;
      case 752:
        _struct._unique_message_item_752 = value;
        break;
      case 753:
        _struct._unique_message_item_753 = value;
        break;
      case 754:
        _struct._unique_message_item_754 = value;
        break;
      case 755:
        _struct._unique_message_item_755 = value;
        break;
      case 756:
        _struct._unique_message_item_756 = value;
        break;
      case 757:
        _struct._unique_message_item_757 = value;
        break;
      case 758:
        _struct._unique_message_item_758 = value;
        break;
      case 759:
        _struct._unique_message_item_759 = value;
        break;
      case 760:
        _struct._unique_message_item_760 = value;
        break;
      case 761:
        _struct._unique_message_item_761 = value;
        break;
      case 762:
        _struct._unique_message_item_762 = value;
        break;
      case 763:
        _struct._unique_message_item_763 = value;
        break;
      case 764:
        _struct._unique_message_item_764 = value;
        break;
      case 765:
        _struct._unique_message_item_765 = value;
        break;
      case 766:
        _struct._unique_message_item_766 = value;
        break;
      case 767:
        _struct._unique_message_item_767 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `file` in struct `rcutils_error_state_t`.
class ArrayHelper_rcutils_error_state_t_file_level0 {
  final rcutils_error_state_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_rcutils_error_state_t_file_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_file_item_0;
      case 1:
        return _struct._unique_file_item_1;
      case 2:
        return _struct._unique_file_item_2;
      case 3:
        return _struct._unique_file_item_3;
      case 4:
        return _struct._unique_file_item_4;
      case 5:
        return _struct._unique_file_item_5;
      case 6:
        return _struct._unique_file_item_6;
      case 7:
        return _struct._unique_file_item_7;
      case 8:
        return _struct._unique_file_item_8;
      case 9:
        return _struct._unique_file_item_9;
      case 10:
        return _struct._unique_file_item_10;
      case 11:
        return _struct._unique_file_item_11;
      case 12:
        return _struct._unique_file_item_12;
      case 13:
        return _struct._unique_file_item_13;
      case 14:
        return _struct._unique_file_item_14;
      case 15:
        return _struct._unique_file_item_15;
      case 16:
        return _struct._unique_file_item_16;
      case 17:
        return _struct._unique_file_item_17;
      case 18:
        return _struct._unique_file_item_18;
      case 19:
        return _struct._unique_file_item_19;
      case 20:
        return _struct._unique_file_item_20;
      case 21:
        return _struct._unique_file_item_21;
      case 22:
        return _struct._unique_file_item_22;
      case 23:
        return _struct._unique_file_item_23;
      case 24:
        return _struct._unique_file_item_24;
      case 25:
        return _struct._unique_file_item_25;
      case 26:
        return _struct._unique_file_item_26;
      case 27:
        return _struct._unique_file_item_27;
      case 28:
        return _struct._unique_file_item_28;
      case 29:
        return _struct._unique_file_item_29;
      case 30:
        return _struct._unique_file_item_30;
      case 31:
        return _struct._unique_file_item_31;
      case 32:
        return _struct._unique_file_item_32;
      case 33:
        return _struct._unique_file_item_33;
      case 34:
        return _struct._unique_file_item_34;
      case 35:
        return _struct._unique_file_item_35;
      case 36:
        return _struct._unique_file_item_36;
      case 37:
        return _struct._unique_file_item_37;
      case 38:
        return _struct._unique_file_item_38;
      case 39:
        return _struct._unique_file_item_39;
      case 40:
        return _struct._unique_file_item_40;
      case 41:
        return _struct._unique_file_item_41;
      case 42:
        return _struct._unique_file_item_42;
      case 43:
        return _struct._unique_file_item_43;
      case 44:
        return _struct._unique_file_item_44;
      case 45:
        return _struct._unique_file_item_45;
      case 46:
        return _struct._unique_file_item_46;
      case 47:
        return _struct._unique_file_item_47;
      case 48:
        return _struct._unique_file_item_48;
      case 49:
        return _struct._unique_file_item_49;
      case 50:
        return _struct._unique_file_item_50;
      case 51:
        return _struct._unique_file_item_51;
      case 52:
        return _struct._unique_file_item_52;
      case 53:
        return _struct._unique_file_item_53;
      case 54:
        return _struct._unique_file_item_54;
      case 55:
        return _struct._unique_file_item_55;
      case 56:
        return _struct._unique_file_item_56;
      case 57:
        return _struct._unique_file_item_57;
      case 58:
        return _struct._unique_file_item_58;
      case 59:
        return _struct._unique_file_item_59;
      case 60:
        return _struct._unique_file_item_60;
      case 61:
        return _struct._unique_file_item_61;
      case 62:
        return _struct._unique_file_item_62;
      case 63:
        return _struct._unique_file_item_63;
      case 64:
        return _struct._unique_file_item_64;
      case 65:
        return _struct._unique_file_item_65;
      case 66:
        return _struct._unique_file_item_66;
      case 67:
        return _struct._unique_file_item_67;
      case 68:
        return _struct._unique_file_item_68;
      case 69:
        return _struct._unique_file_item_69;
      case 70:
        return _struct._unique_file_item_70;
      case 71:
        return _struct._unique_file_item_71;
      case 72:
        return _struct._unique_file_item_72;
      case 73:
        return _struct._unique_file_item_73;
      case 74:
        return _struct._unique_file_item_74;
      case 75:
        return _struct._unique_file_item_75;
      case 76:
        return _struct._unique_file_item_76;
      case 77:
        return _struct._unique_file_item_77;
      case 78:
        return _struct._unique_file_item_78;
      case 79:
        return _struct._unique_file_item_79;
      case 80:
        return _struct._unique_file_item_80;
      case 81:
        return _struct._unique_file_item_81;
      case 82:
        return _struct._unique_file_item_82;
      case 83:
        return _struct._unique_file_item_83;
      case 84:
        return _struct._unique_file_item_84;
      case 85:
        return _struct._unique_file_item_85;
      case 86:
        return _struct._unique_file_item_86;
      case 87:
        return _struct._unique_file_item_87;
      case 88:
        return _struct._unique_file_item_88;
      case 89:
        return _struct._unique_file_item_89;
      case 90:
        return _struct._unique_file_item_90;
      case 91:
        return _struct._unique_file_item_91;
      case 92:
        return _struct._unique_file_item_92;
      case 93:
        return _struct._unique_file_item_93;
      case 94:
        return _struct._unique_file_item_94;
      case 95:
        return _struct._unique_file_item_95;
      case 96:
        return _struct._unique_file_item_96;
      case 97:
        return _struct._unique_file_item_97;
      case 98:
        return _struct._unique_file_item_98;
      case 99:
        return _struct._unique_file_item_99;
      case 100:
        return _struct._unique_file_item_100;
      case 101:
        return _struct._unique_file_item_101;
      case 102:
        return _struct._unique_file_item_102;
      case 103:
        return _struct._unique_file_item_103;
      case 104:
        return _struct._unique_file_item_104;
      case 105:
        return _struct._unique_file_item_105;
      case 106:
        return _struct._unique_file_item_106;
      case 107:
        return _struct._unique_file_item_107;
      case 108:
        return _struct._unique_file_item_108;
      case 109:
        return _struct._unique_file_item_109;
      case 110:
        return _struct._unique_file_item_110;
      case 111:
        return _struct._unique_file_item_111;
      case 112:
        return _struct._unique_file_item_112;
      case 113:
        return _struct._unique_file_item_113;
      case 114:
        return _struct._unique_file_item_114;
      case 115:
        return _struct._unique_file_item_115;
      case 116:
        return _struct._unique_file_item_116;
      case 117:
        return _struct._unique_file_item_117;
      case 118:
        return _struct._unique_file_item_118;
      case 119:
        return _struct._unique_file_item_119;
      case 120:
        return _struct._unique_file_item_120;
      case 121:
        return _struct._unique_file_item_121;
      case 122:
        return _struct._unique_file_item_122;
      case 123:
        return _struct._unique_file_item_123;
      case 124:
        return _struct._unique_file_item_124;
      case 125:
        return _struct._unique_file_item_125;
      case 126:
        return _struct._unique_file_item_126;
      case 127:
        return _struct._unique_file_item_127;
      case 128:
        return _struct._unique_file_item_128;
      case 129:
        return _struct._unique_file_item_129;
      case 130:
        return _struct._unique_file_item_130;
      case 131:
        return _struct._unique_file_item_131;
      case 132:
        return _struct._unique_file_item_132;
      case 133:
        return _struct._unique_file_item_133;
      case 134:
        return _struct._unique_file_item_134;
      case 135:
        return _struct._unique_file_item_135;
      case 136:
        return _struct._unique_file_item_136;
      case 137:
        return _struct._unique_file_item_137;
      case 138:
        return _struct._unique_file_item_138;
      case 139:
        return _struct._unique_file_item_139;
      case 140:
        return _struct._unique_file_item_140;
      case 141:
        return _struct._unique_file_item_141;
      case 142:
        return _struct._unique_file_item_142;
      case 143:
        return _struct._unique_file_item_143;
      case 144:
        return _struct._unique_file_item_144;
      case 145:
        return _struct._unique_file_item_145;
      case 146:
        return _struct._unique_file_item_146;
      case 147:
        return _struct._unique_file_item_147;
      case 148:
        return _struct._unique_file_item_148;
      case 149:
        return _struct._unique_file_item_149;
      case 150:
        return _struct._unique_file_item_150;
      case 151:
        return _struct._unique_file_item_151;
      case 152:
        return _struct._unique_file_item_152;
      case 153:
        return _struct._unique_file_item_153;
      case 154:
        return _struct._unique_file_item_154;
      case 155:
        return _struct._unique_file_item_155;
      case 156:
        return _struct._unique_file_item_156;
      case 157:
        return _struct._unique_file_item_157;
      case 158:
        return _struct._unique_file_item_158;
      case 159:
        return _struct._unique_file_item_159;
      case 160:
        return _struct._unique_file_item_160;
      case 161:
        return _struct._unique_file_item_161;
      case 162:
        return _struct._unique_file_item_162;
      case 163:
        return _struct._unique_file_item_163;
      case 164:
        return _struct._unique_file_item_164;
      case 165:
        return _struct._unique_file_item_165;
      case 166:
        return _struct._unique_file_item_166;
      case 167:
        return _struct._unique_file_item_167;
      case 168:
        return _struct._unique_file_item_168;
      case 169:
        return _struct._unique_file_item_169;
      case 170:
        return _struct._unique_file_item_170;
      case 171:
        return _struct._unique_file_item_171;
      case 172:
        return _struct._unique_file_item_172;
      case 173:
        return _struct._unique_file_item_173;
      case 174:
        return _struct._unique_file_item_174;
      case 175:
        return _struct._unique_file_item_175;
      case 176:
        return _struct._unique_file_item_176;
      case 177:
        return _struct._unique_file_item_177;
      case 178:
        return _struct._unique_file_item_178;
      case 179:
        return _struct._unique_file_item_179;
      case 180:
        return _struct._unique_file_item_180;
      case 181:
        return _struct._unique_file_item_181;
      case 182:
        return _struct._unique_file_item_182;
      case 183:
        return _struct._unique_file_item_183;
      case 184:
        return _struct._unique_file_item_184;
      case 185:
        return _struct._unique_file_item_185;
      case 186:
        return _struct._unique_file_item_186;
      case 187:
        return _struct._unique_file_item_187;
      case 188:
        return _struct._unique_file_item_188;
      case 189:
        return _struct._unique_file_item_189;
      case 190:
        return _struct._unique_file_item_190;
      case 191:
        return _struct._unique_file_item_191;
      case 192:
        return _struct._unique_file_item_192;
      case 193:
        return _struct._unique_file_item_193;
      case 194:
        return _struct._unique_file_item_194;
      case 195:
        return _struct._unique_file_item_195;
      case 196:
        return _struct._unique_file_item_196;
      case 197:
        return _struct._unique_file_item_197;
      case 198:
        return _struct._unique_file_item_198;
      case 199:
        return _struct._unique_file_item_199;
      case 200:
        return _struct._unique_file_item_200;
      case 201:
        return _struct._unique_file_item_201;
      case 202:
        return _struct._unique_file_item_202;
      case 203:
        return _struct._unique_file_item_203;
      case 204:
        return _struct._unique_file_item_204;
      case 205:
        return _struct._unique_file_item_205;
      case 206:
        return _struct._unique_file_item_206;
      case 207:
        return _struct._unique_file_item_207;
      case 208:
        return _struct._unique_file_item_208;
      case 209:
        return _struct._unique_file_item_209;
      case 210:
        return _struct._unique_file_item_210;
      case 211:
        return _struct._unique_file_item_211;
      case 212:
        return _struct._unique_file_item_212;
      case 213:
        return _struct._unique_file_item_213;
      case 214:
        return _struct._unique_file_item_214;
      case 215:
        return _struct._unique_file_item_215;
      case 216:
        return _struct._unique_file_item_216;
      case 217:
        return _struct._unique_file_item_217;
      case 218:
        return _struct._unique_file_item_218;
      case 219:
        return _struct._unique_file_item_219;
      case 220:
        return _struct._unique_file_item_220;
      case 221:
        return _struct._unique_file_item_221;
      case 222:
        return _struct._unique_file_item_222;
      case 223:
        return _struct._unique_file_item_223;
      case 224:
        return _struct._unique_file_item_224;
      case 225:
        return _struct._unique_file_item_225;
      case 226:
        return _struct._unique_file_item_226;
      case 227:
        return _struct._unique_file_item_227;
      case 228:
        return _struct._unique_file_item_228;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_file_item_0 = value;
        break;
      case 1:
        _struct._unique_file_item_1 = value;
        break;
      case 2:
        _struct._unique_file_item_2 = value;
        break;
      case 3:
        _struct._unique_file_item_3 = value;
        break;
      case 4:
        _struct._unique_file_item_4 = value;
        break;
      case 5:
        _struct._unique_file_item_5 = value;
        break;
      case 6:
        _struct._unique_file_item_6 = value;
        break;
      case 7:
        _struct._unique_file_item_7 = value;
        break;
      case 8:
        _struct._unique_file_item_8 = value;
        break;
      case 9:
        _struct._unique_file_item_9 = value;
        break;
      case 10:
        _struct._unique_file_item_10 = value;
        break;
      case 11:
        _struct._unique_file_item_11 = value;
        break;
      case 12:
        _struct._unique_file_item_12 = value;
        break;
      case 13:
        _struct._unique_file_item_13 = value;
        break;
      case 14:
        _struct._unique_file_item_14 = value;
        break;
      case 15:
        _struct._unique_file_item_15 = value;
        break;
      case 16:
        _struct._unique_file_item_16 = value;
        break;
      case 17:
        _struct._unique_file_item_17 = value;
        break;
      case 18:
        _struct._unique_file_item_18 = value;
        break;
      case 19:
        _struct._unique_file_item_19 = value;
        break;
      case 20:
        _struct._unique_file_item_20 = value;
        break;
      case 21:
        _struct._unique_file_item_21 = value;
        break;
      case 22:
        _struct._unique_file_item_22 = value;
        break;
      case 23:
        _struct._unique_file_item_23 = value;
        break;
      case 24:
        _struct._unique_file_item_24 = value;
        break;
      case 25:
        _struct._unique_file_item_25 = value;
        break;
      case 26:
        _struct._unique_file_item_26 = value;
        break;
      case 27:
        _struct._unique_file_item_27 = value;
        break;
      case 28:
        _struct._unique_file_item_28 = value;
        break;
      case 29:
        _struct._unique_file_item_29 = value;
        break;
      case 30:
        _struct._unique_file_item_30 = value;
        break;
      case 31:
        _struct._unique_file_item_31 = value;
        break;
      case 32:
        _struct._unique_file_item_32 = value;
        break;
      case 33:
        _struct._unique_file_item_33 = value;
        break;
      case 34:
        _struct._unique_file_item_34 = value;
        break;
      case 35:
        _struct._unique_file_item_35 = value;
        break;
      case 36:
        _struct._unique_file_item_36 = value;
        break;
      case 37:
        _struct._unique_file_item_37 = value;
        break;
      case 38:
        _struct._unique_file_item_38 = value;
        break;
      case 39:
        _struct._unique_file_item_39 = value;
        break;
      case 40:
        _struct._unique_file_item_40 = value;
        break;
      case 41:
        _struct._unique_file_item_41 = value;
        break;
      case 42:
        _struct._unique_file_item_42 = value;
        break;
      case 43:
        _struct._unique_file_item_43 = value;
        break;
      case 44:
        _struct._unique_file_item_44 = value;
        break;
      case 45:
        _struct._unique_file_item_45 = value;
        break;
      case 46:
        _struct._unique_file_item_46 = value;
        break;
      case 47:
        _struct._unique_file_item_47 = value;
        break;
      case 48:
        _struct._unique_file_item_48 = value;
        break;
      case 49:
        _struct._unique_file_item_49 = value;
        break;
      case 50:
        _struct._unique_file_item_50 = value;
        break;
      case 51:
        _struct._unique_file_item_51 = value;
        break;
      case 52:
        _struct._unique_file_item_52 = value;
        break;
      case 53:
        _struct._unique_file_item_53 = value;
        break;
      case 54:
        _struct._unique_file_item_54 = value;
        break;
      case 55:
        _struct._unique_file_item_55 = value;
        break;
      case 56:
        _struct._unique_file_item_56 = value;
        break;
      case 57:
        _struct._unique_file_item_57 = value;
        break;
      case 58:
        _struct._unique_file_item_58 = value;
        break;
      case 59:
        _struct._unique_file_item_59 = value;
        break;
      case 60:
        _struct._unique_file_item_60 = value;
        break;
      case 61:
        _struct._unique_file_item_61 = value;
        break;
      case 62:
        _struct._unique_file_item_62 = value;
        break;
      case 63:
        _struct._unique_file_item_63 = value;
        break;
      case 64:
        _struct._unique_file_item_64 = value;
        break;
      case 65:
        _struct._unique_file_item_65 = value;
        break;
      case 66:
        _struct._unique_file_item_66 = value;
        break;
      case 67:
        _struct._unique_file_item_67 = value;
        break;
      case 68:
        _struct._unique_file_item_68 = value;
        break;
      case 69:
        _struct._unique_file_item_69 = value;
        break;
      case 70:
        _struct._unique_file_item_70 = value;
        break;
      case 71:
        _struct._unique_file_item_71 = value;
        break;
      case 72:
        _struct._unique_file_item_72 = value;
        break;
      case 73:
        _struct._unique_file_item_73 = value;
        break;
      case 74:
        _struct._unique_file_item_74 = value;
        break;
      case 75:
        _struct._unique_file_item_75 = value;
        break;
      case 76:
        _struct._unique_file_item_76 = value;
        break;
      case 77:
        _struct._unique_file_item_77 = value;
        break;
      case 78:
        _struct._unique_file_item_78 = value;
        break;
      case 79:
        _struct._unique_file_item_79 = value;
        break;
      case 80:
        _struct._unique_file_item_80 = value;
        break;
      case 81:
        _struct._unique_file_item_81 = value;
        break;
      case 82:
        _struct._unique_file_item_82 = value;
        break;
      case 83:
        _struct._unique_file_item_83 = value;
        break;
      case 84:
        _struct._unique_file_item_84 = value;
        break;
      case 85:
        _struct._unique_file_item_85 = value;
        break;
      case 86:
        _struct._unique_file_item_86 = value;
        break;
      case 87:
        _struct._unique_file_item_87 = value;
        break;
      case 88:
        _struct._unique_file_item_88 = value;
        break;
      case 89:
        _struct._unique_file_item_89 = value;
        break;
      case 90:
        _struct._unique_file_item_90 = value;
        break;
      case 91:
        _struct._unique_file_item_91 = value;
        break;
      case 92:
        _struct._unique_file_item_92 = value;
        break;
      case 93:
        _struct._unique_file_item_93 = value;
        break;
      case 94:
        _struct._unique_file_item_94 = value;
        break;
      case 95:
        _struct._unique_file_item_95 = value;
        break;
      case 96:
        _struct._unique_file_item_96 = value;
        break;
      case 97:
        _struct._unique_file_item_97 = value;
        break;
      case 98:
        _struct._unique_file_item_98 = value;
        break;
      case 99:
        _struct._unique_file_item_99 = value;
        break;
      case 100:
        _struct._unique_file_item_100 = value;
        break;
      case 101:
        _struct._unique_file_item_101 = value;
        break;
      case 102:
        _struct._unique_file_item_102 = value;
        break;
      case 103:
        _struct._unique_file_item_103 = value;
        break;
      case 104:
        _struct._unique_file_item_104 = value;
        break;
      case 105:
        _struct._unique_file_item_105 = value;
        break;
      case 106:
        _struct._unique_file_item_106 = value;
        break;
      case 107:
        _struct._unique_file_item_107 = value;
        break;
      case 108:
        _struct._unique_file_item_108 = value;
        break;
      case 109:
        _struct._unique_file_item_109 = value;
        break;
      case 110:
        _struct._unique_file_item_110 = value;
        break;
      case 111:
        _struct._unique_file_item_111 = value;
        break;
      case 112:
        _struct._unique_file_item_112 = value;
        break;
      case 113:
        _struct._unique_file_item_113 = value;
        break;
      case 114:
        _struct._unique_file_item_114 = value;
        break;
      case 115:
        _struct._unique_file_item_115 = value;
        break;
      case 116:
        _struct._unique_file_item_116 = value;
        break;
      case 117:
        _struct._unique_file_item_117 = value;
        break;
      case 118:
        _struct._unique_file_item_118 = value;
        break;
      case 119:
        _struct._unique_file_item_119 = value;
        break;
      case 120:
        _struct._unique_file_item_120 = value;
        break;
      case 121:
        _struct._unique_file_item_121 = value;
        break;
      case 122:
        _struct._unique_file_item_122 = value;
        break;
      case 123:
        _struct._unique_file_item_123 = value;
        break;
      case 124:
        _struct._unique_file_item_124 = value;
        break;
      case 125:
        _struct._unique_file_item_125 = value;
        break;
      case 126:
        _struct._unique_file_item_126 = value;
        break;
      case 127:
        _struct._unique_file_item_127 = value;
        break;
      case 128:
        _struct._unique_file_item_128 = value;
        break;
      case 129:
        _struct._unique_file_item_129 = value;
        break;
      case 130:
        _struct._unique_file_item_130 = value;
        break;
      case 131:
        _struct._unique_file_item_131 = value;
        break;
      case 132:
        _struct._unique_file_item_132 = value;
        break;
      case 133:
        _struct._unique_file_item_133 = value;
        break;
      case 134:
        _struct._unique_file_item_134 = value;
        break;
      case 135:
        _struct._unique_file_item_135 = value;
        break;
      case 136:
        _struct._unique_file_item_136 = value;
        break;
      case 137:
        _struct._unique_file_item_137 = value;
        break;
      case 138:
        _struct._unique_file_item_138 = value;
        break;
      case 139:
        _struct._unique_file_item_139 = value;
        break;
      case 140:
        _struct._unique_file_item_140 = value;
        break;
      case 141:
        _struct._unique_file_item_141 = value;
        break;
      case 142:
        _struct._unique_file_item_142 = value;
        break;
      case 143:
        _struct._unique_file_item_143 = value;
        break;
      case 144:
        _struct._unique_file_item_144 = value;
        break;
      case 145:
        _struct._unique_file_item_145 = value;
        break;
      case 146:
        _struct._unique_file_item_146 = value;
        break;
      case 147:
        _struct._unique_file_item_147 = value;
        break;
      case 148:
        _struct._unique_file_item_148 = value;
        break;
      case 149:
        _struct._unique_file_item_149 = value;
        break;
      case 150:
        _struct._unique_file_item_150 = value;
        break;
      case 151:
        _struct._unique_file_item_151 = value;
        break;
      case 152:
        _struct._unique_file_item_152 = value;
        break;
      case 153:
        _struct._unique_file_item_153 = value;
        break;
      case 154:
        _struct._unique_file_item_154 = value;
        break;
      case 155:
        _struct._unique_file_item_155 = value;
        break;
      case 156:
        _struct._unique_file_item_156 = value;
        break;
      case 157:
        _struct._unique_file_item_157 = value;
        break;
      case 158:
        _struct._unique_file_item_158 = value;
        break;
      case 159:
        _struct._unique_file_item_159 = value;
        break;
      case 160:
        _struct._unique_file_item_160 = value;
        break;
      case 161:
        _struct._unique_file_item_161 = value;
        break;
      case 162:
        _struct._unique_file_item_162 = value;
        break;
      case 163:
        _struct._unique_file_item_163 = value;
        break;
      case 164:
        _struct._unique_file_item_164 = value;
        break;
      case 165:
        _struct._unique_file_item_165 = value;
        break;
      case 166:
        _struct._unique_file_item_166 = value;
        break;
      case 167:
        _struct._unique_file_item_167 = value;
        break;
      case 168:
        _struct._unique_file_item_168 = value;
        break;
      case 169:
        _struct._unique_file_item_169 = value;
        break;
      case 170:
        _struct._unique_file_item_170 = value;
        break;
      case 171:
        _struct._unique_file_item_171 = value;
        break;
      case 172:
        _struct._unique_file_item_172 = value;
        break;
      case 173:
        _struct._unique_file_item_173 = value;
        break;
      case 174:
        _struct._unique_file_item_174 = value;
        break;
      case 175:
        _struct._unique_file_item_175 = value;
        break;
      case 176:
        _struct._unique_file_item_176 = value;
        break;
      case 177:
        _struct._unique_file_item_177 = value;
        break;
      case 178:
        _struct._unique_file_item_178 = value;
        break;
      case 179:
        _struct._unique_file_item_179 = value;
        break;
      case 180:
        _struct._unique_file_item_180 = value;
        break;
      case 181:
        _struct._unique_file_item_181 = value;
        break;
      case 182:
        _struct._unique_file_item_182 = value;
        break;
      case 183:
        _struct._unique_file_item_183 = value;
        break;
      case 184:
        _struct._unique_file_item_184 = value;
        break;
      case 185:
        _struct._unique_file_item_185 = value;
        break;
      case 186:
        _struct._unique_file_item_186 = value;
        break;
      case 187:
        _struct._unique_file_item_187 = value;
        break;
      case 188:
        _struct._unique_file_item_188 = value;
        break;
      case 189:
        _struct._unique_file_item_189 = value;
        break;
      case 190:
        _struct._unique_file_item_190 = value;
        break;
      case 191:
        _struct._unique_file_item_191 = value;
        break;
      case 192:
        _struct._unique_file_item_192 = value;
        break;
      case 193:
        _struct._unique_file_item_193 = value;
        break;
      case 194:
        _struct._unique_file_item_194 = value;
        break;
      case 195:
        _struct._unique_file_item_195 = value;
        break;
      case 196:
        _struct._unique_file_item_196 = value;
        break;
      case 197:
        _struct._unique_file_item_197 = value;
        break;
      case 198:
        _struct._unique_file_item_198 = value;
        break;
      case 199:
        _struct._unique_file_item_199 = value;
        break;
      case 200:
        _struct._unique_file_item_200 = value;
        break;
      case 201:
        _struct._unique_file_item_201 = value;
        break;
      case 202:
        _struct._unique_file_item_202 = value;
        break;
      case 203:
        _struct._unique_file_item_203 = value;
        break;
      case 204:
        _struct._unique_file_item_204 = value;
        break;
      case 205:
        _struct._unique_file_item_205 = value;
        break;
      case 206:
        _struct._unique_file_item_206 = value;
        break;
      case 207:
        _struct._unique_file_item_207 = value;
        break;
      case 208:
        _struct._unique_file_item_208 = value;
        break;
      case 209:
        _struct._unique_file_item_209 = value;
        break;
      case 210:
        _struct._unique_file_item_210 = value;
        break;
      case 211:
        _struct._unique_file_item_211 = value;
        break;
      case 212:
        _struct._unique_file_item_212 = value;
        break;
      case 213:
        _struct._unique_file_item_213 = value;
        break;
      case 214:
        _struct._unique_file_item_214 = value;
        break;
      case 215:
        _struct._unique_file_item_215 = value;
        break;
      case 216:
        _struct._unique_file_item_216 = value;
        break;
      case 217:
        _struct._unique_file_item_217 = value;
        break;
      case 218:
        _struct._unique_file_item_218 = value;
        break;
      case 219:
        _struct._unique_file_item_219 = value;
        break;
      case 220:
        _struct._unique_file_item_220 = value;
        break;
      case 221:
        _struct._unique_file_item_221 = value;
        break;
      case 222:
        _struct._unique_file_item_222 = value;
        break;
      case 223:
        _struct._unique_file_item_223 = value;
        break;
      case 224:
        _struct._unique_file_item_224 = value;
        break;
      case 225:
        _struct._unique_file_item_225 = value;
        break;
      case 226:
        _struct._unique_file_item_226 = value;
        break;
      case 227:
        _struct._unique_file_item_227 = value;
        break;
      case 228:
        _struct._unique_file_item_228 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class rcutils_array_list_impl_t extends ffi.Struct {}

class rcutils_array_list_t extends ffi.Struct {
  external ffi.Pointer<rcutils_array_list_impl_t> impl;
}

class rcutils_char_array_t extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> buffer;

  /// if this is true, we may safely free/realloc the buffer as needed;
  /// otherwise we will leave the buffer alone and alloc new memory if
  /// more space is needed
  @ffi.Uint8()
  external int owns_buffer;

  @ffi.Uint64()
  external int buffer_length;

  @ffi.Uint64()
  external int buffer_capacity;

  external rcutils_allocator_t allocator;
}

class rcutils_hash_map_impl_t extends ffi.Struct {}

class rcutils_hash_map_t extends ffi.Struct {
  external ffi.Pointer<rcutils_hash_map_impl_t> impl;
}

class rcutils_string_array_t extends ffi.Struct {
  @ffi.Uint64()
  external int size;

  external ffi.Pointer<ffi.Pointer<ffi.Int8>> data;

  external rcutils_allocator_t allocator;
}

class rcutils_string_map_impl_t extends ffi.Struct {}

class rcutils_string_map_t extends ffi.Struct {
  external ffi.Pointer<rcutils_string_map_impl_t> impl;
}

class rcutils_uint8_array_t extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> buffer;

  @ffi.Uint64()
  external int buffer_length;

  @ffi.Uint64()
  external int buffer_capacity;

  external rcutils_allocator_t allocator;
}

/// /// The structure identifying the caller location in the source code.
class rcutils_log_location_t extends ffi.Struct {
  /// /// The name of the function containing the log call.
  external ffi.Pointer<ffi.Int8> function_name;

  /// /// The name of the source file containing the log call.
  external ffi.Pointer<ffi.Int8> file_name;

  /// /// The line number containing the log call.
  @ffi.Uint64()
  external int line_number;
}

/// /// The severity levels of log messages / loggers.
abstract class RCUTILS_LOG_SEVERITY {
  /// ///< The unset log level
  static const int RCUTILS_LOG_SEVERITY_UNSET = 0;

  /// ///< The debug log level
  static const int RCUTILS_LOG_SEVERITY_DEBUG = 10;

  /// ///< The info log level
  static const int RCUTILS_LOG_SEVERITY_INFO = 20;

  /// ///< The warn log level
  static const int RCUTILS_LOG_SEVERITY_WARN = 30;

  /// ///< The error log level
  static const int RCUTILS_LOG_SEVERITY_ERROR = 40;

  /// ///< The fatal log level
  static const int RCUTILS_LOG_SEVERITY_FATAL = 50;
}

/// /// Structure which encapsulates an rmw node
class rmw_node_t extends ffi.Struct {
  /// /// Name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Type erased pointer to this node's data
  external ffi.Pointer<ffi.Void> data;

  /// /// A concise name of this rmw node for identification
  external ffi.Pointer<ffi.Int8> name;

  /// /// The namespace of this rmw node
  external ffi.Pointer<ffi.Int8> namespace_;

  /// /// Context information about node's init specific information
  external ffi.Pointer<rmw_context_t> context;
}

/// /// Endpoint enumeration type
abstract class rmw_endpoint_type_t {
  /// /// Endpoint type has not yet been set
  static const int RMW_ENDPOINT_INVALID = 0;

  /// /// Creates and publishes messages to the ROS topic
  static const int RMW_ENDPOINT_PUBLISHER = 1;

  /// /// Listens for and receives messages from a topic
  static const int RMW_ENDPOINT_SUBSCRIPTION = 2;
}

/// /// Options that can be used to configure the creation of a publisher in rmw.
class rmw_publisher_options_t extends ffi.Struct {
  /// /// Used to pass rmw implementation specific resources during publisher creation.
  ///
  /// This field is type erased (rather than forward declared) because it will
  /// usually be a non-owned reference to an language specific object, e.g.
  /// C++ it may be a polymorphic class that only the rmw implementation can use.
  ///
  /// The resource pointed to here needs to outlive this options structure, and
  /// any rmw_publisher objects that are created using it, as they copy this
  /// structure and may use this payload throughout their lifetime.
  external ffi.Pointer<ffi.Void> rmw_specific_publisher_payload;
}

/// /// Structure which encapsulates an rmw publisher
class rmw_publisher_t extends ffi.Struct {
  /// /// Name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Type erased pointer to this publisher's data
  external ffi.Pointer<ffi.Void> data;

  /// /// The name of the ROS topic this publisher publishes to
  external ffi.Pointer<ffi.Int8> topic_name;

  /// /// Publisher options.
  ///
  /// The options structure passed to rmw_create_publisher() should be
  /// assigned to this field by the rmw implementation.
  /// The fields should not be modified after creation, but
  /// the contents of the options structure may or may not be const, i.e.
  /// shallow const-ness.
  /// This field is not marked const to avoid any const casting during setup.
  external rmw_publisher_options_t options;

  /// /// Indicate whether this publisher supports loaning messages
  @ffi.Uint8()
  external int can_loan_messages;
}

/// /// Options that can be used to configure the creation of a subscription in rmw.
class rmw_subscription_options_t extends ffi.Struct {
  /// /// Used to pass rmw implementation specific resources during subscription creation.
  ///
  /// All the same details and restrictions of this field in
  /// rmw_publisher_options_t apply to this struct as well.
  ///
  /// \sa rmw_publisher_options_t.rmw_specific_publisher_payload
  external ffi.Pointer<ffi.Void> rmw_specific_subscription_payload;

  /// /// If true then the middleware should not deliver data from local publishers.
  ///
  /// This setting is most often used when data should only be received from
  /// remote nodes, especially to avoid "double delivery" when both intra- and
  /// inter- process communication is taking place.
  ///
  /// \TODO(wjwwood): nail this down when participant mapping is sorted out.
  /// See: https://github.com/ros2/design/pull/250
  ///
  /// The definition of local is somewhat vague at the moment.
  /// Right now it means local to the node, and that definition works best, but
  /// may become more complicated when/if participants map to a context instead.
  @ffi.Uint8()
  external int ignore_local_publications;
}

class rmw_subscription_t extends ffi.Struct {
  /// /// Name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Type erased pointer to this subscription
  external ffi.Pointer<ffi.Void> data;

  /// /// Name of the ros topic this subscription listens to
  external ffi.Pointer<ffi.Int8> topic_name;

  /// /// Subscription options.
  ///
  /// The options structure passed to rmw_create_subscription() should be
  /// assigned to this field by the rmw implementation.
  /// The fields should not be modified after creation, but
  /// the contents of the options structure may or may not be const, i.e.
  /// shallow const-ness.
  /// This field is not marked const to avoid any const casting during setup.
  external rmw_subscription_options_t options;

  /// /// Indicates whether this subscription can loan messages
  @ffi.Uint8()
  external int can_loan_messages;
}

/// /// A handle to an rmw service
class rmw_service_t extends ffi.Struct {
  /// /// The name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Type erased pointer to this service
  external ffi.Pointer<ffi.Void> data;

  /// /// The name of this service as exposed to the ros graph
  external ffi.Pointer<ffi.Int8> service_name;
}

/// /// A handle to an rmw service client
class rmw_client_t extends ffi.Struct {
  /// /// The name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Type erased pointer to this service client
  external ffi.Pointer<ffi.Void> data;

  /// /// The name of this service as exposed to the ros graph
  external ffi.Pointer<ffi.Int8> service_name;
}

/// /// Handle for an rmw guard condition
class rmw_guard_condition_t extends ffi.Struct {
  /// /// The name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Type erased pointer to this guard condition
  external ffi.Pointer<ffi.Void> data;

  /// /// rmw context associated with this guard condition
  external ffi.Pointer<rmw_context_t> context;
}

/// /// Allocation of memory for an rmw publisher
class rmw_publisher_allocation_t extends ffi.Struct {
  /// /// The name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Type erased pointer to this allocation
  external ffi.Pointer<ffi.Void> data;
}

/// /// Allocation of memory for an rmw subscription
class rmw_subscription_allocation_t extends ffi.Struct {
  /// /// The name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// Type erased pointer to this allocation
  external ffi.Pointer<ffi.Void> data;
}

/// /// Array of subscriber handles.
///
/// An array of void * pointers representing type-erased middleware-specific subscriptions.
/// The number of non-null entries may be smaller than the allocated size of the array.
/// The number of subscriptions represented may be smaller than the allocated size of the array.
/// The creator of this struct is responsible for allocating and deallocating the array.
class rmw_subscriptions_t extends ffi.Struct {
  /// /// The number of subscribers represented by the array.
  @ffi.Uint64()
  external int subscriber_count;

  /// /// Pointer to an array of void * pointers of subscriptions.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> subscribers;
}

/// /// Array of service handles.
///
/// An array of void * pointers representing type-erased middleware-specific services.
/// The number of non-null entries may be smaller than the allocated size of the array.
/// The number of services represented may be smaller than the allocated size of the array.
/// The creator of this struct is responsible for allocating and deallocating the array.
class rmw_services_t extends ffi.Struct {
  /// /// The number of services represented by the array.
  @ffi.Uint64()
  external int service_count;

  /// /// Pointer to an array of void * pointers of services.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> services;
}

/// /// Array of client handles.
///
/// An array of void * pointers representing type-erased middleware-specific clients.
/// The number of non-null entries may be smaller than the allocated size of the array.
/// The number of clients represented may be smaller than the allocated size of the array.
/// The creator of this struct is responsible for allocating and deallocating the array.
class rmw_clients_t extends ffi.Struct {
  /// /// The number of clients represented by the array.
  @ffi.Uint64()
  external int client_count;

  /// /// Pointer to an array of void * pointers of clients.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> clients;
}

class rmw_events_t extends ffi.Struct {
  /// /// The number of events represented by the array.
  @ffi.Uint64()
  external int event_count;

  /// /// Pointer to an array of void * pointers of events.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> events;
}

/// /// Array of guard condition handles.
///
/// An array of void * pointers representing type-erased middleware-specific guard conditions.
/// The number of non-null entries may be smaller than the allocated size of the array.
/// The number of guard conditions represented may be smaller than the allocated size of the array.
/// The creator of this struct is responsible for allocating and deallocating the array.
class rmw_guard_conditions_t extends ffi.Struct {
  /// /// The number of guard conditions represented by the array.
  @ffi.Uint64()
  external int guard_condition_count;

  /// /// Pointer to an array of void * pointers of guard conditions.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> guard_conditions;
}

/// /// Container for guard conditions to be waited on
class rmw_wait_set_t extends ffi.Struct {
  /// /// The name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  /// /// The guard condition to be waited on
  external ffi.Pointer<rmw_guard_conditions_t> guard_conditions;

  /// /// Type erased pointer to this wait set's data
  external ffi.Pointer<ffi.Void> data;
}

/// /// An rmw service request identifier
class rmw_request_id_t extends ffi.Struct {
  @ffi.Int8()
  external int _unique_writer_guid_item_0;
  @ffi.Int8()
  external int _unique_writer_guid_item_1;
  @ffi.Int8()
  external int _unique_writer_guid_item_2;
  @ffi.Int8()
  external int _unique_writer_guid_item_3;
  @ffi.Int8()
  external int _unique_writer_guid_item_4;
  @ffi.Int8()
  external int _unique_writer_guid_item_5;
  @ffi.Int8()
  external int _unique_writer_guid_item_6;
  @ffi.Int8()
  external int _unique_writer_guid_item_7;
  @ffi.Int8()
  external int _unique_writer_guid_item_8;
  @ffi.Int8()
  external int _unique_writer_guid_item_9;
  @ffi.Int8()
  external int _unique_writer_guid_item_10;
  @ffi.Int8()
  external int _unique_writer_guid_item_11;
  @ffi.Int8()
  external int _unique_writer_guid_item_12;
  @ffi.Int8()
  external int _unique_writer_guid_item_13;
  @ffi.Int8()
  external int _unique_writer_guid_item_14;
  @ffi.Int8()
  external int _unique_writer_guid_item_15;

  /// Helper for array `writer_guid`.
  ArrayHelper_rmw_request_id_t_writer_guid_level0 get writer_guid =>
      ArrayHelper_rmw_request_id_t_writer_guid_level0(this, [16], 0, 0);

  /// /// Sequence number of this service
  @ffi.Int64()
  external int sequence_number;
}

/// Helper for array `writer_guid` in struct `rmw_request_id_t`.
class ArrayHelper_rmw_request_id_t_writer_guid_level0 {
  final rmw_request_id_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_rmw_request_id_t_writer_guid_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_writer_guid_item_0;
      case 1:
        return _struct._unique_writer_guid_item_1;
      case 2:
        return _struct._unique_writer_guid_item_2;
      case 3:
        return _struct._unique_writer_guid_item_3;
      case 4:
        return _struct._unique_writer_guid_item_4;
      case 5:
        return _struct._unique_writer_guid_item_5;
      case 6:
        return _struct._unique_writer_guid_item_6;
      case 7:
        return _struct._unique_writer_guid_item_7;
      case 8:
        return _struct._unique_writer_guid_item_8;
      case 9:
        return _struct._unique_writer_guid_item_9;
      case 10:
        return _struct._unique_writer_guid_item_10;
      case 11:
        return _struct._unique_writer_guid_item_11;
      case 12:
        return _struct._unique_writer_guid_item_12;
      case 13:
        return _struct._unique_writer_guid_item_13;
      case 14:
        return _struct._unique_writer_guid_item_14;
      case 15:
        return _struct._unique_writer_guid_item_15;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_writer_guid_item_0 = value;
        break;
      case 1:
        _struct._unique_writer_guid_item_1 = value;
        break;
      case 2:
        _struct._unique_writer_guid_item_2 = value;
        break;
      case 3:
        _struct._unique_writer_guid_item_3 = value;
        break;
      case 4:
        _struct._unique_writer_guid_item_4 = value;
        break;
      case 5:
        _struct._unique_writer_guid_item_5 = value;
        break;
      case 6:
        _struct._unique_writer_guid_item_6 = value;
        break;
      case 7:
        _struct._unique_writer_guid_item_7 = value;
        break;
      case 8:
        _struct._unique_writer_guid_item_8 = value;
        break;
      case 9:
        _struct._unique_writer_guid_item_9 = value;
        break;
      case 10:
        _struct._unique_writer_guid_item_10 = value;
        break;
      case 11:
        _struct._unique_writer_guid_item_11 = value;
        break;
      case 12:
        _struct._unique_writer_guid_item_12 = value;
        break;
      case 13:
        _struct._unique_writer_guid_item_13 = value;
        break;
      case 14:
        _struct._unique_writer_guid_item_14 = value;
        break;
      case 15:
        _struct._unique_writer_guid_item_15 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// /// Struct representing a time point for rmw
class rmw_time_t extends ffi.Struct {
  /// /// Seconds since the epoch
  @ffi.Uint64()
  external int sec;

  /// /// Nanoseconds component of this time point
  @ffi.Uint64()
  external int nsec;
}

/// /// Meta-data for a service-related take.
class rmw_service_info_t extends ffi.Struct {
  @ffi.Int64()
  external int source_timestamp;

  @ffi.Int64()
  external int received_timestamp;

  external rmw_request_id_t request_id;
}

abstract class rmw_qos_reliability_policy_t {
  /// /// Implementation specific default
  static const int RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT = 0;

  /// /// Guarantee that samples are delivered, may retry multiple times.
  static const int RMW_QOS_POLICY_RELIABILITY_RELIABLE = 1;

  /// /// Attempt to deliver samples, but some may be lost if the network is not robust
  static const int RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT = 2;

  /// /// Reliability policy has not yet been set
  static const int RMW_QOS_POLICY_RELIABILITY_UNKNOWN = 3;
}

/// /// QoS history enumerations describing how samples endure
abstract class rmw_qos_history_policy_t {
  /// /// Implementation default for history policy
  static const int RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT = 0;

  /// /// Only store up to a maximum number of samples, dropping oldest once max is exceeded
  static const int RMW_QOS_POLICY_HISTORY_KEEP_LAST = 1;

  /// /// Store all samples, subject to resource limits
  static const int RMW_QOS_POLICY_HISTORY_KEEP_ALL = 2;

  /// /// History policy has not yet been set
  static const int RMW_QOS_POLICY_HISTORY_UNKNOWN = 3;
}

/// /// QoS durability enumerations describing how samples persist
abstract class rmw_qos_durability_policy_t {
  /// /// Impplementation specific default
  static const int RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT = 0;

  /// /// The rmw publisher is responsible for persisting samples for “late-joining” subscribers
  static const int RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL = 1;

  /// /// Samples are not persistent
  static const int RMW_QOS_POLICY_DURABILITY_VOLATILE = 2;

  /// /// Durability policy has not yet been set
  static const int RMW_QOS_POLICY_DURABILITY_UNKNOWN = 3;
}

/// /// QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.
/// /// For a subscriber, these are its requirements for its topic's publishers.
abstract class rmw_qos_liveliness_policy_t {
  /// /// Implementation specific default
  static const int RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT = 0;

  /// /// The signal that establishes a Topic is alive comes from the ROS rmw layer.
  static const int RMW_QOS_POLICY_LIVELINESS_AUTOMATIC = 1;
  static const int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE = 2;

  /// /// The signal that establishes a Topic is alive is at the Topic level. Only publishing a message
  /// /// on the Topic or an explicit signal from the application to assert liveliness on the Topic
  /// /// will mark the Topic as being alive.
  static const int RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = 3;

  /// /// Liveliness policy has not yet been set
  static const int RMW_QOS_POLICY_LIVELINESS_UNKNOWN = 4;
}

/// /// ROS MiddleWare quality of service profile.
class rmw_qos_profile_t extends ffi.Struct {
  @ffi.Int32()
  external int history;

  /// /// Size of the message queue.
  @ffi.Uint64()
  external int depth;

  /// /// Reliabiilty QoS policy setting
  @ffi.Int32()
  external int reliability;

  /// /// Durability QoS policy setting
  @ffi.Int32()
  external int durability;

  /// /// The period at which messages are expected to be sent/received
  external rmw_time_t deadline;

  /// /// The age at which messages are considered expired and no longer valid
  external rmw_time_t lifespan;

  /// /// Liveliness QoS policy setting
  @ffi.Int32()
  external int liveliness;

  /// /// The time within which the RMW node or publisher must show that it is alive
  external rmw_time_t liveliness_lease_duration;

  /// /// If true, any ROS specific namespacing conventions will be circumvented.
  ///
  /// In the case of DDS and topics, for example, this means the typical
  /// ROS specific prefix of `rt` would not be applied as described here:
  ///
  /// http://design.ros2.org/articles/topic_and_service_names.html#ros-specific-namespace-prefix
  ///
  /// This might be useful when trying to directly connect a native DDS topic
  /// with a ROS 2 topic.
  @ffi.Uint8()
  external int avoid_ros_namespace_conventions;
}

/// /// ROS graph ID of the topic
class rmw_gid_t extends ffi.Struct {
  /// /// Name of the rmw implementation
  external ffi.Pointer<ffi.Int8> implementation_identifier;

  @ffi.Uint8()
  external int _unique_data_item_0;
  @ffi.Uint8()
  external int _unique_data_item_1;
  @ffi.Uint8()
  external int _unique_data_item_2;
  @ffi.Uint8()
  external int _unique_data_item_3;
  @ffi.Uint8()
  external int _unique_data_item_4;
  @ffi.Uint8()
  external int _unique_data_item_5;
  @ffi.Uint8()
  external int _unique_data_item_6;
  @ffi.Uint8()
  external int _unique_data_item_7;
  @ffi.Uint8()
  external int _unique_data_item_8;
  @ffi.Uint8()
  external int _unique_data_item_9;
  @ffi.Uint8()
  external int _unique_data_item_10;
  @ffi.Uint8()
  external int _unique_data_item_11;
  @ffi.Uint8()
  external int _unique_data_item_12;
  @ffi.Uint8()
  external int _unique_data_item_13;
  @ffi.Uint8()
  external int _unique_data_item_14;
  @ffi.Uint8()
  external int _unique_data_item_15;
  @ffi.Uint8()
  external int _unique_data_item_16;
  @ffi.Uint8()
  external int _unique_data_item_17;
  @ffi.Uint8()
  external int _unique_data_item_18;
  @ffi.Uint8()
  external int _unique_data_item_19;
  @ffi.Uint8()
  external int _unique_data_item_20;
  @ffi.Uint8()
  external int _unique_data_item_21;
  @ffi.Uint8()
  external int _unique_data_item_22;
  @ffi.Uint8()
  external int _unique_data_item_23;

  /// Helper for array `data`.
  ArrayHelper_rmw_gid_t_data_level0 get data =>
      ArrayHelper_rmw_gid_t_data_level0(this, [24], 0, 0);
}

/// Helper for array `data` in struct `rmw_gid_t`.
class ArrayHelper_rmw_gid_t_data_level0 {
  final rmw_gid_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_rmw_gid_t_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      case 2:
        return _struct._unique_data_item_2;
      case 3:
        return _struct._unique_data_item_3;
      case 4:
        return _struct._unique_data_item_4;
      case 5:
        return _struct._unique_data_item_5;
      case 6:
        return _struct._unique_data_item_6;
      case 7:
        return _struct._unique_data_item_7;
      case 8:
        return _struct._unique_data_item_8;
      case 9:
        return _struct._unique_data_item_9;
      case 10:
        return _struct._unique_data_item_10;
      case 11:
        return _struct._unique_data_item_11;
      case 12:
        return _struct._unique_data_item_12;
      case 13:
        return _struct._unique_data_item_13;
      case 14:
        return _struct._unique_data_item_14;
      case 15:
        return _struct._unique_data_item_15;
      case 16:
        return _struct._unique_data_item_16;
      case 17:
        return _struct._unique_data_item_17;
      case 18:
        return _struct._unique_data_item_18;
      case 19:
        return _struct._unique_data_item_19;
      case 20:
        return _struct._unique_data_item_20;
      case 21:
        return _struct._unique_data_item_21;
      case 22:
        return _struct._unique_data_item_22;
      case 23:
        return _struct._unique_data_item_23;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      case 2:
        _struct._unique_data_item_2 = value;
        break;
      case 3:
        _struct._unique_data_item_3 = value;
        break;
      case 4:
        _struct._unique_data_item_4 = value;
        break;
      case 5:
        _struct._unique_data_item_5 = value;
        break;
      case 6:
        _struct._unique_data_item_6 = value;
        break;
      case 7:
        _struct._unique_data_item_7 = value;
        break;
      case 8:
        _struct._unique_data_item_8 = value;
        break;
      case 9:
        _struct._unique_data_item_9 = value;
        break;
      case 10:
        _struct._unique_data_item_10 = value;
        break;
      case 11:
        _struct._unique_data_item_11 = value;
        break;
      case 12:
        _struct._unique_data_item_12 = value;
        break;
      case 13:
        _struct._unique_data_item_13 = value;
        break;
      case 14:
        _struct._unique_data_item_14 = value;
        break;
      case 15:
        _struct._unique_data_item_15 = value;
        break;
      case 16:
        _struct._unique_data_item_16 = value;
        break;
      case 17:
        _struct._unique_data_item_17 = value;
        break;
      case 18:
        _struct._unique_data_item_18 = value;
        break;
      case 19:
        _struct._unique_data_item_19 = value;
        break;
      case 20:
        _struct._unique_data_item_20 = value;
        break;
      case 21:
        _struct._unique_data_item_21 = value;
        break;
      case 22:
        _struct._unique_data_item_22 = value;
        break;
      case 23:
        _struct._unique_data_item_23 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// /// Information describing an rmw message
class rmw_message_info_t extends ffi.Struct {
  @ffi.Int64()
  external int source_timestamp;

  @ffi.Int64()
  external int received_timestamp;

  external rmw_gid_t publisher_gid;

  /// /// Whether this message is from intra_process communication or not
  @ffi.Uint8()
  external int from_intra_process;
}

/// /// Type mapping of rcutils log severity types to rmw specific types.
abstract class rmw_log_severity_t {
  /// /// Debug log severity, for pedantic messaging
  static const int RMW_LOG_SEVERITY_DEBUG = 10;

  /// /// Informational log severity, for reporting expected but not overwhelming information
  static const int RMW_LOG_SEVERITY_INFO = 20;

  /// /// Warning log severity, for reporting recoverable issues
  static const int RMW_LOG_SEVERITY_WARN = 30;

  /// /// Error log severity, for reporting uncoverable issues
  static const int RMW_LOG_SEVERITY_ERROR = 40;

  /// /// Fatal log severity, for reporting issue causing imminent shutdown
  static const int RMW_LOG_SEVERITY_FATAL = 50;
}

/// /// QoS Liveliness Changed information provided by a subscription.
class rmw_liveliness_changed_status_t extends ffi.Struct {
  /// The total number of currently active Publishers which publish to the topic associated with
  /// the Subscription.
  /// This count increases when a newly matched Publisher asserts its liveliness for the first time
  /// or when a Publisher previously considered to be not alive reasserts its liveliness.
  /// The count decreases when a Publisher considered alive fails to assert its liveliness and
  /// becomes not alive, whether because it was deleted normally or for some other reason.
  @ffi.Int32()
  external int alive_count;

  /// The total count of current Publishers which publish to the topic associated with the
  /// Subscription that are no longer asserting their liveliness.
  /// This count increases when a Publisher considered alive fails to assert its liveliness and
  /// becomes not alive for some reason other than the normal deletion of that Publisher.
  /// It decreases when a previously not alive Publisher either reasserts its liveliness or is
  /// deleted normally.
  @ffi.Int32()
  external int not_alive_count;

  /// /// The change in the alive_count since the status was last read.
  @ffi.Int32()
  external int alive_count_change;

  /// /// The change in the not_alive_count since the status was last read.
  @ffi.Int32()
  external int not_alive_count_change;
}

/// /// QoS Requested Deadline Missed information provided by a subscription.
class rmw_requested_deadline_missed_status_t extends ffi.Struct {
  /// Lifetime cumulative number of missed deadlines detected for any instance read by the
  /// subscription.
  /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
  /// by one for each instance for which data was not received.
  @ffi.Int32()
  external int total_count;

  /// /// The incremental number of deadlines detected since the status was read.
  @ffi.Int32()
  external int total_count_change;
}

/// /// QoS Liveliness Lost information provided by a publisher.
class rmw_liveliness_lost_status_t extends ffi.Struct {
  /// Lifetime cumulative number of times that a previously-alive Publisher became not alive due to
  /// a failure to actively signal its liveliness within its offered liveliness period.
  /// This count does not change when an already not alive Publisher simply remains not alive for
  /// another liveliness period.
  @ffi.Int32()
  external int total_count;

  /// /// The change in total_count since the last time the status was last read.
  @ffi.Int32()
  external int total_count_change;
}

/// /// QoS Deadline Missed information provided by a publisher.
class rmw_offered_deadline_missed_status_t extends ffi.Struct {
  /// Lifetime cumulative number of offered deadline periods elapsed during which a Publisher failed
  /// to provide data.
  /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
  /// by one.
  @ffi.Int32()
  external int total_count;

  /// /// The change in total_count since the last time the status was last read.
  @ffi.Int32()
  external int total_count_change;
}

/// /// Array of bool values
class rcl_bool_array_t extends ffi.Struct {
  /// /// Array with bool values
  external ffi.Pointer<ffi.Uint8> values;

  /// /// Number of values in the array
  @ffi.Uint64()
  external int size;
}

/// /// Array of int64_t values
class rcl_int64_array_t extends ffi.Struct {
  /// /// Array with int64 values
  external ffi.Pointer<ffi.Int64> values;

  /// /// Number of values in the array
  @ffi.Uint64()
  external int size;
}

/// /// Array of double values
class rcl_double_array_t extends ffi.Struct {
  /// /// Array with double values
  external ffi.Pointer<ffi.Double> values;

  /// /// Number of values in the array
  @ffi.Uint64()
  external int size;
}

/// /// Array of byte values
class rcl_byte_array_t extends ffi.Struct {
  /// /// Array with uint8_t values
  external ffi.Pointer<ffi.Uint8> values;

  /// /// Number of values in the array
  @ffi.Uint64()
  external int size;
}

/// /// variant_t stores the value of a parameter
class rcl_variant_t extends ffi.Struct {
  /// ///< If bool, gets stored here
  external ffi.Pointer<ffi.Uint8> bool_value;

  /// ///< If integer, gets stored here
  external ffi.Pointer<ffi.Int64> integer_value;

  /// ///< If double, gets stored here
  external ffi.Pointer<ffi.Double> double_value;

  /// ///< If string, gets stored here
  external ffi.Pointer<ffi.Int8> string_value;

  /// ///< If array of bytes
  external ffi.Pointer<rcl_byte_array_t> byte_array_value;

  /// ///< If array of bool's
  external ffi.Pointer<rcl_bool_array_t> bool_array_value;

  /// ///< If array of integers
  external ffi.Pointer<rcl_int64_array_t> integer_array_value;

  /// ///< If array of doubles
  external ffi.Pointer<rcl_double_array_t> double_array_value;

  /// ///< If array of strings
  external ffi.Pointer<rcutils_string_array_t> string_array_value;
}

/// /// node_params_t stores all the parameters(key:value) of a single node
class rcl_node_params_t extends ffi.Struct {
  /// ///< Array of parameter names (keys)
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> parameter_names;

  /// ///< Array of coressponding parameter values
  external ffi.Pointer<rcl_variant_t> parameter_values;

  /// ///< Number of parameters in the node
  @ffi.Uint64()
  external int num_params;
}

/// /// stores all the parameters of all nodes of a process
class rcl_params_t extends ffi.Struct {
  /// ///< List of names of the node
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> node_names;

  /// ///<  Array of parameters
  external ffi.Pointer<rcl_node_params_t> params;

  /// ///< Number of nodes
  @ffi.Uint64()
  external int num_nodes;

  /// ///< Allocator used
  external rcutils_allocator_t allocator;
}

class rcl_arguments_impl_t extends ffi.Struct {}

/// /// Hold output of parsing command line arguments.
class rcl_arguments_t extends ffi.Struct {
  /// /// Private implementation pointer.
  external ffi.Pointer<rcl_arguments_impl_t> impl;
}

class rcl_init_options_impl_t extends ffi.Struct {}

/// /// Encapsulation of init options and implementation defined init options.
class rcl_init_options_t extends ffi.Struct {
  /// /// Implementation specific pointer.
  external ffi.Pointer<rcl_init_options_impl_t> impl;
}

class rcl_context_impl_t extends ffi.Struct {}

/// /// Encapsulates the non-global state of an init/shutdown cycle.
///
/// The context is used in the creation of top level entities like nodes and
/// guard conditions, as well as to shutdown a specific instance of init.
///
/// Here is a diagram of a typical context's lifecycle:
///
/// ```
/// +---------------+
/// |               |
/// +--> uninitialized +---> rcl_get_zero_initialized_context() +
/// |  |               |                                        |
/// |  +---------------+                                        |
/// |                                                           |
/// |           +-----------------------------------------------+
/// |           |
/// |  +--------v---------+                +-----------------------+
/// |  |                  |                |                       |
/// |  | zero-initialized +-> rcl_init() +-> initialized and valid +-> rcl_shutdown() +
/// |  |                  |                |                       |                  |
/// |  +------------------+                +-----------------------+                  |
/// |                                                                                 |
/// |               +-----------------------------------------------------------------+
/// |               |
/// |  +------------v------------+
/// |  |                         |
/// |  | initialized but invalid +---> finalize all entities, then rcl_context_fini() +
/// |  |                         |                                                    |
/// |  +-------------------------+                                                    |
/// |                                                                                 |
/// +---------------------------------------------------------------------------------+
/// ```
///
/// A declared but not defined `rcl_context_t` instance is considered to be
/// "uninitialized", and passing an uninitialized context to any functions will
/// result in undefined behavior.
/// Some functions, like `rcl_init()` require the context instance to be
/// zero initialized (all members set to "zero" state) before use.
///
/// Zero initialization of an `rcl_context_t` should be done with
/// `rcl_get_zero_initialized_context()`, which ensures the context is in a safe
/// state for initialization with `rcl_init()`.
///
/// Initialization of an `rcl_context_t` should be done with `rcl_init()`, after
/// which the context is considered both initialized and valid.
/// After initialization it can be used in the creation of other entities like
/// nodes and guard conditions.
///
/// At any time the context can be invalidated by calling `rcl_shutdown()` on
/// the `rcl_context_t`, after which the context is still initialized but now
/// invalid.
///
/// Invalidation indicates to other entities that the context was shutdown, but
/// is still accessible for use during cleanup of themselves.
///
/// After being invalidated, and after all of the entities which used it have
/// been finalized, the context should be finalized with `rcl_context_fini()`.
///
/// Finalizing the context while entities which have copies of it have not yet
/// been finalized is undefined behavior.
/// Therefore, the context's lifetime (between calls to `rcl_init()` and
/// `rcl_context_fini()`) should exceed the lifetime of all entities which use
/// it directly (e.g. nodes and guard conditions) or indirectly (e.g.
/// subscriptions and topics).
class rcl_context_t extends ffi.Struct {
  /// /// Global arguments for all nodes which share this context.
  /// Typically generated by the parsing of argc/argv in `rcl_init()`.
  external rcl_arguments_t global_arguments;

  /// /// Implementation specific pointer.
  external ffi.Pointer<rcl_context_impl_t> impl;

  @ffi.Uint8()
  external int _unique_instance_id_storage_item_0;
  @ffi.Uint8()
  external int _unique_instance_id_storage_item_1;
  @ffi.Uint8()
  external int _unique_instance_id_storage_item_2;
  @ffi.Uint8()
  external int _unique_instance_id_storage_item_3;
  @ffi.Uint8()
  external int _unique_instance_id_storage_item_4;
  @ffi.Uint8()
  external int _unique_instance_id_storage_item_5;
  @ffi.Uint8()
  external int _unique_instance_id_storage_item_6;
  @ffi.Uint8()
  external int _unique_instance_id_storage_item_7;

  /// Helper for array `instance_id_storage`.
  ArrayHelper_rcl_context_t_instance_id_storage_level0
      get instance_id_storage =>
          ArrayHelper_rcl_context_t_instance_id_storage_level0(this, [8], 0, 0);
}

/// Helper for array `instance_id_storage` in struct `rcl_context_t`.
class ArrayHelper_rcl_context_t_instance_id_storage_level0 {
  final rcl_context_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_rcl_context_t_instance_id_storage_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_instance_id_storage_item_0;
      case 1:
        return _struct._unique_instance_id_storage_item_1;
      case 2:
        return _struct._unique_instance_id_storage_item_2;
      case 3:
        return _struct._unique_instance_id_storage_item_3;
      case 4:
        return _struct._unique_instance_id_storage_item_4;
      case 5:
        return _struct._unique_instance_id_storage_item_5;
      case 6:
        return _struct._unique_instance_id_storage_item_6;
      case 7:
        return _struct._unique_instance_id_storage_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_instance_id_storage_item_0 = value;
        break;
      case 1:
        _struct._unique_instance_id_storage_item_1 = value;
        break;
      case 2:
        _struct._unique_instance_id_storage_item_2 = value;
        break;
      case 3:
        _struct._unique_instance_id_storage_item_3 = value;
        break;
      case 4:
        _struct._unique_instance_id_storage_item_4 = value;
        break;
      case 5:
        _struct._unique_instance_id_storage_item_5 = value;
        break;
      case 6:
        _struct._unique_instance_id_storage_item_6 = value;
        break;
      case 7:
        _struct._unique_instance_id_storage_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// /// Structure which encapsulates the options for creating a rcl_node_t.
class rcl_node_options_t extends ffi.Struct {
  /// /// If set, then this value overrides the ROS_DOMAIN_ID environment variable.
  ///
  /// It defaults to RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID, which will cause the
  /// node to use the ROS domain ID set in the ROS_DOMAIN_ID environment
  /// variable, or on some systems 0 if the environment variable is not set.
  ///
  /// \todo TODO(wjwwood):
  /// Should we put a limit on the ROS_DOMAIN_ID value, that way we can have
  /// a safe value for the default RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID?
  /// (currently max size_t)
  @ffi.Uint64()
  external int domain_id;

  /// /// Custom allocator used for internal allocations.
  external rcutils_allocator_t allocator;

  /// /// If false then only use arguments in this struct, otherwise use global arguments also.
  @ffi.Uint8()
  external int use_global_arguments;

  /// /// Command line arguments that apply only to this node.
  external rcl_arguments_t arguments;

  /// /// Flag to enable rosout for this node
  @ffi.Uint8()
  external int enable_rosout;
}

/// /// Handle for a rcl guard condition.
class rcl_guard_condition_t extends ffi.Struct {
  external ffi.Pointer<rcl_context_t> context;
  external ffi.Pointer<rcl_guard_condition_impl_t> impl;
}

class rcl_node_impl_t extends ffi.Struct {}

/// /// Structure which encapsulates a ROS Node.
class rcl_node_t extends ffi.Struct {
  /// /// Context associated with this node.
  external ffi.Pointer<rcl_context_t> context;

  /// /// Private implementation pointer.
  external ffi.Pointer<rcl_node_impl_t> impl;
}

/// /// Contains rosidl message type support data
class rosidl_message_type_support_t extends ffi.Struct {}

/// /// Internal rcl publisher implementation struct.
class rcl_publisher_impl_t extends ffi.Struct {}

/// /// Structure which encapsulates a ROS Publisher.
class rcl_publisher_t extends ffi.Struct {
  /// /// Pointer to the publisher implementation
  external ffi.Pointer<rcl_publisher_impl_t> impl;
}

/// /// Options available for a rcl publisher.
class rcl_publisher_options_t extends ffi.Struct {
  /// /// Middleware quality of service settings for the publisher.
  external rmw_qos_profile_t qos;

  /// /// Custom allocator for the publisher, used for incidental allocations.
  /// For default behavior (malloc/free), use: rcl_get_default_allocator()
  external rcutils_allocator_t allocator;

  /// /// rmw specific publisher options, e.g. the rmw implementation specific payload.
  external rmw_publisher_options_t rmw_publisher_options;
}

/// /// Structure to hold a sequence of ROS messages.
class rmw_message_sequence_t extends ffi.Struct {
  /// /// Array of pointers to ROS messages.
  external ffi.Pointer<ffi.Pointer<ffi.Void>> data;

  /// /// The number of valid entries in `data`.
  @ffi.Uint64()
  external int size;

  /// /// The total allocated capacity of the data array.
  @ffi.Uint64()
  external int capacity;

  /// /// The allocator used to allocate the data array.
  external ffi.Pointer<rcutils_allocator_t> allocator;
}

/// /// Structure to hold a sequence of message infos.
class rmw_message_info_sequence_t extends ffi.Struct {
  /// /// Array of message info.
  external ffi.Pointer<rmw_message_info_t> data;

  /// /// The number of valid entries in data.
  @ffi.Uint64()
  external int size;

  /// /// The total allocated capacity of the data array.
  @ffi.Uint64()
  external int capacity;

  /// /// The allocator used to allocate the data array.
  external ffi.Pointer<rcutils_allocator_t> allocator;
}

/// /// Internal rcl implementation struct.
class rcl_subscription_impl_t extends ffi.Struct {}

/// /// Structure which encapsulates a ROS Subscription.
class rcl_subscription_t extends ffi.Struct {
  /// /// Pointer to the subscription implementation
  external ffi.Pointer<rcl_subscription_impl_t> impl;
}

/// /// Options available for a rcl subscription.
class rcl_subscription_options_t extends ffi.Struct {
  /// /// Middleware quality of service settings for the subscription.
  external rmw_qos_profile_t qos;

  /// /// Custom allocator for the subscription, used for incidental allocations.
  /// For default behavior (malloc/free), see: rcl_get_default_allocator()
  external rcutils_allocator_t allocator;

  /// /// rmw specific subscription options, e.g. the rmw implementation specific payload.
  external rmw_subscription_options_t rmw_subscription_options;
}

/// /// Contains rosidl service type support data
class rosidl_service_type_support_t extends ffi.Struct {}

/// /// Internal rcl client implementation struct.
class rcl_client_impl_t extends ffi.Struct {}

/// /// Structure which encapsulates a ROS Client.
class rcl_client_t extends ffi.Struct {
  /// /// Pointer to the client implementation
  external ffi.Pointer<rcl_client_impl_t> impl;
}

/// /// Options available for a rcl_client_t.
class rcl_client_options_t extends ffi.Struct {
  /// /// Middleware quality of service settings for the client.
  external rmw_qos_profile_t qos;

  /// /// Custom allocator for the client, used for incidental allocations.
  /// For default behavior (malloc/free), use: rcl_get_default_allocator()
  external rcutils_allocator_t allocator;
}

/// /// Internal rcl guard condition implementation struct.
class rcl_guard_condition_impl_t extends ffi.Struct {}

/// /// Options available for a rcl guard condition.
class rcl_guard_condition_options_t extends ffi.Struct {
  /// /// Custom allocator for the guard condition, used for internal allocations.
  external rcutils_allocator_t allocator;
}

/// /// Internal rcl implementation struct.
class rcl_service_impl_t extends ffi.Struct {}

/// /// Structure which encapsulates a ROS Service.
class rcl_service_t extends ffi.Struct {
  /// /// Pointer to the service implementation
  external ffi.Pointer<rcl_service_impl_t> impl;
}

/// /// Options available for a rcl service.
class rcl_service_options_t extends ffi.Struct {
  /// /// Middleware quality of service settings for the service.
  external rmw_qos_profile_t qos;

  /// /// Custom allocator for the service, used for incidental allocations.
  /// For default behavior (malloc/free), see: rcl_get_default_allocator()
  external rcutils_allocator_t allocator;
}

/// /// Time source type, used to indicate the source of a time measurement.
///
/// RCL_ROS_TIME will report the latest value reported by a ROS time source, or
/// if a ROS time source is not active it reports the same as RCL_SYSTEM_TIME.
/// For more information about ROS time sources, refer to the design document:
/// http://design.ros2.org/articles/clock_and_time.html
///
/// RCL_SYSTEM_TIME reports the same value as the system clock.
///
/// RCL_STEADY_TIME reports a value from a monotonically increasing clock.
abstract class rcl_clock_type_t {
  static const int RCL_CLOCK_UNINITIALIZED = 0;
  static const int RCL_ROS_TIME = 1;
  static const int RCL_SYSTEM_TIME = 2;
  static const int RCL_STEADY_TIME = 3;
}

/// /// A duration of time, measured in nanoseconds and its source.
class rcl_duration_t extends ffi.Struct {
  /// /// Duration in nanoseconds and its source.
  @ffi.Int64()
  external int nanoseconds;
}

/// /// Enumeration to describe the type of time jump.
abstract class rcl_clock_change_t {
  /// /// The source before and after the jump is ROS_TIME.
  static const int RCL_ROS_TIME_NO_CHANGE = 1;

  /// /// The source switched to ROS_TIME from SYSTEM_TIME.
  static const int RCL_ROS_TIME_ACTIVATED = 2;

  /// /// The source switched to SYSTEM_TIME from ROS_TIME.
  static const int RCL_ROS_TIME_DEACTIVATED = 3;

  /// /// The source before and after the jump is SYSTEM_TIME.
  static const int RCL_SYSTEM_TIME_NO_CHANGE = 4;
}

/// /// Struct to describe a jump in time.
class rcl_time_jump_t extends ffi.Struct {
  /// /// Indicate whether or not the source of time changed.
  @ffi.Int32()
  external int clock_change;

  /// /// The new time minus the last time before the jump.
  external rcl_duration_t delta;
}

/// /// Describe the prerequisites for calling a time jump callback.
class rcl_jump_threshold_t extends ffi.Struct {
  /// /// True to call callback when the clock type changes.
  @ffi.Uint8()
  external int on_clock_change;

  /// /// A positive duration indicating the minimum jump forwards to be considered exceeded, or zero
  /// /// to disable.
  external rcl_duration_t min_forward;

  /// /// A negative duration indicating the minimum jump backwards to be considered exceeded, or zero
  /// /// to disable.
  external rcl_duration_t min_backward;
}

/// /// Struct to describe an added callback.
class rcl_jump_callback_info_t extends ffi.Struct {
  /// /// Callback to fucntion.
  external ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback;

  /// /// Threshold to decide when to call the callback.
  external rcl_jump_threshold_t threshold;

  /// /// Pointer passed to the callback.
  external ffi.Pointer<ffi.Void> user_data;
}

/// /// Encapsulation of a time source.
class rcl_clock_t extends ffi.Struct {
  /// /// Clock type
  @ffi.Int32()
  external int type;

  /// /// An array of added jump callbacks.
  external ffi.Pointer<rcl_jump_callback_info_t> jump_callbacks;

  /// /// Number of callbacks in jump_callbacks.
  @ffi.Uint64()
  external int num_jump_callbacks;

  /// /// Pointer to get_now function
  external ffi.Pointer<ffi.NativeFunction<_typedefC_6>> get_now;

  /// /// Clock storage
  external ffi.Pointer<ffi.Void> data;

  /// /// Custom allocator used for internal allocations.
  external rcutils_allocator_t allocator;
}

/// /// A single point in time, measured in nanoseconds, the reference point is based on the source.
class rcl_time_point_t extends ffi.Struct {
  /// /// Nanoseconds of the point in time
  @ffi.Int64()
  external int nanoseconds;

  /// /// Clock type of the point in time
  @ffi.Int32()
  external int clock_type;
}

class rosidl_runtime_c__Sequence__bound extends ffi.Struct {}

class rcl_timer_impl_t extends ffi.Struct {}

/// /// Structure which encapsulates a ROS Timer.
class rcl_timer_t extends ffi.Struct {
  /// /// Private implementation pointer.
  external ffi.Pointer<rcl_timer_impl_t> impl;
}

abstract class rcl_publisher_event_type_t {
  static const int RCL_PUBLISHER_OFFERED_DEADLINE_MISSED = 0;
  static const int RCL_PUBLISHER_LIVELINESS_LOST = 1;
  static const int RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS = 2;
}

abstract class rcl_subscription_event_type_t {
  static const int RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED = 0;
  static const int RCL_SUBSCRIPTION_LIVELINESS_CHANGED = 1;
  static const int RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS = 2;
}

class rmw_event_t extends ffi.Struct {}

/// /// Internal rcl implementation struct.
class rcl_event_impl_t extends ffi.Struct {}

/// /// Structure which encapsulates a ROS QoS event handle.
class rcl_event_t extends ffi.Struct {
  /// /// Pointer to the event implementation
  external ffi.Pointer<rcl_event_impl_t> impl;
}

class rcl_wait_set_impl_t extends ffi.Struct {}

/// /// Container for subscription's, guard condition's, etc to be waited on.
class rcl_wait_set_t extends ffi.Struct {
  /// /// Storage for subscription pointers.
  external ffi.Pointer<ffi.Pointer<rcl_subscription_t>> subscriptions;

  /// /// Number of subscriptions
  @ffi.Uint64()
  external int size_of_subscriptions;

  /// /// Storage for guard condition pointers.
  external ffi.Pointer<ffi.Pointer<rcl_guard_condition_t>> guard_conditions;

  /// /// Number of guard_conditions
  @ffi.Uint64()
  external int size_of_guard_conditions;

  /// /// Storage for timer pointers.
  external ffi.Pointer<ffi.Pointer<rcl_timer_t>> timers;

  /// /// Number of timers
  @ffi.Uint64()
  external int size_of_timers;

  /// /// Storage for client pointers.
  external ffi.Pointer<ffi.Pointer<rcl_client_t>> clients;

  /// /// Number of clients
  @ffi.Uint64()
  external int size_of_clients;

  /// /// Storage for service pointers.
  external ffi.Pointer<ffi.Pointer<rcl_service_t>> services;

  /// /// Number of services
  @ffi.Uint64()
  external int size_of_services;

  /// /// Storage for event pointers.
  external ffi.Pointer<ffi.Pointer<rcl_event_t>> events;

  /// /// Number of events
  @ffi.Uint64()
  external int size_of_events;

  /// /// Implementation specific storage.
  external ffi.Pointer<rcl_wait_set_impl_t> impl;
}

const int RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT = 0;

const int RCUTILS_RET_OK = 0;

const int RCUTILS_RET_WARN = 1;

const int RCUTILS_RET_ERROR = 2;

const int RCUTILS_RET_BAD_ALLOC = 10;

const int RCUTILS_RET_INVALID_ARGUMENT = 11;

const int RCUTILS_RET_NOT_ENOUGH_SPACE = 12;

const int RCUTILS_RET_NOT_INITIALIZED = 13;

const int RCUTILS_RET_NOT_FOUND = 14;

const int RCUTILS_RET_STRING_MAP_ALREADY_INIT = 30;

const int RCUTILS_RET_STRING_MAP_INVALID = 31;

const int RCUTILS_RET_STRING_KEY_NOT_FOUND = 32;

const int RCUTILS_RET_LOGGING_SEVERITY_MAP_INVALID = 40;

const int RCUTILS_RET_LOGGING_SEVERITY_STRING_INVALID = 41;

const int RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES = 50;

const int RMW_DEFAULT_DOMAIN_ID = -1;

const int RMW_RET_OK = 0;

const int RMW_RET_ERROR = 1;

const int RMW_RET_TIMEOUT = 2;

const int RMW_RET_UNSUPPORTED = 3;

const int RMW_RET_BAD_ALLOC = 10;

const int RMW_RET_INVALID_ARGUMENT = 11;

const int RMW_RET_INCORRECT_RMW_IMPLEMENTATION = 12;

const int RMW_RET_NODE_NAME_NON_EXISTENT = 203;

const int RCUTILS_FAULT_INJECTION_NEVER_FAIL = -1;

const int RCUTILS_FAULT_INJECTION_FAIL_NOW = 0;

const int RCUTILS_ERROR_STATE_LINE_NUMBER_STR_MAX_LENGTH = 20;

const int RCUTILS_ERROR_FORMATTING_CHARACTERS = 6;

const int RCUTILS_ERROR_MESSAGE_MAX_LENGTH = 1024;

const int RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH = 768;

const int RCUTILS_ERROR_STATE_FILE_MAX_LENGTH = 229;

const int RCUTILS_LOGGING_SEPARATOR_CHAR = 46;

const String RCUTILS_LOGGING_SEPARATOR_STRING = '.';

const int RCUTILS_DEFAULT_LOGGER_DEFAULT_LEVEL = 20;

const int RMW_GID_STORAGE_SIZE = 24;

const String RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE_DEPRECATED_MSG =
    'RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE is deprecated. Use RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC if manually asserted liveliness is needed.';

const int RCL_RET_OK = 0;

const int RCL_RET_ERROR = 1;

const int RCL_RET_TIMEOUT = 2;

const int RCL_RET_BAD_ALLOC = 10;

const int RCL_RET_INVALID_ARGUMENT = 11;

const int RCL_RET_UNSUPPORTED = 3;

const int RCL_RET_ALREADY_INIT = 100;

const int RCL_RET_NOT_INIT = 101;

const int RCL_RET_MISMATCHED_RMW_ID = 102;

const int RCL_RET_TOPIC_NAME_INVALID = 103;

const int RCL_RET_SERVICE_NAME_INVALID = 104;

const int RCL_RET_UNKNOWN_SUBSTITUTION = 105;

const int RCL_RET_ALREADY_SHUTDOWN = 106;

const int RCL_RET_NODE_INVALID = 200;

const int RCL_RET_NODE_INVALID_NAME = 201;

const int RCL_RET_NODE_INVALID_NAMESPACE = 202;

const int RCL_RET_NODE_NAME_NON_EXISTENT = 203;

const int RCL_RET_PUBLISHER_INVALID = 300;

const int RCL_RET_SUBSCRIPTION_INVALID = 400;

const int RCL_RET_SUBSCRIPTION_TAKE_FAILED = 401;

const int RCL_RET_CLIENT_INVALID = 500;

const int RCL_RET_CLIENT_TAKE_FAILED = 501;

const int RCL_RET_SERVICE_INVALID = 600;

const int RCL_RET_SERVICE_TAKE_FAILED = 601;

const int RCL_RET_TIMER_INVALID = 800;

const int RCL_RET_TIMER_CANCELED = 801;

const int RCL_RET_WAIT_SET_INVALID = 900;

const int RCL_RET_WAIT_SET_EMPTY = 901;

const int RCL_RET_WAIT_SET_FULL = 902;

const int RCL_RET_INVALID_REMAP_RULE = 1001;

const int RCL_RET_WRONG_LEXEME = 1002;

const int RCL_RET_INVALID_ROS_ARGS = 1003;

const int RCL_RET_INVALID_PARAM_RULE = 1010;

const int RCL_RET_INVALID_LOG_LEVEL_RULE = 1020;

const int RCL_RET_EVENT_INVALID = 2000;

const int RCL_RET_EVENT_TAKE_FAILED = 2001;

const String RCL_ROS_ARGS_FLAG = '--ros-args';

const String RCL_ROS_ARGS_EXPLICIT_END_TOKEN = '--';

const String RCL_PARAM_FLAG = '--param';

const String RCL_SHORT_PARAM_FLAG = '-p';

const String RCL_PARAM_FILE_FLAG = '--params-file';

const String RCL_REMAP_FLAG = '--remap';

const String RCL_SHORT_REMAP_FLAG = '-r';

const String RCL_ENCLAVE_FLAG = '--enclave';

const String RCL_SHORT_ENCLAVE_FLAG = '-e';

const String RCL_LOG_LEVEL_FLAG = '--log-level';

const String RCL_EXTERNAL_LOG_CONFIG_FLAG = '--log-config-file';

const String RCL_LOG_STDOUT_FLAG_SUFFIX = 'stdout-logs';

const String RCL_LOG_ROSOUT_FLAG_SUFFIX = 'rosout-logs';

const String RCL_LOG_EXT_LIB_FLAG_SUFFIX = 'external-lib-logs';

const int RCL_CONTEXT_ATOMIC_INSTANCE_ID_STORAGE_SIZE = 8;

const int RCL_DEFAULT_DOMAIN_ID = -1;

const int RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID = -1;

typedef _c_rcutils_get_zero_initialized_allocator = rcutils_allocator_t
    Function();

typedef _dart_rcutils_get_zero_initialized_allocator = rcutils_allocator_t
    Function();

typedef _c_rcutils_get_default_allocator = rcutils_allocator_t Function();

typedef _dart_rcutils_get_default_allocator = rcutils_allocator_t Function();

typedef _c_rcutils_allocator_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_allocator_is_valid = int Function(
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_reallocf = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> pointer,
  ffi.Uint64 size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_reallocf = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> pointer,
  int size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rmw_get_zero_initialized_security_options = rmw_security_options_t
    Function();

typedef _dart_rmw_get_zero_initialized_security_options = rmw_security_options_t
    Function();

typedef _c_rmw_get_default_security_options = rmw_security_options_t Function();

typedef _dart_rmw_get_default_security_options = rmw_security_options_t
    Function();

typedef _c_rmw_security_options_copy = ffi.Int32 Function(
  ffi.Pointer<rmw_security_options_t> src,
  ffi.Pointer<rcutils_allocator_t> allocator,
  ffi.Pointer<rmw_security_options_t> dst,
);

typedef _dart_rmw_security_options_copy = int Function(
  ffi.Pointer<rmw_security_options_t> src,
  ffi.Pointer<rcutils_allocator_t> allocator,
  ffi.Pointer<rmw_security_options_t> dst,
);

typedef _c_rmw_security_options_set_root_path = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> security_root_path,
  ffi.Pointer<rcutils_allocator_t> allocator,
  ffi.Pointer<rmw_security_options_t> security_options,
);

typedef _dart_rmw_security_options_set_root_path = int Function(
  ffi.Pointer<ffi.Int8> security_root_path,
  ffi.Pointer<rcutils_allocator_t> allocator,
  ffi.Pointer<rmw_security_options_t> security_options,
);

typedef _c_rmw_security_options_fini = ffi.Int32 Function(
  ffi.Pointer<rmw_security_options_t> security_options,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rmw_security_options_fini = int Function(
  ffi.Pointer<rmw_security_options_t> security_options,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rmw_get_zero_initialized_init_options = rmw_init_options_t
    Function();

typedef _dart_rmw_get_zero_initialized_init_options = rmw_init_options_t
    Function();

typedef _c_rmw_init_options_init = ffi.Int32 Function(
  ffi.Pointer<rmw_init_options_t> init_options,
  rcutils_allocator_t allocator,
);

typedef _dart_rmw_init_options_init = int Function(
  ffi.Pointer<rmw_init_options_t> init_options,
  rcutils_allocator_t allocator,
);

typedef _c_rmw_init_options_copy = ffi.Int32 Function(
  ffi.Pointer<rmw_init_options_t> src,
  ffi.Pointer<rmw_init_options_t> dst,
);

typedef _dart_rmw_init_options_copy = int Function(
  ffi.Pointer<rmw_init_options_t> src,
  ffi.Pointer<rmw_init_options_t> dst,
);

typedef _c_rmw_init_options_fini = ffi.Int32 Function(
  ffi.Pointer<rmw_init_options_t> init_options,
);

typedef _dart_rmw_init_options_fini = int Function(
  ffi.Pointer<rmw_init_options_t> init_options,
);

typedef _c_rmw_get_zero_initialized_context = rmw_context_t Function();

typedef _dart_rmw_get_zero_initialized_context = rmw_context_t Function();

typedef _c_rmw_init = ffi.Int32 Function(
  ffi.Pointer<rmw_init_options_t> options,
  ffi.Pointer<rmw_context_t> context,
);

typedef _dart_rmw_init = int Function(
  ffi.Pointer<rmw_init_options_t> options,
  ffi.Pointer<rmw_context_t> context,
);

typedef _c_rmw_shutdown = ffi.Int32 Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _dart_rmw_shutdown = int Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _c_rmw_context_fini = ffi.Int32 Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _dart_rmw_context_fini = int Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _c_rcutils_snprintf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Uint64 buffer_size,
  ffi.Pointer<ffi.Int8> format,
);

typedef _dart_rcutils_snprintf = int Function(
  ffi.Pointer<ffi.Int8> buffer,
  int buffer_size,
  ffi.Pointer<ffi.Int8> format,
);

typedef _c_rcutils_vsnprintf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Uint64 buffer_size,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<__va_list_tag> args,
);

typedef _dart_rcutils_vsnprintf = int Function(
  ffi.Pointer<ffi.Int8> buffer,
  int buffer_size,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<__va_list_tag> args,
);

typedef _c_rcutils_fault_injection_is_test_complete = ffi.Uint8 Function();

typedef _dart_rcutils_fault_injection_is_test_complete = int Function();

typedef _c_rcutils_fault_injection_set_count = ffi.Void Function(
  ffi.Int64 count,
);

typedef _dart_rcutils_fault_injection_set_count = void Function(
  int count,
);

typedef _c_rcutils_fault_injection_get_count = ffi.Int64 Function();

typedef _dart_rcutils_fault_injection_get_count = int Function();

typedef _c__rcutils_fault_injection_maybe_fail = ffi.Int64 Function();

typedef _dart__rcutils_fault_injection_maybe_fail = int Function();

typedef _c_rcutils_initialize_error_handling_thread_local_storage = ffi.Int32
    Function(
  rcutils_allocator_t allocator,
);

typedef _dart_rcutils_initialize_error_handling_thread_local_storage = int
    Function(
  rcutils_allocator_t allocator,
);

typedef _c_rcutils_set_error_state = ffi.Void Function(
  ffi.Pointer<ffi.Int8> error_string,
  ffi.Pointer<ffi.Int8> file,
  ffi.Uint64 line_number,
);

typedef _dart_rcutils_set_error_state = void Function(
  ffi.Pointer<ffi.Int8> error_string,
  ffi.Pointer<ffi.Int8> file,
  int line_number,
);

typedef _c_rcutils_error_is_set = ffi.Uint8 Function();

typedef _dart_rcutils_error_is_set = int Function();

typedef _c_rcutils_get_error_state = ffi.Pointer<rcutils_error_state_t>
    Function();

typedef _dart_rcutils_get_error_state = ffi.Pointer<rcutils_error_state_t>
    Function();

typedef _c_rcutils_get_error_string = rcutils_error_string_t Function();

typedef _dart_rcutils_get_error_string = rcutils_error_string_t Function();

typedef _c_rcutils_reset_error = ffi.Void Function();

typedef _dart_rcutils_reset_error = void Function();

typedef _c_rcutils_get_zero_initialized_array_list = rcutils_array_list_t
    Function();

typedef _dart_rcutils_get_zero_initialized_array_list = rcutils_array_list_t
    Function();

typedef _c_rcutils_array_list_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Uint64 initial_capacity,
  ffi.Uint64 data_size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_array_list_init = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  int initial_capacity,
  int data_size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_array_list_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
);

typedef _dart_rcutils_array_list_fini = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
);

typedef _c_rcutils_array_list_add = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_array_list_add = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_array_list_set = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Uint64 index,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_array_list_set = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  int index,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_array_list_remove = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Uint64 index,
);

typedef _dart_rcutils_array_list_remove = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  int index,
);

typedef _c_rcutils_array_list_get = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Uint64 index,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_array_list_get = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  int index,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_array_list_get_size = ffi.Int32 Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_rcutils_array_list_get_size = int Function(
  ffi.Pointer<rcutils_array_list_t> array_list,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_rcutils_get_zero_initialized_char_array = rcutils_char_array_t
    Function();

typedef _dart_rcutils_get_zero_initialized_char_array = rcutils_char_array_t
    Function();

typedef _c_rcutils_char_array_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Uint64 buffer_capacity,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_char_array_init = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  int buffer_capacity,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_char_array_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
);

typedef _dart_rcutils_char_array_fini = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
);

typedef _c_rcutils_char_array_resize = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Uint64 new_size,
);

typedef _dart_rcutils_char_array_resize = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  int new_size,
);

typedef _c_rcutils_char_array_expand_as_needed = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Uint64 new_size,
);

typedef _dart_rcutils_char_array_expand_as_needed = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  int new_size,
);

typedef _c_rcutils_char_array_vsprintf = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<__va_list_tag> args,
);

typedef _dart_rcutils_char_array_vsprintf = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<__va_list_tag> args,
);

typedef _c_rcutils_char_array_strncat = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 n,
);

typedef _dart_rcutils_char_array_strncat = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
  int n,
);

typedef _c_rcutils_char_array_strcat = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
);

typedef _dart_rcutils_char_array_strcat = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
);

typedef _c_rcutils_char_array_memcpy = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 n,
);

typedef _dart_rcutils_char_array_memcpy = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
  int n,
);

typedef _c_rcutils_char_array_strcpy = ffi.Int32 Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
);

typedef _dart_rcutils_char_array_strcpy = int Function(
  ffi.Pointer<rcutils_char_array_t> char_array,
  ffi.Pointer<ffi.Int8> src,
);

typedef _c_rcutils_hash_map_string_hash_func = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> key_str,
);

typedef _dart_rcutils_hash_map_string_hash_func = int Function(
  ffi.Pointer<ffi.Void> key_str,
);

typedef _c_rcutils_hash_map_string_cmp_func = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> val1,
  ffi.Pointer<ffi.Void> val2,
);

typedef _dart_rcutils_hash_map_string_cmp_func = int Function(
  ffi.Pointer<ffi.Void> val1,
  ffi.Pointer<ffi.Void> val2,
);

typedef _c_rcutils_get_zero_initialized_hash_map = rcutils_hash_map_t
    Function();

typedef _dart_rcutils_get_zero_initialized_hash_map = rcutils_hash_map_t
    Function();

typedef rcutils_hash_map_key_hasher_t = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void>,
);

typedef rcutils_hash_map_key_cmp_t = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_rcutils_hash_map_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Uint64 initial_capacity,
  ffi.Uint64 key_size,
  ffi.Uint64 data_size,
  ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_hasher_t>>
      key_hashing_func,
  ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_cmp_t>> key_cmp_func,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_hash_map_init = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  int initial_capacity,
  int key_size,
  int data_size,
  ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_hasher_t>>
      key_hashing_func,
  ffi.Pointer<ffi.NativeFunction<rcutils_hash_map_key_cmp_t>> key_cmp_func,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_hash_map_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
);

typedef _dart_rcutils_hash_map_fini = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
);

typedef _c_rcutils_hash_map_get_capacity = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Uint64> capacity,
);

typedef _dart_rcutils_hash_map_get_capacity = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Uint64> capacity,
);

typedef _c_rcutils_hash_map_get_size = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_rcutils_hash_map_get_size = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_rcutils_hash_map_set = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> value,
);

typedef _dart_rcutils_hash_map_set = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> value,
);

typedef _c_rcutils_hash_map_unset = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
);

typedef _dart_rcutils_hash_map_unset = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
);

typedef _c_rcutils_hash_map_key_exists = ffi.Uint8 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
);

typedef _dart_rcutils_hash_map_key_exists = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
);

typedef _c_rcutils_hash_map_get = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_hash_map_get = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_rcutils_hash_map_get_next_key_and_data = ffi.Int32 Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> previous_key,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_rcutils_hash_map_get_next_key_and_data = int Function(
  ffi.Pointer<rcutils_hash_map_t> hash_map,
  ffi.Pointer<ffi.Void> previous_key,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.Void> data,
);

typedef _typedefC_5 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_rcutils_qsort = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Uint64 count,
  ffi.Uint64 size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_5>> comp,
);

typedef _dart_rcutils_qsort = int Function(
  ffi.Pointer<ffi.Void> ptr,
  int count,
  int size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_5>> comp,
);

typedef _c_rcutils_get_zero_initialized_string_array = rcutils_string_array_t
    Function();

typedef _dart_rcutils_get_zero_initialized_string_array = rcutils_string_array_t
    Function();

typedef _c_rcutils_string_array_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
  ffi.Uint64 size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_string_array_init = int Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
  int size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_string_array_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
);

typedef _dart_rcutils_string_array_fini = int Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
);

typedef _c_rcutils_string_array_cmp = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_array_t> lhs,
  ffi.Pointer<rcutils_string_array_t> rhs,
  ffi.Pointer<ffi.Int32> res,
);

typedef _dart_rcutils_string_array_cmp = int Function(
  ffi.Pointer<rcutils_string_array_t> lhs,
  ffi.Pointer<rcutils_string_array_t> rhs,
  ffi.Pointer<ffi.Int32> res,
);

typedef _c_rcutils_string_array_resize = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
  ffi.Uint64 new_size,
);

typedef _dart_rcutils_string_array_resize = int Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
  int new_size,
);

typedef _c_rcutils_string_array_sort_compare = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> lhs,
  ffi.Pointer<ffi.Void> rhs,
);

typedef _dart_rcutils_string_array_sort_compare = int Function(
  ffi.Pointer<ffi.Void> lhs,
  ffi.Pointer<ffi.Void> rhs,
);

typedef _c_rcutils_string_array_sort = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
);

typedef _dart_rcutils_string_array_sort = int Function(
  ffi.Pointer<rcutils_string_array_t> string_array,
);

typedef _c_rcutils_get_zero_initialized_string_map = rcutils_string_map_t
    Function();

typedef _dart_rcutils_get_zero_initialized_string_map = rcutils_string_map_t
    Function();

typedef _c_rcutils_string_map_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Uint64 initial_capacity,
  rcutils_allocator_t allocator,
);

typedef _dart_rcutils_string_map_init = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  int initial_capacity,
  rcutils_allocator_t allocator,
);

typedef _c_rcutils_string_map_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
);

typedef _dart_rcutils_string_map_fini = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
);

typedef _c_rcutils_string_map_get_capacity = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Uint64> capacity,
);

typedef _dart_rcutils_string_map_get_capacity = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Uint64> capacity,
);

typedef _c_rcutils_string_map_get_size = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_rcutils_string_map_get_size = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_rcutils_string_map_reserve = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Uint64 capacity,
);

typedef _dart_rcutils_string_map_reserve = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  int capacity,
);

typedef _c_rcutils_string_map_clear = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
);

typedef _dart_rcutils_string_map_clear = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
);

typedef _c_rcutils_string_map_set = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_rcutils_string_map_set = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_rcutils_string_map_set_no_resize = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_rcutils_string_map_set_no_resize = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_rcutils_string_map_unset = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_rcutils_string_map_unset = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_rcutils_string_map_key_exists = ffi.Uint8 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_rcutils_string_map_key_exists = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_rcutils_string_map_key_existsn = ffi.Uint8 Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Uint64 key_length,
);

typedef _dart_rcutils_string_map_key_existsn = int Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  int key_length,
);

typedef _c_rcutils_string_map_get = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_rcutils_string_map_get = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_rcutils_string_map_getn = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  ffi.Uint64 key_length,
);

typedef _dart_rcutils_string_map_getn = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
  int key_length,
);

typedef _c_rcutils_string_map_get_next_key = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _dart_rcutils_string_map_get_next_key = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcutils_string_map_t> string_map,
  ffi.Pointer<ffi.Int8> key,
);

typedef _c_rcutils_string_map_copy = ffi.Int32 Function(
  ffi.Pointer<rcutils_string_map_t> src_string_map,
  ffi.Pointer<rcutils_string_map_t> dst_string_map,
);

typedef _dart_rcutils_string_map_copy = int Function(
  ffi.Pointer<rcutils_string_map_t> src_string_map,
  ffi.Pointer<rcutils_string_map_t> dst_string_map,
);

typedef _c_rcutils_get_zero_initialized_uint8_array = rcutils_uint8_array_t
    Function();

typedef _dart_rcutils_get_zero_initialized_uint8_array = rcutils_uint8_array_t
    Function();

typedef _c_rcutils_uint8_array_init = ffi.Int32 Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  ffi.Uint64 buffer_capacity,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcutils_uint8_array_init = int Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  int buffer_capacity,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcutils_uint8_array_fini = ffi.Int32 Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
);

typedef _dart_rcutils_uint8_array_fini = int Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
);

typedef _c_rcutils_uint8_array_resize = ffi.Int32 Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  ffi.Uint64 new_size,
);

typedef _dart_rcutils_uint8_array_resize = int Function(
  ffi.Pointer<rcutils_uint8_array_t> uint8_array,
  int new_size,
);

typedef _c_rcutils_system_time_now = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> now,
);

typedef _dart_rcutils_system_time_now = int Function(
  ffi.Pointer<ffi.Int64> now,
);

typedef _c_rcutils_steady_time_now = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> now,
);

typedef _dart_rcutils_steady_time_now = int Function(
  ffi.Pointer<ffi.Int64> now,
);

typedef _c_rcutils_time_point_value_as_nanoseconds_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> time_point,
  ffi.Pointer<ffi.Int8> str,
  ffi.Uint64 str_size,
);

typedef _dart_rcutils_time_point_value_as_nanoseconds_string = int Function(
  ffi.Pointer<ffi.Int64> time_point,
  ffi.Pointer<ffi.Int8> str,
  int str_size,
);

typedef _c_rcutils_time_point_value_as_seconds_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> time_point,
  ffi.Pointer<ffi.Int8> str,
  ffi.Uint64 str_size,
);

typedef _dart_rcutils_time_point_value_as_seconds_string = int Function(
  ffi.Pointer<ffi.Int64> time_point,
  ffi.Pointer<ffi.Int8> str,
  int str_size,
);

typedef _c_rcutils_logging_initialize_with_allocator = ffi.Int32 Function(
  rcutils_allocator_t allocator,
);

typedef _dart_rcutils_logging_initialize_with_allocator = int Function(
  rcutils_allocator_t allocator,
);

typedef _c_rcutils_logging_initialize = ffi.Int32 Function();

typedef _dart_rcutils_logging_initialize = int Function();

typedef _c_rcutils_logging_shutdown = ffi.Int32 Function();

typedef _dart_rcutils_logging_shutdown = int Function();

typedef _c_rcutils_logging_severity_level_from_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> severity_string,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Int32> severity,
);

typedef _dart_rcutils_logging_severity_level_from_string = int Function(
  ffi.Pointer<ffi.Int8> severity_string,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Int32> severity,
);

typedef rcutils_logging_output_handler_t = ffi.Void Function(
  ffi.Pointer<rcutils_log_location_t>,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Int64,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Pointer<__va_list_tag>>,
);

typedef _c_rcutils_logging_get_output_handler
    = ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>
        Function();

typedef _dart_rcutils_logging_get_output_handler
    = ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>>
        Function();

typedef _c_rcutils_logging_set_output_handler = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>> function,
);

typedef _dart_rcutils_logging_set_output_handler = void Function(
  ffi.Pointer<ffi.NativeFunction<rcutils_logging_output_handler_t>> function,
);

typedef _c_rcutils_logging_format_message = ffi.Int32 Function(
  ffi.Pointer<rcutils_log_location_t> location,
  ffi.Int32 severity,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int64 timestamp,
  ffi.Pointer<ffi.Int8> msg,
  ffi.Pointer<rcutils_char_array_t> logging_output,
);

typedef _dart_rcutils_logging_format_message = int Function(
  ffi.Pointer<rcutils_log_location_t> location,
  int severity,
  ffi.Pointer<ffi.Int8> name,
  int timestamp,
  ffi.Pointer<ffi.Int8> msg,
  ffi.Pointer<rcutils_char_array_t> logging_output,
);

typedef _c_rcutils_logging_get_default_logger_level = ffi.Int32 Function();

typedef _dart_rcutils_logging_get_default_logger_level = int Function();

typedef _c_rcutils_logging_set_default_logger_level = ffi.Void Function(
  ffi.Int32 level,
);

typedef _dart_rcutils_logging_set_default_logger_level = void Function(
  int level,
);

typedef _c_rcutils_logging_get_logger_level = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_rcutils_logging_get_logger_level = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_rcutils_logging_get_logger_leveln = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Uint64 name_length,
);

typedef _dart_rcutils_logging_get_logger_leveln = int Function(
  ffi.Pointer<ffi.Int8> name,
  int name_length,
);

typedef _c_rcutils_logging_set_logger_level = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 level,
);

typedef _dart_rcutils_logging_set_logger_level = int Function(
  ffi.Pointer<ffi.Int8> name,
  int level,
);

typedef _c_rcutils_logging_logger_is_enabled_for = ffi.Uint8 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 severity,
);

typedef _dart_rcutils_logging_logger_is_enabled_for = int Function(
  ffi.Pointer<ffi.Int8> name,
  int severity,
);

typedef _c_rcutils_logging_get_logger_effective_level = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_rcutils_logging_get_logger_effective_level = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_rcutils_log = ffi.Void Function(
  ffi.Pointer<rcutils_log_location_t> location,
  ffi.Int32 severity,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> format,
);

typedef _dart_rcutils_log = void Function(
  ffi.Pointer<rcutils_log_location_t> location,
  int severity,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> format,
);

typedef _c_rcutils_logging_console_output_handler = ffi.Void Function(
  ffi.Pointer<rcutils_log_location_t> location,
  ffi.Int32 severity,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int64 timestamp,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<ffi.Pointer<__va_list_tag>> args,
);

typedef _dart_rcutils_logging_console_output_handler = void Function(
  ffi.Pointer<rcutils_log_location_t> location,
  int severity,
  ffi.Pointer<ffi.Int8> name,
  int timestamp,
  ffi.Pointer<ffi.Int8> format,
  ffi.Pointer<ffi.Pointer<__va_list_tag>> args,
);

typedef _c_rmw_get_zero_initialized_message_info = rmw_message_info_t
    Function();

typedef _dart_rmw_get_zero_initialized_message_info = rmw_message_info_t
    Function();

typedef _c_rcl_get_zero_initialized_arguments = rcl_arguments_t Function();

typedef _dart_rcl_get_zero_initialized_arguments = rcl_arguments_t Function();

typedef _c_rcl_parse_arguments = ffi.Int32 Function(
  ffi.Int32 argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  rcutils_allocator_t allocator,
  ffi.Pointer<rcl_arguments_t> args_output,
);

typedef _dart_rcl_parse_arguments = int Function(
  int argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  rcutils_allocator_t allocator,
  ffi.Pointer<rcl_arguments_t> args_output,
);

typedef _c_rcl_arguments_get_count_unparsed = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _dart_rcl_arguments_get_count_unparsed = int Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _c_rcl_arguments_get_unparsed = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_indices,
);

typedef _dart_rcl_arguments_get_unparsed = int Function(
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_indices,
);

typedef _c_rcl_arguments_get_count_unparsed_ros = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _dart_rcl_arguments_get_count_unparsed_ros = int Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _c_rcl_arguments_get_unparsed_ros = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_ros_indices,
);

typedef _dart_rcl_arguments_get_unparsed_ros = int Function(
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> output_unparsed_ros_indices,
);

typedef _c_rcl_arguments_get_param_files_count = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _dart_rcl_arguments_get_param_files_count = int Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _c_rcl_arguments_get_param_files = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> arguments,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> parameter_files,
);

typedef _dart_rcl_arguments_get_param_files = int Function(
  ffi.Pointer<rcl_arguments_t> arguments,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> parameter_files,
);

typedef _c_rcl_arguments_get_param_overrides = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> arguments,
  ffi.Pointer<ffi.Pointer<rcl_params_t>> parameter_overrides,
);

typedef _dart_rcl_arguments_get_param_overrides = int Function(
  ffi.Pointer<rcl_arguments_t> arguments,
  ffi.Pointer<ffi.Pointer<rcl_params_t>> parameter_overrides,
);

typedef _c_rcl_remove_ros_arguments = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Int32> nonros_argc,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> nonros_argv,
);

typedef _dart_rcl_remove_ros_arguments = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<rcl_arguments_t> args,
  rcutils_allocator_t allocator,
  ffi.Pointer<ffi.Int32> nonros_argc,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> nonros_argv,
);

typedef _c_rcl_arguments_copy = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
  ffi.Pointer<rcl_arguments_t> args_out,
);

typedef _dart_rcl_arguments_copy = int Function(
  ffi.Pointer<rcl_arguments_t> args,
  ffi.Pointer<rcl_arguments_t> args_out,
);

typedef _c_rcl_arguments_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _dart_rcl_arguments_fini = int Function(
  ffi.Pointer<rcl_arguments_t> args,
);

typedef _c_rcl_get_zero_initialized_init_options = rcl_init_options_t
    Function();

typedef _dart_rcl_get_zero_initialized_init_options = rcl_init_options_t
    Function();

typedef _c_rcl_init_options_init = ffi.Int32 Function(
  ffi.Pointer<rcl_init_options_t> init_options,
  rcutils_allocator_t allocator,
);

typedef _dart_rcl_init_options_init = int Function(
  ffi.Pointer<rcl_init_options_t> init_options,
  rcutils_allocator_t allocator,
);

typedef _c_rcl_init_options_copy = ffi.Int32 Function(
  ffi.Pointer<rcl_init_options_t> src,
  ffi.Pointer<rcl_init_options_t> dst,
);

typedef _dart_rcl_init_options_copy = int Function(
  ffi.Pointer<rcl_init_options_t> src,
  ffi.Pointer<rcl_init_options_t> dst,
);

typedef _c_rcl_init_options_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _dart_rcl_init_options_fini = int Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _c_rcl_init_options_get_rmw_init_options
    = ffi.Pointer<rmw_init_options_t> Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _dart_rcl_init_options_get_rmw_init_options
    = ffi.Pointer<rmw_init_options_t> Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _c_rcl_init_options_get_allocator = ffi.Pointer<rcutils_allocator_t>
    Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _dart_rcl_init_options_get_allocator = ffi.Pointer<rcutils_allocator_t>
    Function(
  ffi.Pointer<rcl_init_options_t> init_options,
);

typedef _c_rcl_get_zero_initialized_context = rcl_context_t Function();

typedef _dart_rcl_get_zero_initialized_context = rcl_context_t Function();

typedef _c_rcl_context_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_fini = int Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_context_get_init_options = ffi.Pointer<rcl_init_options_t>
    Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_get_init_options = ffi.Pointer<rcl_init_options_t>
    Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_context_get_instance_id = ffi.Uint64 Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_get_instance_id = int Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_context_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_is_valid = int Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_context_get_rmw_context = ffi.Pointer<rmw_context_t> Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_context_get_rmw_context = ffi.Pointer<rmw_context_t> Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_init = ffi.Int32 Function(
  ffi.Int32 argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<rcl_init_options_t> options,
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_init = int Function(
  int argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<rcl_init_options_t> options,
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_shutdown = ffi.Int32 Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _dart_rcl_shutdown = int Function(
  ffi.Pointer<rcl_context_t> context,
);

typedef _c_rcl_get_default_domain_id = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint64> domain_id,
);

typedef _dart_rcl_get_default_domain_id = int Function(
  ffi.Pointer<ffi.Uint64> domain_id,
);

typedef _c_rcl_node_get_default_options = rcl_node_options_t Function();

typedef _dart_rcl_node_get_default_options = rcl_node_options_t Function();

typedef _c_rcl_node_options_copy = ffi.Int32 Function(
  ffi.Pointer<rcl_node_options_t> options,
  ffi.Pointer<rcl_node_options_t> options_out,
);

typedef _dart_rcl_node_options_copy = int Function(
  ffi.Pointer<rcl_node_options_t> options,
  ffi.Pointer<rcl_node_options_t> options_out,
);

typedef _c_rcl_node_options_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_node_options_t> options,
);

typedef _dart_rcl_node_options_fini = int Function(
  ffi.Pointer<rcl_node_options_t> options,
);

typedef _c_rcl_get_zero_initialized_node = rcl_node_t Function();

typedef _dart_rcl_get_zero_initialized_node = rcl_node_t Function();

typedef _c_rcl_node_init = ffi.Int32 Function(
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> namespace_,
  ffi.Pointer<rcl_context_t> context,
  ffi.Pointer<rcl_node_options_t> options,
);

typedef _dart_rcl_node_init = int Function(
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> namespace_,
  ffi.Pointer<rcl_context_t> context,
  ffi.Pointer<rcl_node_options_t> options,
);

typedef _c_rcl_node_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_fini = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_is_valid = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_is_valid_except_context = ffi.Uint8 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_is_valid_except_context = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_namespace = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_namespace = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_fully_qualified_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_fully_qualified_name = ffi.Pointer<ffi.Int8>
    Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_options = ffi.Pointer<rcl_node_options_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_options = ffi.Pointer<rcl_node_options_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_domain_id = ffi.Int32 Function(
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<ffi.Uint64> domain_id,
);

typedef _dart_rcl_node_get_domain_id = int Function(
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<ffi.Uint64> domain_id,
);

typedef _c_rcl_node_get_rmw_handle = ffi.Pointer<rmw_node_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_rmw_handle = ffi.Pointer<rmw_node_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_rcl_instance_id = ffi.Uint64 Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_rcl_instance_id = int Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_graph_guard_condition
    = ffi.Pointer<rcl_guard_condition_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_graph_guard_condition
    = ffi.Pointer<rcl_guard_condition_t> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_node_get_logger_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_node_get_logger_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_get_message_typesupport_handle
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_message_typesupport_handle
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_get_message_typesupport_handle_function
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_message_typesupport_handle_function
    = ffi.Pointer<rosidl_message_type_support_t> Function(
  ffi.Pointer<rosidl_message_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_rcl_get_zero_initialized_publisher = rcl_publisher_t Function();

typedef _dart_rcl_get_zero_initialized_publisher = rcl_publisher_t Function();

typedef _c_rcl_publisher_init = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rcl_publisher_options_t> options,
);

typedef _dart_rcl_publisher_init = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rcl_publisher_options_t> options,
);

typedef _c_rcl_publisher_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_publisher_fini = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_publisher_get_default_options = rcl_publisher_options_t
    Function();

typedef _dart_rcl_publisher_get_default_options = rcl_publisher_options_t
    Function();

typedef _c_rcl_borrow_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
);

typedef _dart_rcl_borrow_loaned_message = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
);

typedef _c_rcl_return_loaned_message_from_publisher = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _dart_rcl_return_loaned_message_from_publisher = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _c_rcl_publish = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rcl_publish = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rcl_publish_serialized_message = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rcl_publish_serialized_message = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rcl_publish_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rcl_publish_loaned_message = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rcl_publisher_assert_liveliness = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_assert_liveliness = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_topic_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_topic_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_options = ffi.Pointer<rcl_publisher_options_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_options = ffi.Pointer<rcl_publisher_options_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_rmw_handle = ffi.Pointer<rmw_publisher_t> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_rmw_handle = ffi.Pointer<rmw_publisher_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_context = ffi.Pointer<rcl_context_t> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_context = ffi.Pointer<rcl_context_t> Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_is_valid = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_is_valid_except_context = ffi.Uint8 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_is_valid_except_context = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_get_subscription_count = ffi.Int32 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Uint64> subscription_count,
);

typedef _dart_rcl_publisher_get_subscription_count = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Pointer<ffi.Uint64> subscription_count,
);

typedef _c_rcl_publisher_get_actual_qos = ffi.Pointer<rmw_qos_profile_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_get_actual_qos = ffi.Pointer<rmw_qos_profile_t>
    Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rcl_publisher_can_loan_messages = ffi.Uint8 Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _dart_rcl_publisher_can_loan_messages = int Function(
  ffi.Pointer<rcl_publisher_t> publisher,
);

typedef _c_rmw_get_zero_initialized_message_sequence = rmw_message_sequence_t
    Function();

typedef _dart_rmw_get_zero_initialized_message_sequence = rmw_message_sequence_t
    Function();

typedef _c_rmw_message_sequence_init = ffi.Int32 Function(
  ffi.Pointer<rmw_message_sequence_t> sequence,
  ffi.Uint64 size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rmw_message_sequence_init = int Function(
  ffi.Pointer<rmw_message_sequence_t> sequence,
  int size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rmw_message_sequence_fini = ffi.Int32 Function(
  ffi.Pointer<rmw_message_sequence_t> sequence,
);

typedef _dart_rmw_message_sequence_fini = int Function(
  ffi.Pointer<rmw_message_sequence_t> sequence,
);

typedef _c_rmw_get_zero_initialized_message_info_sequence
    = rmw_message_info_sequence_t Function();

typedef _dart_rmw_get_zero_initialized_message_info_sequence
    = rmw_message_info_sequence_t Function();

typedef _c_rmw_message_info_sequence_init = ffi.Int32 Function(
  ffi.Pointer<rmw_message_info_sequence_t> sequence,
  ffi.Uint64 size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rmw_message_info_sequence_init = int Function(
  ffi.Pointer<rmw_message_info_sequence_t> sequence,
  int size,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rmw_message_info_sequence_fini = ffi.Int32 Function(
  ffi.Pointer<rmw_message_info_sequence_t> sequence,
);

typedef _dart_rmw_message_info_sequence_fini = int Function(
  ffi.Pointer<rmw_message_info_sequence_t> sequence,
);

typedef _c_rcl_get_zero_initialized_subscription = rcl_subscription_t
    Function();

typedef _dart_rcl_get_zero_initialized_subscription = rcl_subscription_t
    Function();

typedef _c_rcl_subscription_init = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rcl_subscription_options_t> options,
);

typedef _dart_rcl_subscription_init = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rcl_subscription_options_t> options,
);

typedef _c_rcl_subscription_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_subscription_fini = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_subscription_get_default_options = rcl_subscription_options_t
    Function();

typedef _dart_rcl_subscription_get_default_options = rcl_subscription_options_t
    Function();

typedef _c_rcl_take = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rcl_take = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rcl_take_sequence = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Uint64 count,
  ffi.Pointer<rmw_message_sequence_t> message_sequence,
  ffi.Pointer<rmw_message_info_sequence_t> message_info_sequence,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rcl_take_sequence = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  int count,
  ffi.Pointer<rmw_message_sequence_t> message_sequence,
  ffi.Pointer<rmw_message_info_sequence_t> message_info_sequence,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rcl_take_serialized_message = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rcl_take_serialized_message = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rcl_take_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rcl_take_loaned_message = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rcl_return_loaned_message_from_subscription = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _dart_rcl_return_loaned_message_from_subscription = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _c_rcl_subscription_get_topic_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_get_topic_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_get_options
    = ffi.Pointer<rcl_subscription_options_t> Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_get_options
    = ffi.Pointer<rcl_subscription_options_t> Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_get_rmw_handle = ffi.Pointer<rmw_subscription_t>
    Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_get_rmw_handle = ffi.Pointer<rmw_subscription_t>
    Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_is_valid = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_get_publisher_count = ffi.Int32 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> publisher_count,
);

typedef _dart_rcl_subscription_get_publisher_count = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> publisher_count,
);

typedef _c_rcl_subscription_get_actual_qos = ffi.Pointer<rmw_qos_profile_t>
    Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_get_actual_qos = ffi.Pointer<rmw_qos_profile_t>
    Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_rcl_subscription_can_loan_messages = ffi.Uint8 Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _dart_rcl_subscription_can_loan_messages = int Function(
  ffi.Pointer<rcl_subscription_t> subscription,
);

typedef _c_get_service_typesupport_handle
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_service_typesupport_handle
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_get_service_typesupport_handle_function
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_service_typesupport_handle_function
    = ffi.Pointer<rosidl_service_type_support_t> Function(
  ffi.Pointer<rosidl_service_type_support_t> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_rcl_get_zero_initialized_client = rcl_client_t Function();

typedef _dart_rcl_get_zero_initialized_client = rcl_client_t Function();

typedef _c_rcl_client_init = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rcl_client_options_t> options,
);

typedef _dart_rcl_client_init = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rcl_client_options_t> options,
);

typedef _c_rcl_client_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_client_fini = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_client_get_default_options = rcl_client_options_t Function();

typedef _dart_rcl_client_get_default_options = rcl_client_options_t Function();

typedef _c_rcl_send_request = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Int64> sequence_number,
);

typedef _dart_rcl_send_request = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Int64> sequence_number,
);

typedef _c_rcl_take_response_with_info = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rmw_service_info_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _dart_rcl_take_response_with_info = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rmw_service_info_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _c_rcl_take_response = ffi.Int32 Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _dart_rcl_take_response = int Function(
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _c_rcl_client_get_service_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _dart_rcl_client_get_service_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _c_rcl_client_get_options = ffi.Pointer<rcl_client_options_t> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _dart_rcl_client_get_options = ffi.Pointer<rcl_client_options_t>
    Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _c_rcl_client_get_rmw_handle = ffi.Pointer<rmw_client_t> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _dart_rcl_client_get_rmw_handle = ffi.Pointer<rmw_client_t> Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _c_rcl_client_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _dart_rcl_client_is_valid = int Function(
  ffi.Pointer<rcl_client_t> client,
);

typedef _c_rcl_get_zero_initialized_guard_condition = rcl_guard_condition_t
    Function();

typedef _dart_rcl_get_zero_initialized_guard_condition = rcl_guard_condition_t
    Function();

typedef _c_rcl_guard_condition_init = ffi.Int32 Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<rcl_context_t> context,
  rcl_guard_condition_options_t options,
);

typedef _dart_rcl_guard_condition_init = int Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<rcl_context_t> context,
  rcl_guard_condition_options_t options,
);

typedef _c_rcl_guard_condition_init_from_rmw = ffi.Int32 Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<rmw_guard_condition_t> rmw_guard_condition,
  ffi.Pointer<rcl_context_t> context,
  rcl_guard_condition_options_t options,
);

typedef _dart_rcl_guard_condition_init_from_rmw = int Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<rmw_guard_condition_t> rmw_guard_condition,
  ffi.Pointer<rcl_context_t> context,
  rcl_guard_condition_options_t options,
);

typedef _c_rcl_guard_condition_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _dart_rcl_guard_condition_fini = int Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _c_rcl_guard_condition_get_default_options
    = rcl_guard_condition_options_t Function();

typedef _dart_rcl_guard_condition_get_default_options
    = rcl_guard_condition_options_t Function();

typedef _c_rcl_trigger_guard_condition = ffi.Int32 Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _dart_rcl_trigger_guard_condition = int Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _c_rcl_guard_condition_get_options
    = ffi.Pointer<rcl_guard_condition_options_t> Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _dart_rcl_guard_condition_get_options
    = ffi.Pointer<rcl_guard_condition_options_t> Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _c_rcl_guard_condition_get_rmw_handle
    = ffi.Pointer<rmw_guard_condition_t> Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _dart_rcl_guard_condition_get_rmw_handle
    = ffi.Pointer<rmw_guard_condition_t> Function(
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
);

typedef _c_rcl_get_zero_initialized_service = rcl_service_t Function();

typedef _dart_rcl_get_zero_initialized_service = rcl_service_t Function();

typedef _c_rcl_service_init = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rcl_service_options_t> options,
);

typedef _dart_rcl_service_init = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rcl_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rcl_service_options_t> options,
);

typedef _c_rcl_service_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rcl_node_t> node,
);

typedef _dart_rcl_service_fini = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rcl_node_t> node,
);

typedef _c_rcl_service_get_default_options = rcl_service_options_t Function();

typedef _dart_rcl_service_get_default_options = rcl_service_options_t
    Function();

typedef _c_rcl_take_request_with_info = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_service_info_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
);

typedef _dart_rcl_take_request_with_info = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_service_info_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
);

typedef _c_rcl_take_request = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
);

typedef _dart_rcl_take_request = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
);

typedef _c_rcl_send_response = ffi.Int32 Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_request_id_t> response_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _dart_rcl_send_response = int Function(
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<rmw_request_id_t> response_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _c_rcl_service_get_service_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _dart_rcl_service_get_service_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _c_rcl_service_get_options = ffi.Pointer<rcl_service_options_t>
    Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _dart_rcl_service_get_options = ffi.Pointer<rcl_service_options_t>
    Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _c_rcl_service_get_rmw_handle = ffi.Pointer<rmw_service_t> Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _dart_rcl_service_get_rmw_handle = ffi.Pointer<rmw_service_t> Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _c_rcl_service_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _dart_rcl_service_is_valid = int Function(
  ffi.Pointer<rcl_service_t> service,
);

typedef _c_rcl_clock_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_clock_valid = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_clock_init = ffi.Int32 Function(
  ffi.Int32 clock_type,
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_clock_init = int Function(
  int clock_type,
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_clock_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_clock_fini = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_ros_clock_init = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_ros_clock_init = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_ros_clock_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_ros_clock_fini = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_steady_clock_init = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_steady_clock_init = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_steady_clock_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_steady_clock_fini = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_system_clock_init = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_system_clock_init = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_system_clock_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_system_clock_fini = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_difference_times = ffi.Int32 Function(
  ffi.Pointer<rcl_time_point_t> start,
  ffi.Pointer<rcl_time_point_t> finish,
  ffi.Pointer<rcl_duration_t> delta,
);

typedef _dart_rcl_difference_times = int Function(
  ffi.Pointer<rcl_time_point_t> start,
  ffi.Pointer<rcl_time_point_t> finish,
  ffi.Pointer<rcl_duration_t> delta,
);

typedef _c_rcl_clock_get_now = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.Int64> time_point_value,
);

typedef _dart_rcl_clock_get_now = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.Int64> time_point_value,
);

typedef _c_rcl_enable_ros_time_override = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_enable_ros_time_override = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_disable_ros_time_override = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _dart_rcl_disable_ros_time_override = int Function(
  ffi.Pointer<rcl_clock_t> clock,
);

typedef _c_rcl_is_enabled_ros_time_override = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.Uint8> is_enabled,
);

typedef _dart_rcl_is_enabled_ros_time_override = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.Uint8> is_enabled,
);

typedef _c_rcl_set_ros_time_override = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Int64 time_value,
);

typedef _dart_rcl_set_ros_time_override = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  int time_value,
);

typedef rcl_jump_callback_t = ffi.Void Function(
  ffi.Pointer<rcl_time_jump_t>,
  ffi.Uint8,
  ffi.Pointer<ffi.Void>,
);

typedef _c_rcl_clock_add_jump_callback = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  rcl_jump_threshold_t threshold,
  ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _dart_rcl_clock_add_jump_callback = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  rcl_jump_threshold_t threshold,
  ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _c_rcl_clock_remove_jump_callback = ffi.Int32 Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _dart_rcl_clock_remove_jump_callback = int Function(
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<ffi.NativeFunction<rcl_jump_callback_t>> callback,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _c_get_sequence_bound_handle
    = ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_sequence_bound_handle
    = ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_get_sequence_bound_handle_function
    = ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _dart_get_sequence_bound_handle_function
    = ffi.Pointer<rosidl_runtime_c__Sequence__bound> Function(
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> handle,
  ffi.Pointer<ffi.Int8> identifier,
);

typedef _c_rmw_get_default_subscription_options = rmw_subscription_options_t
    Function();

typedef _dart_rmw_get_default_subscription_options = rmw_subscription_options_t
    Function();

typedef _c_rmw_get_implementation_identifier = ffi.Pointer<ffi.Int8> Function();

typedef _dart_rmw_get_implementation_identifier = ffi.Pointer<ffi.Int8>
    Function();

typedef _c_rmw_get_serialization_format = ffi.Pointer<ffi.Int8> Function();

typedef _dart_rmw_get_serialization_format = ffi.Pointer<ffi.Int8> Function();

typedef _c_rmw_create_node = ffi.Pointer<rmw_node_t> Function(
  ffi.Pointer<rmw_context_t> context,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> namespace_,
  ffi.Uint64 domain_id,
  ffi.Uint8 localhost_only,
);

typedef _dart_rmw_create_node = ffi.Pointer<rmw_node_t> Function(
  ffi.Pointer<rmw_context_t> context,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> namespace_,
  int domain_id,
  int localhost_only,
);

typedef _c_rmw_destroy_node = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _dart_rmw_destroy_node = int Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _c_rmw_node_assert_liveliness = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _dart_rmw_node_assert_liveliness = int Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _c_rmw_node_get_graph_guard_condition
    = ffi.Pointer<rmw_guard_condition_t> Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _dart_rmw_node_get_graph_guard_condition
    = ffi.Pointer<rmw_guard_condition_t> Function(
  ffi.Pointer<rmw_node_t> node,
);

typedef _c_rmw_init_publisher_allocation = ffi.Int32 Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_init_publisher_allocation = int Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_fini_publisher_allocation = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_fini_publisher_allocation = int Function(
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_get_default_publisher_options = rmw_publisher_options_t
    Function();

typedef _dart_rmw_get_default_publisher_options = rmw_publisher_options_t
    Function();

typedef _c_rmw_create_publisher = ffi.Pointer<rmw_publisher_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rmw_qos_profile_t> qos_profile,
  ffi.Pointer<rmw_publisher_options_t> publisher_options,
);

typedef _dart_rmw_create_publisher = ffi.Pointer<rmw_publisher_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rmw_qos_profile_t> qos_profile,
  ffi.Pointer<rmw_publisher_options_t> publisher_options,
);

typedef _c_rmw_destroy_publisher = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_publisher_t> publisher,
);

typedef _dart_rmw_destroy_publisher = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_publisher_t> publisher,
);

typedef _c_rmw_borrow_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
);

typedef _dart_rmw_borrow_loaned_message = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Pointer<ffi.Void>> ros_message,
);

typedef _c_rmw_return_loaned_message_from_publisher = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _dart_rmw_return_loaned_message_from_publisher = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _c_rmw_publish = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_publish = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_publish_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_publish_loaned_message = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_publisher_count_matched_subscriptions = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Uint64> subscription_count,
);

typedef _dart_rmw_publisher_count_matched_subscriptions = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<ffi.Uint64> subscription_count,
);

typedef _c_rmw_publisher_get_actual_qos = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rmw_qos_profile_t> qos,
);

typedef _dart_rmw_publisher_get_actual_qos = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rmw_qos_profile_t> qos,
);

typedef _c_rmw_publish_serialized_message = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _dart_rmw_publish_serialized_message = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rmw_publisher_allocation_t> allocation,
);

typedef _c_rmw_get_serialized_message_size = ffi.Int32 Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_rmw_get_serialized_message_size = int Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_rmw_publisher_assert_liveliness = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
);

typedef _dart_rmw_publisher_assert_liveliness = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
);

typedef _c_rmw_serialize = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
);

typedef _dart_rmw_serialize = int Function(
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
);

typedef _c_rmw_deserialize = ffi.Int32 Function(
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Void> ros_message,
);

typedef _dart_rmw_deserialize = int Function(
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Void> ros_message,
);

typedef _c_rmw_init_subscription_allocation = ffi.Int32 Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_init_subscription_allocation = int Function(
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<rosidl_runtime_c__Sequence__bound> message_bounds,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_fini_subscription_allocation = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_fini_subscription_allocation = int Function(
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_create_subscription = ffi.Pointer<rmw_subscription_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ffi.Pointer<rmw_subscription_options_t> subscription_options,
);

typedef _dart_rmw_create_subscription = ffi.Pointer<rmw_subscription_t>
    Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_message_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
  ffi.Pointer<rmw_subscription_options_t> subscription_options,
);

typedef _c_rmw_destroy_subscription = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_subscription_t> subscription,
);

typedef _dart_rmw_destroy_subscription = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_subscription_t> subscription,
);

typedef _c_rmw_subscription_count_matched_publishers = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> publisher_count,
);

typedef _dart_rmw_subscription_count_matched_publishers = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> publisher_count,
);

typedef _c_rmw_subscription_get_actual_qos = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rmw_qos_profile_t> qos,
);

typedef _dart_rmw_subscription_get_actual_qos = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rmw_qos_profile_t> qos,
);

typedef _c_rmw_take = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_with_info = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_with_info = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> ros_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_sequence = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Uint64 count,
  ffi.Pointer<rmw_message_sequence_t> message_sequence,
  ffi.Pointer<rmw_message_info_sequence_t> message_info_sequence,
  ffi.Pointer<ffi.Uint64> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_sequence = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  int count,
  ffi.Pointer<rmw_message_sequence_t> message_sequence,
  ffi.Pointer<rmw_message_info_sequence_t> message_info_sequence,
  ffi.Pointer<ffi.Uint64> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_serialized_message = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_serialized_message = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_serialized_message_with_info = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_serialized_message_with_info = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<rcutils_uint8_array_t> serialized_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_loaned_message = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_loaned_message = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_take_loaned_message_with_info = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _dart_rmw_take_loaned_message_with_info = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Pointer<ffi.Void>> loaned_message,
  ffi.Pointer<ffi.Uint8> taken,
  ffi.Pointer<rmw_message_info_t> message_info,
  ffi.Pointer<rmw_subscription_allocation_t> allocation,
);

typedef _c_rmw_return_loaned_message_from_subscription = ffi.Int32 Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _dart_rmw_return_loaned_message_from_subscription = int Function(
  ffi.Pointer<rmw_subscription_t> subscription,
  ffi.Pointer<ffi.Void> loaned_message,
);

typedef _c_rmw_create_client = ffi.Pointer<rmw_client_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
);

typedef _dart_rmw_create_client = ffi.Pointer<rmw_client_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rmw_qos_profile_t> qos_policies,
);

typedef _c_rmw_destroy_client = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_client_t> client,
);

typedef _dart_rmw_destroy_client = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_client_t> client,
);

typedef _c_rmw_send_request = ffi.Int32 Function(
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Int64> sequence_id,
);

typedef _dart_rmw_send_request = int Function(
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Int64> sequence_id,
);

typedef _c_rmw_take_response = ffi.Int32 Function(
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<rmw_service_info_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
  ffi.Pointer<ffi.Uint8> taken,
);

typedef _dart_rmw_take_response = int Function(
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<rmw_service_info_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
  ffi.Pointer<ffi.Uint8> taken,
);

typedef _c_rmw_create_service = ffi.Pointer<rmw_service_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rmw_qos_profile_t> qos_profile,
);

typedef _dart_rmw_create_service = ffi.Pointer<rmw_service_t> Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rosidl_service_type_support_t> type_support,
  ffi.Pointer<ffi.Int8> service_name,
  ffi.Pointer<rmw_qos_profile_t> qos_profile,
);

typedef _c_rmw_destroy_service = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_service_t> service,
);

typedef _dart_rmw_destroy_service = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_service_t> service,
);

typedef _c_rmw_take_request = ffi.Int32 Function(
  ffi.Pointer<rmw_service_t> service,
  ffi.Pointer<rmw_service_info_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Uint8> taken,
);

typedef _dart_rmw_take_request = int Function(
  ffi.Pointer<rmw_service_t> service,
  ffi.Pointer<rmw_service_info_t> request_header,
  ffi.Pointer<ffi.Void> ros_request,
  ffi.Pointer<ffi.Uint8> taken,
);

typedef _c_rmw_send_response = ffi.Int32 Function(
  ffi.Pointer<rmw_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _dart_rmw_send_response = int Function(
  ffi.Pointer<rmw_service_t> service,
  ffi.Pointer<rmw_request_id_t> request_header,
  ffi.Pointer<ffi.Void> ros_response,
);

typedef _c_rmw_create_guard_condition = ffi.Pointer<rmw_guard_condition_t>
    Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _dart_rmw_create_guard_condition = ffi.Pointer<rmw_guard_condition_t>
    Function(
  ffi.Pointer<rmw_context_t> context,
);

typedef _c_rmw_destroy_guard_condition = ffi.Int32 Function(
  ffi.Pointer<rmw_guard_condition_t> guard_condition,
);

typedef _dart_rmw_destroy_guard_condition = int Function(
  ffi.Pointer<rmw_guard_condition_t> guard_condition,
);

typedef _c_rmw_trigger_guard_condition = ffi.Int32 Function(
  ffi.Pointer<rmw_guard_condition_t> guard_condition,
);

typedef _dart_rmw_trigger_guard_condition = int Function(
  ffi.Pointer<rmw_guard_condition_t> guard_condition,
);

typedef _c_rmw_create_wait_set = ffi.Pointer<rmw_wait_set_t> Function(
  ffi.Pointer<rmw_context_t> context,
  ffi.Uint64 max_conditions,
);

typedef _dart_rmw_create_wait_set = ffi.Pointer<rmw_wait_set_t> Function(
  ffi.Pointer<rmw_context_t> context,
  int max_conditions,
);

typedef _c_rmw_destroy_wait_set = ffi.Int32 Function(
  ffi.Pointer<rmw_wait_set_t> wait_set,
);

typedef _dart_rmw_destroy_wait_set = int Function(
  ffi.Pointer<rmw_wait_set_t> wait_set,
);

typedef _c_rmw_wait = ffi.Int32 Function(
  ffi.Pointer<rmw_subscriptions_t> subscriptions,
  ffi.Pointer<rmw_guard_conditions_t> guard_conditions,
  ffi.Pointer<rmw_services_t> services,
  ffi.Pointer<rmw_clients_t> clients,
  ffi.Pointer<rmw_events_t> events,
  ffi.Pointer<rmw_wait_set_t> wait_set,
  ffi.Pointer<rmw_time_t> wait_timeout,
);

typedef _dart_rmw_wait = int Function(
  ffi.Pointer<rmw_subscriptions_t> subscriptions,
  ffi.Pointer<rmw_guard_conditions_t> guard_conditions,
  ffi.Pointer<rmw_services_t> services,
  ffi.Pointer<rmw_clients_t> clients,
  ffi.Pointer<rmw_events_t> events,
  ffi.Pointer<rmw_wait_set_t> wait_set,
  ffi.Pointer<rmw_time_t> wait_timeout,
);

typedef _c_rmw_get_node_names = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rcutils_string_array_t> node_names,
  ffi.Pointer<rcutils_string_array_t> node_namespaces,
);

typedef _dart_rmw_get_node_names = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rcutils_string_array_t> node_names,
  ffi.Pointer<rcutils_string_array_t> node_namespaces,
);

typedef _c_rmw_get_node_names_with_enclaves = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rcutils_string_array_t> node_names,
  ffi.Pointer<rcutils_string_array_t> node_namespaces,
  ffi.Pointer<rcutils_string_array_t> enclaves,
);

typedef _dart_rmw_get_node_names_with_enclaves = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rcutils_string_array_t> node_names,
  ffi.Pointer<rcutils_string_array_t> node_namespaces,
  ffi.Pointer<rcutils_string_array_t> enclaves,
);

typedef _c_rmw_count_publishers = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<ffi.Uint64> count,
);

typedef _dart_rmw_count_publishers = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<ffi.Uint64> count,
);

typedef _c_rmw_count_subscribers = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<ffi.Uint64> count,
);

typedef _dart_rmw_count_subscribers = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<ffi.Int8> topic_name,
  ffi.Pointer<ffi.Uint64> count,
);

typedef _c_rmw_get_gid_for_publisher = ffi.Int32 Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rmw_gid_t> gid,
);

typedef _dart_rmw_get_gid_for_publisher = int Function(
  ffi.Pointer<rmw_publisher_t> publisher,
  ffi.Pointer<rmw_gid_t> gid,
);

typedef _c_rmw_compare_gids_equal = ffi.Int32 Function(
  ffi.Pointer<rmw_gid_t> gid1,
  ffi.Pointer<rmw_gid_t> gid2,
  ffi.Pointer<ffi.Uint8> result,
);

typedef _dart_rmw_compare_gids_equal = int Function(
  ffi.Pointer<rmw_gid_t> gid1,
  ffi.Pointer<rmw_gid_t> gid2,
  ffi.Pointer<ffi.Uint8> result,
);

typedef _c_rmw_service_server_is_available = ffi.Int32 Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<ffi.Uint8> is_available,
);

typedef _dart_rmw_service_server_is_available = int Function(
  ffi.Pointer<rmw_node_t> node,
  ffi.Pointer<rmw_client_t> client,
  ffi.Pointer<ffi.Uint8> is_available,
);

typedef _c_rmw_set_log_severity = ffi.Int32 Function(
  ffi.Int32 severity,
);

typedef _dart_rmw_set_log_severity = int Function(
  int severity,
);

typedef _c_rcl_get_zero_initialized_timer = rcl_timer_t Function();

typedef _dart_rcl_get_zero_initialized_timer = rcl_timer_t Function();

typedef rcl_timer_callback_t = ffi.Void Function(
  ffi.Pointer<rcl_timer_t>,
  ffi.Int64,
);

typedef _c_rcl_timer_init = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcl_context_t> context,
  ffi.Int64 period,
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> callback,
  rcutils_allocator_t allocator,
);

typedef _dart_rcl_timer_init = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<rcl_clock_t> clock,
  ffi.Pointer<rcl_context_t> context,
  int period,
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> callback,
  rcutils_allocator_t allocator,
);

typedef _c_rcl_timer_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_fini = int Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_call = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_call = int Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_clock = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Pointer<rcl_clock_t>> clock,
);

typedef _dart_rcl_timer_clock = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Pointer<rcl_clock_t>> clock,
);

typedef _c_rcl_timer_is_ready = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint8> is_ready,
);

typedef _dart_rcl_timer_is_ready = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint8> is_ready,
);

typedef _c_rcl_timer_get_time_until_next_call = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> time_until_next_call,
);

typedef _dart_rcl_timer_get_time_until_next_call = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> time_until_next_call,
);

typedef _c_rcl_timer_get_time_since_last_call = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> time_since_last_call,
);

typedef _dart_rcl_timer_get_time_since_last_call = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> time_since_last_call,
);

typedef _c_rcl_timer_get_period = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> period,
);

typedef _dart_rcl_timer_get_period = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Int64> period,
);

typedef _c_rcl_timer_exchange_period = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Int64 new_period,
  ffi.Pointer<ffi.Int64> old_period,
);

typedef _dart_rcl_timer_exchange_period = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  int new_period,
  ffi.Pointer<ffi.Int64> old_period,
);

typedef _c_rcl_timer_get_callback
    = ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_get_callback
    = ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_exchange_callback
    = ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> new_callback,
);

typedef _dart_rcl_timer_exchange_callback
    = ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.NativeFunction<rcl_timer_callback_t>> new_callback,
);

typedef _c_rcl_timer_cancel = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_cancel = int Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_is_canceled = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint8> is_canceled,
);

typedef _dart_rcl_timer_is_canceled = int Function(
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint8> is_canceled,
);

typedef _c_rcl_timer_reset = ffi.Int32 Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_reset = int Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_get_allocator = ffi.Pointer<rcutils_allocator_t> Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_get_allocator = ffi.Pointer<rcutils_allocator_t>
    Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_timer_get_guard_condition = ffi.Pointer<rcl_guard_condition_t>
    Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _dart_rcl_timer_get_guard_condition = ffi.Pointer<rcl_guard_condition_t>
    Function(
  ffi.Pointer<rcl_timer_t> timer,
);

typedef _c_rcl_get_zero_initialized_event = rcl_event_t Function();

typedef _dart_rcl_get_zero_initialized_event = rcl_event_t Function();

typedef _c_rcl_publisher_event_init = ffi.Int32 Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<rcl_publisher_t> publisher,
  ffi.Int32 event_type,
);

typedef _dart_rcl_publisher_event_init = int Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<rcl_publisher_t> publisher,
  int event_type,
);

typedef _c_rcl_subscription_event_init = ffi.Int32 Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Int32 event_type,
);

typedef _dart_rcl_subscription_event_init = int Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<rcl_subscription_t> subscription,
  int event_type,
);

typedef _c_rcl_take_event = ffi.Int32 Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<ffi.Void> event_info,
);

typedef _dart_rcl_take_event = int Function(
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<ffi.Void> event_info,
);

typedef _c_rcl_event_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_event_t> event,
);

typedef _dart_rcl_event_fini = int Function(
  ffi.Pointer<rcl_event_t> event,
);

typedef _c_rcl_event_get_rmw_handle = ffi.Pointer<rmw_event_t> Function(
  ffi.Pointer<rcl_event_t> event,
);

typedef _dart_rcl_event_get_rmw_handle = ffi.Pointer<rmw_event_t> Function(
  ffi.Pointer<rcl_event_t> event,
);

typedef _c_rcl_get_zero_initialized_wait_set = rcl_wait_set_t Function();

typedef _dart_rcl_get_zero_initialized_wait_set = rcl_wait_set_t Function();

typedef _c_rcl_wait_set_init = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Uint64 number_of_subscriptions,
  ffi.Uint64 number_of_guard_conditions,
  ffi.Uint64 number_of_timers,
  ffi.Uint64 number_of_clients,
  ffi.Uint64 number_of_services,
  ffi.Uint64 number_of_events,
  ffi.Pointer<rcl_context_t> context,
  rcutils_allocator_t allocator,
);

typedef _dart_rcl_wait_set_init = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  int number_of_subscriptions,
  int number_of_guard_conditions,
  int number_of_timers,
  int number_of_clients,
  int number_of_services,
  int number_of_events,
  ffi.Pointer<rcl_context_t> context,
  rcutils_allocator_t allocator,
);

typedef _c_rcl_wait_set_fini = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _dart_rcl_wait_set_fini = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _c_rcl_wait_set_get_allocator = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _dart_rcl_wait_set_get_allocator = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcutils_allocator_t> allocator,
);

typedef _c_rcl_wait_set_add_subscription = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_subscription = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_subscription_t> subscription,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_clear = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _dart_rcl_wait_set_clear = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _c_rcl_wait_set_resize = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Uint64 subscriptions_size,
  ffi.Uint64 guard_conditions_size,
  ffi.Uint64 timers_size,
  ffi.Uint64 clients_size,
  ffi.Uint64 services_size,
  ffi.Uint64 events_size,
);

typedef _dart_rcl_wait_set_resize = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  int subscriptions_size,
  int guard_conditions_size,
  int timers_size,
  int clients_size,
  int services_size,
  int events_size,
);

typedef _c_rcl_wait_set_add_guard_condition = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_guard_condition = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_guard_condition_t> guard_condition,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_add_timer = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_timer = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_timer_t> timer,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_add_client = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_client = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_client_t> client,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_add_service = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_service = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_service_t> service,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait_set_add_event = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _dart_rcl_wait_set_add_event = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Pointer<rcl_event_t> event,
  ffi.Pointer<ffi.Uint64> index,
);

typedef _c_rcl_wait = ffi.Int32 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  ffi.Int64 timeout,
);

typedef _dart_rcl_wait = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
  int timeout,
);

typedef _c_rcl_wait_set_is_valid = ffi.Uint8 Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _dart_rcl_wait_set_is_valid = int Function(
  ffi.Pointer<rcl_wait_set_t> wait_set,
);

typedef _typedefC_1 = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_2 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_3 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Uint64,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_4 = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64,
  ffi.Uint64,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_6 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Int64>,
);
